2024 09 26 10 03 44 - YouTube
https://www.youtube.com/watch?v=NmPKjvu9JVQ

Transcript:
(00:09) Hola cómo están Cómo están Oigan a quién le gustan las películas de cuento intino de aquí bien también poquito en serio es que ayer estaba viendo p Fiction Y qué buena est dos o tres nueve o sea escritas escritas por él porque Ajá o sea había varias no según yo iba a ser 10 pero o sea escritas por él sí Fiction está muy buena la de Hollywood también pero creo que me gusta más la de perros de reserva o sea tiene escenas más como
(01:13) que más más filosóficas si lo ven así sí pero perros de reserva es la que más me gusta también bastardo sin gloria Sí pero yo creo o sea yo yo creo que mi top es perros de reserva luego luego Bueno a la par está la de vez en Hollywood luego los ocho más odiados y luego bastardos sin gloria yo creo pero sí están muy buenas la verdad si no han visto peros de Reserva la verdad se las recomiendo o sea es si entren mi top de películas favorit y las de Kill No sí vean perros de reserva o sea perros de reserva s es de
(02:07) mis de mis favoritas de la vida okay Entonces vamos a eh eh vamos a empezar con eh esta parte de eh los snapshots son los otros ejercicios de su tarea el el ejercicio uno ya lo tienen no O tienen dudas del ejercicio uno para regresarnos sí está sencillo Okay si tienen dudas de ese me avisan y nos regresamos Entonces vamos a empezar la idea es revisar hoy la parte de snapshots para poder ver si podemos sacar el ejercicio dos y el ejercicio TR y el martes siguiente eh ver el
(03:14) ejercicio el ejercicio dos tres y y el martes siguiente ver el ejercicio 4at y C yo espero porque Bueno sí me quiero apurar tantito porque no sé si les voy a poder dar clase el jueves es porque tengo que ir a hacer mi examen de doctorado entonces pero vamos viendo no Pero igual hay que aportarnos un poquito para que para que le salga su tarea bien no les parece o no les parece entonces va acuérdense que la clase pasada estábamos viendo esta parte de registros seguros registros regulares y registros atómicos el registro más seguro era el
(04:07) registro atómico Y por qué era el más seguro o sea qué les garantiza el registro atómico que no ni el seguro ni el regular qué les garantiza el atómico Exacto que en el caso de traslado regrese cualquier valor devolver el último valor actualizado muy bien Sí muy bien básicamente el atómico eh Nada más les va a regresar o sea tiene dos posibles valores que les va a regresar el imagínense que ustedes Acá si si se traslapan acuérdense que si no se traslapan los tres registros o sea los seguros los regulares y los
(05:00) cumplen que si no se traslapa este lo va O sea no las operaciones de lectura y escritura van a ser como serían secuencialmente entonces Pero si ustedes tienen esta parte acá y seapa el se traslapa un read un así 1 con un re eh los registros atómicos o sea tienen la garantía de que solo les va a regresar dos valores y básicamente es el último actualizado en este caso para el momento en el que le vamos a ponerlo tantito más corto para el momento en el que le O sea al final de cuentas se está traslap entonces está
(06:01) traslap y al final del día cuando nosotros vemos que se traslapa lo que vamos a tener Es que va a regresar el último valor actualizado pero para este punto que se termina de hacer el read nosotros no sabemos si ya se terminó de actualizar el dos Entonces ustedes siempre siempre siempre con Los atómicos nada más van a tener de dos opciones que regresa el último último último traslapado o el anterior o se es el último o el anterior y en este caso básicamente el re les puede regresar dos o uno porque para este punto todavía no sabemos si
(06:46) este si ya se terminó de actualizar la variable que se hace con el Wi entonces para este punto lo que ustedes hacen es que tienen nada más la certeza de que les puede regresar uno o A diferencia de si hacen por ejemplo O sea si ustedes tienen acá más right así imagínense que tengan así un bu no los registros seguros acuérdense que les pueden dar eh cualquiera de todos esos entonces son los dos extremos que que tienen los registros y de aquí de aquí salen los snapshots snapshots entonces bueno nuestro ejemplo igual que este eh vean que este read se
(07:35) traslapa con este wr Entonces para este punto que lee no sabemos si ya terminó de actualizar el el valor Entonces si no se terminado de actualizar va a regresar cer o eh un pero para este punto de acá o sea si este ya regresó uno esto es muy importante entonces entonces vean si este ya regresó uno significa que el valor ya se terminó de actualizar si ya se terminó de actualizar atómico eh Como decían siempre regresa el último valor actualizado eso significa que este re va a ver el último valor actualizado Y en
(08:17) este caso ya sabemos que es uno porque este ya lo regresó sí lo ven Entonces cuando se traslapan dos re así con un wr eh lo que tienen es que si uno o sea si el primero ya lo ve a fuerza el segundo lo va a ver o sea va a ver la actualización en registros atómicos y esto es similar a como lo vamos a ver en los snapshots no entonces ya sabemos que un un registro bueno puede tener lectura y escritura atómica y básicamente un registro es un objeto que nada más permite lectura y escritura no pero qué pasa si nosotros queremos leer múltiples
(08:59) valores de registros atómicamente Aquí nada más tenemos uno Qué pasaría si nosotros queremos tener un conjunto de registros atómicos que los leamos este todos atómicamente no Entonces para eso necesitamos un snapshot atómico esto es como o sea un snapshot véanlo como como una foto no ustedes tienen muchísimos valores tienen así todas sus líneas y entonces acá ustedes tienen varios registros tienen tienen operaciones de read W así no Entonces si ustedes hacen un snapshot es como si tomaran una screenshot no es como si pusieran así O
(09:49) sea si un snapshot es llegar y tomarle una foto a todo esto pero llegar y tomarle una foto todo esto básicamente le están tomando una foto a registros atómicos Entonces eso claramente les va a dar que es un conjunto de registros atómicos entonces va a mantener la mayoría de las propiedades que tienen los registros atómicos sí lo ven entonces un snapshot básicamente es como si llegaran y tomaran una foto a un buen de de registros atómicos Sí hasta aquí sí va entonces de los snapshots en G Ah sí sí sí sí básicamente tú tienes
(10:42) eh Tú tienes varios registros no atómicos entonces Imagínate que tú tienes acá tu hilo a tienes tu hilo b y tienes tu hilo c y así hasta tener tu hilo n no entonces en todos estos hilos Uy Me quedaron chocas en todos estos hilos tú tienes varias operaciones de lectura y escritura Imagínate que tienes así tus lecturas y escrituras que se traslapan o pueden no traslaparse tienes varios no Entonces tú tienes un montón de este operaciones de lectura y escritura en todos tus hilos básicamente lo y son eh registros atómicos O sea tú tienes todas estas
(11:35) operaciones en registros atómicos cuando tú quieres leer múltiples valores de múltiples registros atómicamente lo que vas a hacer es que vas a llegar y tomarle una foto a todo esto para que lo puedas analizar si tú quieres leer muchos eh registros muchos valores de registros Entonces tú vas a llegar y le vas a tomar una foto y de la foto es donde tú vas a empezar a a leer todos estos valores y la foto se llama un snapshot entonces básicamente un snapshot si lo ven como que medio informalmente es una es una foto de todos estos registros
(12:17) atómicos Entonces tu foto pues como está tomando eh o sea como le tomaste una foto a puros registros atómicos tu foto va a seguir cumpliendo las propiedades de registros atómicos Sí entonces básicamente llegaste tú le tomaste una foto un buen de registros atómicos para que los puedas analizar en conjunto Y eso te va a dar que se siguen cumpliendo las propiedades atómicas si lo ven va entonces Eh bueno un un snapshot es esto no un snapshot es como una vista instantánea de registros atómicos pero luego tenemos o sea justamente los los registros
(13:07) atómicos nos permiten un single read eh single write no O single read multiple write cosas así pero nosotros si queremos tener multiple read multiple write multi multi es donde nosotros queremos hacer un snapshot cuando nosotros queremos hacer un multi no porque en general los este registros atómicos y los registros los otros dos tipos de registros no nos permiten eso Entonces nosotros metemos este este snapshot para hacer nuestro registro multi multiride y nosotros tenemos dos funciones la función de update y la función de scan
(13:59) Entonces si ustedes lo ven este es análogo a la función de wr y este es análogo a la función de re nada más que acá los snapshots los snapshots este weight free y los snapshots atómicos en general eh tienen algo pues muy muy bonito o muy chistoso Por así decirlo porque lo que tienen Es que además de leer las o sea además de empezar a leer ustedes van a ser o sea lo importante de los snapshots es esta parte que se tienen dos copias Entonces cuando ustedes estén haciendo un scan imagínense acá no y tienen acá otra línea de eh Por ejemplo
(14:55) re bueno no tienen por ejemplo acá update update tal Y luego update dos y luego upate 3 y acá tienen un scan lo que hace el scan es que en este punto de acá o sea en la línea eh en la línea 14 hace un collect entonces en la línea 14 va a aparecer que hasta ahorita nada más la variable se actualizó a dos pero luego va a volver a hacer otro collect aquí o sea mientras haya algo que recolectar lo va a volver a hacer y va a actualizar su copia Entonces lo importante que tiene esto es que tienen varias O sea no se
(15:43) queda con la primera lectura si lo ven por eso es multiple read porque no se queda con la primera lectura cuando se está traslap con otros writes o con otros updates hace varias lecturas hace varios collects para para este actualizar esta copia que tiene que está acá Bueno es la old copy la New copy este y que les dé el conjunto de valores más actualizados si lo ven entonces este scan no regresa a un valor regresa a un conjunto de valores actualizados y es por eso se Esa es la diferencia para eso usamos un snapshot
(16:26) el snapshot lo queremos para que scan nos regrese un conjunto de valores si ustedes se dan cuenta un read lo que les regresa un read les regresa un valor un scan del snapshot les regresa múltiples valores por eso cuando ustedes necesitan multiple read multiple Wi ustedes necesitan un snapshot si lo ven si scan hace los dos collects antes que update 3 inicie y luego que dos termine entonces a ver scan hace los dos collects antes de que o sea el collect aquí y luego el collect acá no y Y entonces el scan no tendría el valor
(17:18) de Up Ah a eso iba muy bien entonces acuérdense que este cuando ustedes tienen un conjunto de registros atómicos lo que tienen es que se siguen cumpliendo las propiedades de los registros atómicos Entonces el scan básicamente hace este varios collects pero se sigue cumpliendo las mismas propiedades de los registros atómicos Entonces si ustedes o sea lo que les va a garantizar es que por ejemplo no puedan ver el valor del tres y no el valor del dos no Entonces esta parte de registros atómicos les va a garantizar
(18:05) que se comporte de una forma temporalmente coherente pero entonces si como dice José si scan hace los dos collects antes de que el update 3 termine que sí puede pasar entonces acá se siguen cumpliendo las propiedades de los registros atómicos acá lo que les va a decir es que el scan puede este nada más regresar este o puede regresar este y este si lo ven que es el valor anterior o el valor más actualizado el valor más actualizado O sea no se actualiza un valor es el el conjunto de valores Entonces cuando pasa
(18:45) eso se van a las propiedades atómicas las propiedades atómicas les dicen que a fuerza se va a cumplir que se vea el anterior o que se vea este los dos más actualizados o los más recientes entonces dejen pongo el scan ustedes tienen su scan no sé por quedan tan Pero bueno ustedes tienen acá sus dos líneas de scan Sí ustedes tienen sus dos líneas de pero como es un conjunto regresa algo como dos tres Ajá a eso vamos a eso vamos muy bien eh básicamente ustedes tienen eh ustedes tienen acá Este scan no y por ejemplo acá vean que este update no se
(19:54) no se traslapa con este update Cuál eran las propiedades de cuando atómicas de cuando un read and wr no se trasl O sea qué les decía la propiedad atómica de cuando un read un right No se traslapan muy bien devuelve el último valor Entonces hasta este punto muy bien Sí muy bien Luis hasta este punto lo que les tiene que regresar Es este el update de El update de la variable un entonces imag a muy bien el de la variable un Entonces ustedes imagínense snapshot como decía eh zuriel el snapshot se inicializa más o menos como un array Entonces ustedes
(20:57) se inicializan aquí por ejemplo lo tienen B1 b2 B3 Y b4 entonces lo inicializan así 1 2 3 y cu Y ustedes eh o sea lo que les va a regresar el scan es cierta o sea este mismo arreglo perado de cierta forma dependiendo de cómo haga sus sus collects Entonces sí el scan regresa algo como como dos o tres en el ejemplo anterior y en este caso vamos a ver entonces ustedes tienen las dos vistas bd y ba no Por ejemplo si ustedes tienen o sea lo primero que les dice su tarea imagínense que tienen algo así b2 esto les regresa o sea el el escan
(21:43) siempre les regresa un conjunto de de vistas o de valores porque nosotros estamos queriendo O sea la única forma de que nosotros implementos bueno no la única pero si nosotros estamos implementando en Snapchat significa que nosotros queremos ver múltiples registros Entonces si queremos leer múltiples registros queremos que la vista o el scan nos dé Pues un arreglo de registros no entonces eh ahí les va lo primero es les dice es posible que esta ejecución sea eh una ejecución del snapshot W free que es este de acá entonces ahí les va
(22:27) ustedes tienen bd aquí y luego ustedes tienen acá para empezar les dice que bd no vio B1 entonces o sea les está diciendo que bd no vio B1 y eso no se puede porque este no se traslapan entonces para empezar esa parte no se puede luego ahí les va ustedes tienen el update de Uy ustedes tienen el update de b2 y tienen el update de B3 pero acá se o sea se actualiza conforme a los hilos entonces básicamente ahí les va si cuando hizo su collect significa que ya vio este y cuando hizo su collect significa que vio este y vio este
(23:24) entonces su collect debió haber sido algo acá su último collect entonces básicamente les está diciendo que este scan ya vio B1 bueno en sí debió haber visto B1 porque se siguen cumpliendo las propiedades atómicas Entonces les dice que no vio B1 pero luego dice que vio b2 B3 y b4 para empezar eso no se puede porque como no se como no se están traslap debía haber visto B1 sí pero hay algo más fuerte acá todavía les está diciendo que un scan está bastante después que el primero sí vio B1 sí vio b2 Este sí vi B3 y vi
(24:18) b4 Sí más o menos lo ven y esto no hace sentido por que les está diciendo que o sea no hace sentido que este o sea este scan bd haya visto a b2 B3 y b4 que pasaron que pasaron después que B1 pero que no haya visto a B1 sí lo ven O sea no es posible que B tenga el registro de b2 y no tenga el registro B1 si por ejemplo bueno No no es posible si este estuviera un poco más acá podría ser posible Pero acuérdense que los registros atómicos se o sea se van formando ustedes lo pueden ver de acuerdo a la primera llamada o sea
(25:14) cuando se llamó el método eh el primero que se llamó va a ser el primero que se vea Entonces si ustedes Ven a b2 pero no ven a B1 De todas formas está mal sí debieron haber visto a B1 porque fue que pasaba antes así más o menos lo ven o sea ver dejen quito estas líneas es es más o menos lo mismo que un registro atómico cuando ustedes tienen cuando ustedes no se traslapan tiene que regresar el último valor entonces aquí este scan y el update no se están traslapado entonces este scan para empezar debería ver como en el hilo o
(25:58) sea debería ver en el hilo a el valor de B1 y al principio debería haber al principio debería estar viendo así s lo ven y ya después Este se tendría que actualizar a B1 b2 y algo así y luego actualizar algo así b2 B3 y nada y luego se tendrá que actualizar un B1 b2 y como el mismo H lo que actualizó B3 actualiza b4 se pone acá y nada sí lo ven pones los demás lo ven o nos regresamos otra
(27:24) vez todo bien muy bien Ay los os comentarios Ajá Qué pasa entonces con ba Ah eso vamos a eso vamos entonces ba si se dan cuenta ba no se traslapa con este entonces este Lo debería de ver no se traslapa con este no se traslapa con este y no se traslapa con este Entonces como vea perc no se está traslapado con ninguno Que qué les dicen los registros atómicos que no ve ninguno regresa el último valor actualizado Ajá debería Por
(28:32) qué por qué no veo ninguno por qu no se traslapan sí O sea no se traslapan pero el que no se traslapen eh o sea cuando un registro atómico no se traslapa su operación de rid con su operación de r eso lo que te está diciendo es que va a regresar el último valor ad Sí o sí O sea tú tienes la garantía de que va a regresar este último actualizado Entonces si tú tienes por ejemplo un right acá y luego tienes un read Acá tienes la garantía de que este read siempre va a regresar siempre va a regresar un dos Sí ajá Entonces est esta misma garantía
(29:25) la que se va a aplicar para los snapshots si vea no se está traslap Tú tienes la garantía de que ba tuvo que ver a B1 tuvo que ver a b2 tuvo que ver a B3 y luego actualizarla por b4 y hasta abajo en el último hilo no vio nada porque no hubo ninguna actualización B1 b2 b4 muy bien Sí B1 b2 b4 muy bien Luis Entonces eso es lo que va a ver ba y bd debería ver B1 por lo menos O sea tú tienes la garantía de que como bd no se está trasladando con B1 al menos debería ha este B1 y ya los otros Sería cuestión de analizar cómo los está viendo o dónde
(30:16) hace sus collects si por ejemplo hace sus collects acá nada más vería b2 y B3 Y eso es válido pero no puede ser que vea por ejemplo a b4 y no vea a b2 Sí porque si está viendo b4 significa que hiz un collect al menos aquí y ese collect debió haber agarrado a b2 Entonces los collects imagínense elos así como unas líneas Entonces si hace un collect por acá a quién le pega le pega b2 y le pega b4 eso significa que su collect b2 puede terminar antes de b4 cómo cómo cómo O sea no es que termine Pero si tú estás o sea en este
(31:12) punto todo este punto es que se está actualizando Ajá en todo en toda esa línea el b2 se termina de actualizar después de b4 pero en todo ese proceso Se está actualizando y por eso nos sirve nos sirve el m porque bueno el multi bueno el escan no porque el escan no solo ve a los que se están terminando o sea los que ya se terminaron de actualizar el scan por ejemplo para este punto Si viera los que solo se terminaron de actualizar el scan para este punto no vería este punto de acá Entonces no vería ni a b2 ni a
(31:54) b4 no entonces pero si vi b4 entonces sí o sí tuve que haber visto B3 muy bien Sí sí o sí tuve que haber visto B3 pero a eso voy o sea algo muy importante de los snapshots y de los registros atómicos es el inicio de la invocación al método o sea las cosas más importantes que tienen que ver es si se traslapa o no se traslapa y el inicio de la invocación al método si uno inició antes que otro Aunque termine después ese va a ser visto antes sí lo ven Entonces si el b2 acá el b2 inició antes que b4 el b2 va a ser visto antes o sea
(32:42) tendría podría que nada más vieran a b2 y no a b4 Aunque b4 termine antes nada más por el simple hecho de que b2 empezó antes sí lo ven acá es muy importante el momento en el que empiezan el que pieza primero es el que es o sea el que se ve primero por qué porque las collects no lo hacen solo para los que se terminaron de actualizar lo hacen para o sea una línea el escan hace una línea de acá para acá y ve a quién le pega ahorita le está pegando y a b4 entonces su collect hace una línea o se hace imagínense que hace como que un
(33:25) corte No hace un corte acá dice oye a quién le pego de acá para acá y pues a quién le está pegando le está pegando o sea así le está pegando a B1 le está pegando a b2 le está pegando a B3 y le está pegando a b4 pero si el collect se hace aquí le está pegando a B1 a b2 a B3 y no a b4 Aunque b4 termine de actualizarse después entonces no es que b2 termine antes que b4 es que como empezó antes al momento del corte pues este como empezó antes va a estar dentro de un corte antes que b4 sí más o menos Okay muy bien entonces eh e si ustedes
(34:28) tienen acá o sea de su primer ejercicio les dice que si puede pasar a lo que habos visto b2 b4 así y para bd digo ba B1 b2 b4 y empty se puede o no se puede y por qué que la línea b2 más grande no significa que el update se haya podido hacer después de esa línea A ver no sí se o sea el update Sí se hace hasta acá o sea tú la variable se termina de actualizar en este punto o sea se termina de hacer todos los procesos de actualizar en punto pero el el collect no ve solo a los que se están Terminando de actualizar ve a los que se
(35:27) están actualizando Entonces si Se está actualizando b2 de en esta línea o sea en esta línea le pega b2 y que le pegue a b2 significa dos cosas o que ya se terminó de actualizar como aquí le está pegando uno ya se terminó de actualizar o como aquí o que se está actualizando que está en proceso está como así pero igual le pega Entonces si Se está actualizando e ajá si Se está actualizando también el collect lo va a ver o sea en el proceso de actualización lo va a ver eso es lo bonito que tieneen collect los read no
(36:07) lo ven el collect sí lo ve termina de actualizarse hasta después pero el collect lo ve cuandoo Se está actualizando Cuál era la pregunta Ah que si puede pasar esta ejecución es ejecución de b d y ba es el primer inciso de tare no se puede muy bien Por qué no se puede José el de abajo Sí pero el de arriba no muy bien el de abajo Sí pero el de arriba no muy bien muy bien son muy buen Entonces ese básicamente no se puede muy bien justo por el valor de a bien hecho Entonces como no están trasladando el update que hace el hilo a con el escan
(37:10) que hace el hilo D E eso el snapshot este snapshot en específico el wf les garantiza que el B1 debería verse Entonces como el B1 no está en en el primer acá en bd en el primer scan Esto no es posible no porque este snapshot justamente les está garantizando que se debe de ver entonces Esta no es posible luego la siguiente la siguiente les dice qué les dice la siguiente B1 b2 b4 B1 b2 B3 así se puede o no se puede tampoco es posible por el valor de c en B a muy bien sí no es posible porque para este punto no se están traslap O
(38:09) sea véanlo eh Como si fueran o sea cada uno fuera diferente porque pues cada uno es diferente entonces para este punto el ba no se traslapa con ninguna actualización Entonces los registros atómicos les dicen que si no se está trasladando con ninguna actualización eso que se van a ver todas las actualizaciones entonces vea este no se puede porque debería ha b4 porque no se está trasladando entonces si ese tampoco se puede y luego les dicen les dicen B1 b2 B3 B3 y B1 Ajá este se puede o no se puede eh Ajá el último ese sí se puede muy
(39:08) bien Por qué sí se puede muy bien ese sí se puede imagínense Ah pues es justo lo que pasa acá si hacemos lo que collect fue antes del up no muy bien Sí justamente imagínense collect está hacer los collec muy bien bien hecho está el collect aquí imagínense justamente el collect es esta línea azul El collect no está viendo o sea el último collect no está viendo la actualización de b4 Entonces lo único que está haciendo es que está viendo estas actualizaciones O sea ya mirlo está viendo estas actualizaciones de acá para atrás o se está viendo
(40:00) a b 1 Está viendo a b2 y está viendo a B3 Y luego el scan de ba imagínense que está por acá que realmente no importa Dónde esté este scan este scan está por qué el anterior no se podía ahí voy ahí voy ahí voy este scan está viendo este está viendo este está viendo este y está viendo Este Entonces si lo quieren ver un poco práctico e hagan estas líneas y vean A cuál le pega que que estas líneas Pues están haciendo nada más gráficamente la la la definición del snapshot we free no O sea no está mal porque está nada más graficando la la
(40:44) implementación Y la definición y lo están viendo más gráficamente y chance les puede ayudar para ver eh cuál es y se puede y cuáles no se puede entonces hagan estas líneas y vean desde esta línea para atrás cuál son las actualizaciones que se ven por la anterior no se podía Ajá voy tú tienes te dice que así te dice que este que b a que si B puede ser así puedes poner Cuál es bd cuál es ba ahí no bd B el primero es bd y el segundo es ba bd bd ba así está entonces tienen el anterior no se podía el segundo no se puede porque les está
(41:40) diciendo que ba es B3 Pero si tú haces tu collect acá o donde sea que hagas tu collect de ba para atrás a fuerza le va a pegar acá o sea a fuerza va a ver este b4 Sí o sea es b4 y el ba el b4 pasa antes que el ba y no se están traslap entonces ba a fuerza tiene que ver b4 pero acá lo que te está diciendo esta implementación bueno esta ejecución es que no está viendo b4 y eso no se puede o sea debería ba debería ver a b4 no a B3 No hay forma de que B B3 Por qué Porque ba pasa después sin tras la parse que b4 en
(42:25) el caso que sí se puede Cómo pondríamos la linealización solo poniendo invocaciones y respuestas e sí o pueden o sea por ejemplo en el último caso podemos ponerlo por ejemplo la linealización sería así a update B1 y luego B update lo pongo así pero lo pueden poner como siempre ponemos las eh Ya Entonces como B3 y b4 está en el mismo nunca se va a ver B3 Exacto Sí sí sí es el espacio que tiene el snapshot es un espacio por hilo Entonces como están en el mismo se actualiza update b2 luego c update B3 y luego pasa el
(43:20) scan y este da BB y luego pasa el c update b4 lo ponen bonito no Y luego s pasa así si lo ven entonces Bueno nada más es cuestión de que lo pongan bonito pero la linealización sería así para que se cumpla este scan tendría que ser antes que el update de b4 Y eso no contradice ninguna de nuestras definiciones de El snapshot wiit fre Entonces hasta ahí estamos bien Sí todos sí Ah muy bien mu bien Eduardo entonces bueno Esto lo puse por si nos
(44:27) faltaba espacio pero no nos falta espacio Entonces el siguiente ejercicio les está diciendo que planteen una ejecución del snapshot weight free para cuatro hilos en donde muestres un ejemplo de por qué esta implementación es bounded weight free Qué significa que sea Ah bueno aquí les dice es decir que cada update scan terminen a lo más o a la n al cuadrado lecturas o escrituras pasos entonces básicamente lo que tienen que hacer acá es a ver los platico primero y después lo vamos haciendo para empezar sabemos que un
(45:14) bound significa que va a terminar en Alo más n cantidad bueno no n necesariamente pero por ejemplo si es B free en cuadrada eso significa que va a terminar ter eh cada update o cada scan scan en a lo más o a la n al cuadrado pasos entonces para empezar sabemos eso no Entonces no se está diciendo que pongamos cuatro hilos una ejecución de cu hilos donde se cumpla que sea bounded free entonces para empezar tenemos que suponer que tenemos cuatro h a b c y d y imagínense que todos hacen un update primero antes que el scan o sea todos
(46:11) hacen un update update update y luego hacen el lo que nos interesa aquí es cuando se están trasladando las llamadas no porque tenemos dos casos siempre siempre en registros atómicos y snapshot tenemos que este no se traslapen o que si se traslapen no Entonces si no se traslapan tendrían que cualquier hilo que llame a update y su llamada no se traslade con otra cumple con terminar en a lo más o a la n cuadrado Pasos Por qué Porque esta línea la línea dos la línea 3 la línea 4 5 y 6 aj todas estas terminan o sea son
(47:00) constantes todas estas son constantes si se dan cuenta nada más son actualizaciones y las actualizaciones siempre son constantes entonces todo el up o sea en s el update tiene complejidad constante y luego la línea 3 si es constante o sea la línea no no no la línea dos porque acá es un ciclo Entonces cumple con que la línea esta esta esta y esta las actualizaciones sí sean constantes Sí muy bien el scan ahí les va eh cualquier hilo que llame scan y su llamada no se esté traslap e la o sea las únicas líneas que no
(47:51) tardan tiempo constante Cuáles son si se dan cuenta es la 14 del collect la 15 del ciclo 16 del nuevo collect y esta parte de acá pero el ciclo es de la longitud de la tabla entonces este ciclo es n el collect debe ser complejidad n porque está recolectando todos los anteriores este collec debe ser complejidad n y lo único que tienen es este While entonces pero como no se están traslap no tiene que haber o sea este ciclo este While como no se están traslap solo se ejecuta una vez porque no tiene que hacer varios collects o sea
(48:44) no sé cada su collect o sea cada uno de sus collects son diferentes entonces este ciclo nada más ejecuta una vez porque sus dos collect son iguales porque no se está trasladando con nadie entonces en too el escan si nada más lo hace un hilo que no se traslada tiene también cumple con terminar en esta complejidad o sea también cple con ser de este grupo entonces tanto update como scam cumplen con tener este su Cota superior en N cuadrada porque este tan solo o sea este ciclo es n collect complejidad lineal lineal y este nada
(49:30) más ejecuta una vez Entonces es constante sí lo ven entonces en el caso de que no se esté trasladando ninguna operación de lectura con ninguna operación de escritura Eh bueno explican esto pero básicamente las dos cumplen con ser eh complejidad n cuadrada y eso significa que este más específico cumplen con ser complejidad lineal y si no se están trasladando Entonces ya tienen demostrado que es bound free en complejidad o en cuadrado Sí entonces lo que nos interesa es cuando se están traslap cuando no se traslapan es
(50:18) inmediato verlo no lo único que tienen que ver acá es esta línea esta Lía es un escan y el escan lo lo único que tienen que ver que no es constante es este collect que tiene complejidad lineal este tiene complejidad lineal este tiene complejidad constante porque no se está trasladando con nadie y el ciclo se ejecuta n veces entonces también tiene complejidad lineal o bueno cuadrado si no se traslapan Por qué no son No sí son si son lineales Sí sí sí pero en específico si es de complejidad lineal pues es complejidad o cuadrada
(51:03) no porque o sea estas dos son lineales aj Sí nada más lo puse para que vean que si se cumple con pero o sea más aún son lineales Sí muy bien los dos muy bien muy buen Lu los dos son lineales pero más aún o sea los dos son complejidad o en cuadrada y más aún son lineales entonces cuando no se estén traslap ya tienen su bounded we free y si se están traslap O sea lo que nos interesa Entonces es cuando sí se están traslap si lo ven porque cuando no se están traslap pues ya sabemos que sí se cumple cuando no se está traslap es lo
(51:48) importante eh cuando no se está traslap Si todos hacen un update y se traslapan todos mandan a llamar a su Pero estas llamadas No necesariamente se traslapan o sea imagínense que todos o sea tienen acá sus hilos y todos estos hilos hacen un update Ahí está entonces imagínense que es así luego Así luego así y luego algo así no algo así ahí se Está trasl Pando con todos no bueno así entonces imagínense que todas esas son operaciones de update update update y update Entonces al hacer un update igual la línea dos la línea 4at la línea 5 6 y
(52:47) 7 son constantes la única que como decía José es la línea tres la línea tres es el scan pero o sea todos mandan a llamar esan Pero todas estas llamadas No necesariamente se traslapan entonces imagínense que d eh llama scan y ve que alguien se movió o sea por ejemplo Ah así no O sea imagínense que de lo manda a llamar y una vez o sea después en su segundo collect ve que ve Se movió entonces hace un collect por acá y hace un collect por acá Entonces ve que B Se movió entonces B terminó en este on pasos luego c Llama
(53:41) a esan y ve que des movió se imagínense que vamos a ponerlo mejor escrito porque Ajá entonces pero tomen en cuenta este de acá y los diferentes formas de hacer scan entonces imagínense que d o sea todos están mandando Llamar a su scan Porque todos están haciendo un update ese tipo de ejecución es lo que pide el ejercicio tres Sí ajá este tipo de ejecución entonces dejen se los escribo Eh bueno sí O sea tienen que eh mostrar en su ejecución cuando todos se están traslap porque si no se están traslap no tiene caso entrarían en este en este en
(54:30) este caso Pero entonces cuando para demostrar la otra parte bueno para ver la otra parte si tienen que poner que todos están actualizando Entonces todos mandan a llamar al scan Y entonces imagínense que d manda Llamar al scan y luego ve que B Se movió o sea d hace un scan y luego B hizo un update entonces de B que B Se movió Entonces en este punto B termina en on pasos luego eh tienen que c imagínense que se llama scan pero ve que d Se movió o sea lo vamos a ir haciendo como que ligado entonces c ve que d Se movió
(55:33) entonces d termina en o 2n porque tuvo que verificar dos veces no cuando detectó el movimiento de b y cuando recogió O sea ya el el el general entonces o sea su Snap entonces d tuvo que verificar dos veces aquí y aquí así ve de est aquí y de esta acá como ven nada más está una vez termina en tiempo lineal Y luego como de esta dos veces termina en on pasos luego imagínense que a les digo que lo hacer ligado porque si no eh no terminan de demostrar todos los casos y con haciéndolo ligado terminan de demostrar todos entonces a ve que C
(56:28) mueve entonces c en cuánto termina o sea cómo cómo va el patrón de D tuvo que verificar dos veces luego c tuvo que verificar tres veces porque acumulo tres verificaciones Entonces cuánto se tardó c n2n por qu o sea vas por ahí vas por ahí va muy bien pero mira si te das cuenta 1 muy bien en caso de que n se trasladen sucede que tenemos igual o sea
(57:33) bueno sí sí pero eso ahí vamos Eduardo sí la conclusión es esa pero sí ahí va ahí vamos entonces se acumula tres eh tres operaciones que se traslapan o tres verificaciones entonces termino en 3n Porque si se dan cuenta o sea lo lo pasado acá es si se dan cuenta para empezar lo pesado del collect o sea lo pesado no es el collect en general es este ciclo bueno es este Wi Entonces ese se ejecuta Y tenemos tres hilos sí Entonces ese se ejecuta siempre y cuando este well se ejecuta eh siempre y cuando haya nuevas nuevas actualizaciones o que
(58:19) hayan visto nuevas verificaciones Entonces ejecuta entonces sí Sí sí sí muy bien Luis Sí sí sí muy bien Ahí vamos Ahí vamos entonces ahí este está contenido en N cuadrada este está contenido en N cuadrada bueno sí es igual está contenido en N cuadrada y luego el hilo el A cuántas verificaciones eh Cuántas verificaciones acumuló Cuántas verificaciones acumuló a Si todos hacen o sea todos empiezan su update al mismo tiempo entonces Cuántas verificaciones tuvo que hacer A cuántas veces Tuvo que pasar este ciclo de
(59:11) collect tres ahí va más o menos Imagínate que todos hicieron su update al mismo tiempo o sea tú tienes así los updates Entonces todos tienen su copia del collect primero ves que B Se movió y ahí ya se acumula una eh y b no ve a nadie entonces B termina normal pero d tuvo que ver que se movió y luego tuvo que hacer su otra verificación entonces tuvo dos y luego c tuvo que ver la verificación de B la verificación de d y la verificación de de O sea que ya se movió o sea su Snap la recolección de de Snap entonces acá
(59:57) son tres y luego al final acumula Cuántos acumula o sea tuvo que ver a a b luego tuvo que ver que d Se movió luego tuvo que ver la verificación de c y luego tuvo que recoger su Snap Cuántos son 4n muy bien entonces cuatro operaciones porque tuvo que ver o sea tuvo que ver esta esta esta esta y recoger su Snap entonces este a termina en on Este sí lo vos de nuevo el martes a termina en 4n que eso es on cuadr Entonces ya tienen su ejecución de 4 hilos donde todos terminan en on cuadrada y ya quedó y Eduardo decía que para n hilos tienen
(1:00:58) on n que es on cuadrada y tiene toda la razón muy bien Sí Luis Muy bien Entonces como ya si lo generalizan bueno lo generalizó Eduardo pero sí si tienen n hilos van a tener que el último hilo acumula a lo más n por n que eso es n cuadrada entonces en general es bounded free o n cuadrada donde cada hilo se da cuenta que solo uno se movió si detecta que más cambiaron muy bien Sí si detecta que más cambiaron son menos colos muy bien Eduardo muy bien jóvenes ven les digo que son increíbles Entonces hasta acá ya tienen
(1:01:48) el un el dos y el tres no Sí igual lo vemos un poco más de espacio el martes y terminamos los otros dos el martes va va son muy buenos Cuídense mucho No gracias a ustedes la tarea se entrega el tres Bye cuídense mucho Bye
