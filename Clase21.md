2024 08 29 14 06 57 - YouTube
https://www.youtube.com/watch?v=mFoFc9U5Ug0

Transcript:
(00:00) [Música] más difícil siento son muchos conceptos y ya vieron bueno Isabel me comentó de de que Les explico un montón de cosas de la tarea no Entonces sí como que este siento que tardamos un poco bueno no también al inicio para como cachar bien Esto de deadlock free estv free Pero bueno siento que es lo pesado la parte práctica como en realidad pues no podemos enseñar grandes cosas y no entendemos la teoría pues como que vaas siento que un poquito más baja Este pero nada más para que vayamos viendo no O sea cómo pues lo que cómo se implementa
(00:37) eso que vemos en la teoría entonces bueno la anterior pues nada más vimos este diferencias no entre hilos procesos cor procesadores y todo esto no de multicore multihilo multiprocesador todo eso y pues algo muy sencillito no de cómo implementar la clase Run Perdón la interfaz Run la clase TR e pues así muy sencillito entonces bueno en esta práctica este se titula exclusión mutua loxy puls en Java se llama así porque y le pongo en Java porque vamos a ver mucho ya cosas que están predefinidas para hechas en Java vale
(01:23) como que vamos a usar las librerías que que ya nos nos tiene este les puse Aquí se trabo y se trabó sí okay Bueno voy a quitar mi ahora porque tengo conexión fea pero Déjenme Sí bueno se me me avisan vale Sí gracias entonces ya quité la cámara a ver si funciona mejor Eh entonces eh el Primero lo primero que vamos a ver antes de de meternos así en
(02:28) los logs y vamos a ver Bulls vamos a les voy a platicar de dos conceptos que se utilizan un montón el primerito es el concepto de la condición de carrera o Race condition y el segundo es la el concepto de carrera por los datos o dat ríes me imagino que ya han escuchado de ellos este no sé tal vez como las ris condition no son como famosas este entonces eh qué Dónde dónde las vemos surgir no en situaciones donde vemos tenemos eh cosas raras en los programas y digamos que estos dos términos es para que ya no me escuchen decir suceden cosas raras no
(03:14) es ya para nombrar esto como tal esos problemas que surgen entonces la Race condition eh o sucede cuando en una ejecución dos o más hilos acceden a un recurso compartido por ejemplo un recurso compartido Pues podría ser una variable Entonces el resultado depende del orden de la ejecución Y eso lo vemos claramente este en el contador na por ejemplo acá Ay no lo tengo abierto en eclipse este en el contador na este de la práctica uno teníamos esta ejecución que que eran pues cuatro hilitos y utilizaban un el objeto
(03:59) Counter simplemente se acuerdan que nada más tenía el increment aquí la [Música] práctica Aquí está No nada más tenía increment y get value y pues no usaba candados ni nada así pelón Entonces al momento de que los ejecutaban pues obtenía 40 No aquí da 40 otra vez 39 no entonces y veíamos que iba variando el resultado del contador y en realidad se dan cuenta varía dependiendo la ejecución Entonces ya para que nosotros Bueno hablemos como mejor no en este mundo concurrente en vez de decir mira Ocurre algo raro no o en vez de
(04:50) decir simplemente ocurre una inconsistencia podríamos decir existe una condición de carrera existe una Race condition Por qué se llama así condición porque este condición de carrera porque en realidad tu resultado o sea el resultado de tu ejecución depende de Pues de cómo se ejecuten los hilos no por eso como que es de qué depende tu resultado de la condición de carrera de ejecución pues no Ajá sí Exacto Ur una condition Exacto Entonces esa es una forma de describir esto también otra otro concepto muy importante es esta de
(05:32) carrera por los datos que ocurre cuando dos o más hilos realizan una llamada a un método de un objeto compartido al mismo tiempo y este pues sí O sea Ejecutan un método No simplemente de y un método de un objeto compartido sea lo que sea sea cola pila contador lo que sea no y este una de ellas es una escritura no Entonces esto es como nada específico por ejemplo Igual acá tenemos ocurren datas ríes voy a quitaro aquí entonces una Data Race por ejemplo sería en dónde ocurre dat Race en la variable Counter pues es la la variable Por qué
(06:28) Porque cuando dos o más hilos tratan de modificarla Pues digamos que uno de ellos es una es pues una escritura no sea de hecho para modificar con lo que hacen los hilos es este este modifican con una escritura al menos no sabemos que ahí pues hay una escritura oa bueno lees no la variable Counter la escribes en tu variable personal o sea eso no lo vemos no pero pasa abajo escribes en tu variable personal la aumentas y luego por fin se se se ve no o en en lo este en la variable pues compartida global que todos vemos
(07:23) entonces en dónde existe una Data Race en la variable count vale Entonces por qué bueno como aquí es no existen dos o más hilos exacto no O sea en esa implementación Pues hay cuatro que tratan de escribir la misma variable Y entonces existe una Data Race en la el en Counter no en count en este caso entonces así se dice eh más o menos como que cacha la diferencia o sea digamos que una Race condition es en general no O sea ves la ejecución Y dices Ay el resultado varía dependiendo comoo lo ejecutes Sí porque este
(08:04) eh Porque pues pasan ahí cosas extrañas no abajo o sea Pasa una ris condition no y en la carrera por los datos en las datas races lo que dices es Mira hay una variable que está siendo escrita por más de un hilo Vale entonces eh Cómo puedo escribir ahí Ah bueno Sí hay una variable que está siendo escrita por más de un hilo no es como la la forma fácil de decirlo y este entonces es lo que nos dice la dat Race y justo en Dónde existe una dat Race justo en la variable count va Y entonces la diferencia ya cuando o sea es distinto
(08:51) no a decir Eh bueno la la implementación Counter naiv provee errores e inconsistencias sí Pero además tiene una condición de carrera y además tiene una Data Race justo en la variable count no es distinto ya lo como nos podemos referir Vale entonces Bueno realmente estos Pues sí son Pues un par de problemillas No si existen Data races Y si existen Race conditions Pues sí realmente a veces los programas no son lo que queríamos no en este caso un contador que no cuente No Pues que chafa no entonces este el concepto de sección crítica que vimos
(09:32) nosotros en teoría no de Cómo ser un candadito y este bueno de evitar no que que un bloque de código pues sea ejecutado por más de un hilo a la vez Es simplemente esto pues este este concepto nos puede ayudar a evitar Data races y Race conditions Por qué Porque por ejemplo podemos evitar una Data Race Ah si metemos nuestra variable en esta sección crítica entonces hacemos que ya no pueda ser escrita por varios celos a la vez no de esa forma y podemos este evitar una ris condition porque como ya no pueden ya no puede ser
(10:12) escrita por más de unir a la vez esa variable Y esa variable es la que nos ocasionaba que que el resultado fuera distinto cada vez pues evitamos Race conditions Entonces este pues sí no se es como que otra maravilla no de las secciones críticas cercados entonces bueno ahora sí Java pues provee implementaciones de secciones críticas no O sea implementaciones de candados la primera muy famosa pues es synchronize y otra pues es toda la interfaz look Eh pues tiene en realidad varios candados no solo el reentrante el que hemos visto
(10:50) en teoría Pero bueno nosotros solo ocupamos el reentrante Pero buen todos son lo mismo tal vez n más es ver como la entación no de como de bueno este qué garantías me da Qué garantías más me da pero la mayoría este bueno todos cumplen con deathlock free todos no starvation free hay algunos que no otros que sí y con justicia eso es todavía más reducido no entonces bueno en la clase pues vimos que un candado no resuelve este pues la exclusión mutua no O sea te permite construir una sección crítica entonces la diferencia entre usar sincronize y
(11:33) utilizar la la palabra lock este en realidad nada más es una situación como de personalización Por qué Porque sincronize dónde se pone simplemente se pone Acá está voy a quitar esto se pone simplemente eh en los métodos o sea los métodos son los que son sincronize entonces sincronize lo que te dice es que hazte todo este método una sección crítica entonces pues como que se pone por método Vale y la diferencia es que se pone tienes que poner no el inicio cuando adquieres el candado y el final cuando lo dejas o sea como que es una de
(12:30) personalización vale porque por qué Porque si se dan cuenta este si lo ponemos en un método Pues todo lo que está dentro se convierte en esta sección crítica no y al contrario como que ponerlo solo en las variables que tú quieres o sea como que el lo te permite personalizar más es la diferencia no y ya adás este de que te permite personalizar más eh también es distinto por ejemplo la palabra sincronize a todo a todo lo que ustedes le pongan sincronize se va a convertir en una sola sección crítica hagan de cuenta que aunque Ustedes pongan un
(13:13) método no O sea por ejemplo Aquí tengo otro ejempl si ustedes tienen no sé este método no y le ponen sincron pero también le ponen a este a este y luego también le ponen a este o sea todo le ponen hagan de cuenta que todo se va a convertir en un bloque solo de código de sección crítica o sea quiere decir que ningún hilo va a poder acceder a cualquiera o sea este si alguien está utilizando solo Run Pues tampoco va a poder acceder a get value o a increment porque todo está en un mismo candado vale o sea como que
(13:50) es la diferencia y con el Pues sí O sea puedes personalizar justo dónde no incluso puedes crear varios logs y ponerle distintos candados a tus métodos es lo malo con sincronize no lo sincronize es como cuando solo ocupas un candado solamente uno y solamente un método y lo es cuando pues quieres dividir como que esa sección crítica quieres dividir el alcance eso es más específico utilizar lock Entonces por qué podemos utilizar synchronized No pues porque en Java eh cada objeto de Java está creado de forma que tiene
(14:24) asociado un candado Entonces cuando nosotros utilizamos synchronized pues lo lo lo usamos vale es como que lo activas entonces por eso como que a todos le puedes poner sincron y además también syncron previene que este que dos o más Silos accedan no a distintos métodos eh No solamente por por método sino por ejemplo si un objeto este buo lo p por ejemplo en este caso no si tenemos en este ejemplo tenemos estas dos variables count y stop Vale entonces estas dos variables si le ponemos por ejemplo Run solo funciona bueno en run aumentas en
(15:18) increment la variable count Entonces si nosotros le ponemos sincron aquí este va a haber O sea no emos no ejecutar increment de forma como sola no o sea porque para para modificarlo este Digamos que ya está ocupado el candado de Pues que modifica la variable count y de la misma forma con stop Vale entonces como stop está aquí también no podemos modificarlo acá porque se está modificando ya aquí como que sincron así como que todo lo un mismo candado entonces pues es lo malo no no es muy personalizable HM A diferencia de la clas loock que es
(16:08) así no por ahora sí que pones eh donde quieres que inicie y donde quieres que acabe entonces la diferencia en realidad Pues podría ser el scope no el alcance eh Como que es más eh fácil utilizarlo eh Bueno o sea cuando queremos personalizar Ajá Ah Exacto S como dice Sebastián no un buen este como un buen resumen no O sea todos los métodos y funciones que utilicemos dentro de de un syncron se bloquean para todos los demás hilos Exacto o todo se vuelve un candado enorme Sí y bueno entonces es la gran diferencia no pero
(16:50) nosotros ya vimos acciones críticas entonces como que siento que no hay mucho que decir aquí más que pues ver si acaso la documentación vale dice suriel Entonces es mejor usarlo Pues sí O sea si en realidad sí eh Pues bueno van a ver no si nada más ocupamos no sé un candadito no para un contador y solo queremos ponérselo a la al método increment pues está bien no O sea usa sincronize no O sea solo ocupamos algo así pero si ocupas no sé por ejemplo en la en el ejercicio seis no que les voy a Si ocupas si te dejo no
(17:32) eh Por ejemplo perteneces a un equipo de trabajo estás a cargo de de dar acceso no a un servidor O sea tú eres ahí el que da acceso y seis personas te pueden mandar tareas para que las ejecutas en el servidor Pero tú solo puedes este aceptar una tarea por integrante y además no puedes dar acceso a más de tres al mismo tiempo no como que í sí como que usar sincronize Pues no va a funcionar No porque te están pidiendo demasiadas cosas o sea tienes que solo puedes aceptar a tres y solamente una tarea por por cada de esos de esas seis
(18:06) de esas seis integrantes no entonces ahí cómo le haces no con sincronize pues como que no no o sea sincron es para cosas así bien bien triviales bien sencillitas eh y lock es cuando realmente queremos ahí hacer cosas no este más complejas por qué Porque lo Por ejemplo puedes usar un candado dentro de otro no O puedes tener 10 candados a la vez distintos Este y sincronize pues es un mismo candado solo no O sea como que no te permite mucho eh Pues resolver cosas así muy muy complejas como o sea bueno no tan complejas Esto no es complejo no
(18:40) pero o sea es más este más elaborado no O sea no es tan sencillo tan trivial entonces bueno eh Esos son los logs y la clase semafor semáforo ya viene también prediseñada en en Java y simplemente pues un semáforo que es Es una generalización de un candado Por qué Porque te permite en vez de que entre un hilo a la vez a una sección crítica te permite que entren n hilos a la vez noces simplemente es como una generalización no O sea la sección crítica este de un candadito te dice solo uno a la vez y este te dice Ah pues
(19:21) deja que entreen tres no y cuando haya espacio O sea si hay dos pues deja que entre otro si hay uno Deja que enten dos no y y pero siempre máximo tres entonces este o o n no O sea el número que sea entonces Bueno vamos a yo Vale entonces este es el el de la práctica anterior de la inconsistencia e entonces Aquí empieza entonces Bueno aquí más grande esto Aquí está entonces aquí tenemos tres hilitos no y los tres hilitos este utilizan la misma este pues clase que implementa Run y esta clase pues se llama contador
(20:22) sincron no sea este entonces empiezan los tres luego eh esperamos no a que todos terminen con join y finalmente regresamos el valor no Entonces qué hace cada uno de los tres o sea cada uno de los tres ejecuta este bueno primero ve cuál es su nombre no luego este hace un incremento se increment pues nada más modifica la variable count en uno en estas líneas se duerme tantito unos 100 nanosegundos y Ya entonces eso hace cada uno vale Y bueno cómo funciona sincronize si lo ponemos este así miren es muy curioso como lo
(21:19) ponemos en el método Run tenemos este 10 ejecuciones no de c a 9 del hilo cer luego eones del hilo dos y luego 10 ejecuciones del hilo un porque como lo ponemos en el Run Y eso es lo que hace cada uno en Start pues ahora sí que el que gane primero en tomar en ejecutar el ron en este caso ganó el hilo cero luego el hilo dos y luego el hilo un no o sea porque bien sabemos nosotros que este esto se ejecuta en orden así sea en el orden que sea pero digamos que aquí el es el que entra primero en Run y hasta que no acabe de ejecutar las 10 va a
(21:57) dejar el candado que es pues es todo el método Y entonces el otro puede hacer pues este ejecutar no después su Run eh dice puede pasar que un hilo lo tome dos veces seguidas Eh sí sí puede pasar sí puede pasar Ajá en sincron sí puede pasar o sea como que no es estar no es este no es justo Pero bueno en este caso no no lo vemos no O sea Bueno nada más se forman c dos y uno otra vez no otra vez ganó el dos otra vez ganó el dos Este pero así O sea sí puede pasar no sincron no es justo solo es starvation free pero justo no O sea
(22:39) eventualmente todos pasan pero no no este no en orden Este Entonces por ejemplo aquí pues todo se forma no h en este otro ejempl ito tenemos igual no los tres hilitos la misma el mismo Run eh pero miren ahora este utilicé ahora ya no cuentan de en un for o sea de como de 0 a 10 Ahora cuentan mientras no se ponga la variable en stop Vale entonces eh Cómo modificamos la variable en stop bueno para que se digamos que mientras sea falso que que funcione no y cuando se ponga en verdadero que pare y que Dejen de estar contando no entonces eh
(23:30) Quiénes son sincronize todos los métodos no eh increment value excepto esto y también este el método Run no pero pues bueno en realidad ponerle sincronize aquí pues es un poco redundante no este porque Bueno aquí ejecutamos el increment no pero pues como les dije en realidad te permite hacer esas cosas no O sea ponerle a todo aunque sea métodos que usas dentro de otros pero todo lo mete en un un gran candado entonces aquí Qué sucede este Bueno aquí lo que hace el método es que se duerme tantito 400 nanosegundos y luego lo
(24:15) detiene y finalmente Espera que terminen todos y este y obtiene el valor Entonces eso hace pero por o sea también como aquí pongo Este ejemplo Porque tampoco es tan trivial utilizar sincronize en todo porque Bueno no sé Luego me pasa que tengo alumnos que no vienen en todo el curso luego vienen al examen final y les pido implementar algo y pues la todo le ponen sincronize no literal a todo a todo este y pues bueno tampoco es tan trivial o sea ustedes creen o sea luego esos alumnos creen que sí es así como Ah mira
(25:02) ahorita paso el curso así pero no es tan trivial utilizarlo a veces puedes crear programas que no se detienen por ejemplo aquí no se va a detener nunca Por qué Porque si pones a sincronize a stop también en synchronize qué va a pasar que que este Bueno ya hay que detener Esto sí si lo pones en este también adentro del Gran candado que es sincronize pues se va a formar Entonces si pones a dormir al hilo no este 400 y luego le das Así que se detenga pues como este esta eh este método está dentro del Gran candado
(25:53) único no de pero aquí pues ya lo tiene el primer hilo no se Bueno uno de estos hilos uno ya está dentro del único candado no y no va a parar hasta que lo detengan con el Stop igual a true entonces nunca va a suceder No tampoco es tan trivial O sea si hacemos estas cosas no pues no se va no se va a detener porque nunca va a dejar de dar vueltas aquí nunca va a dejar su candado no por ejemplo mira aquí ven ven todas son del mismo hilo no del hilo cero todo todo por el mismo hilo Entonces es lo malo de sincron O sea hay que saber bien dónde lo ocupas
(26:51) si si ocupas una variable no que funcione independiente a lo que está dentro no este Entonces aunque le quite el sincron tampoco se va a det tener si se lo quito Sí y de hecho ajá si se lo quito Sí porque ya este digamos que el objetivo de de este W pues es nada más O sea digamos que del método Run Es simplemente leerlo no entonces si yo lo cambio pues ya se va a reflejar finalmente en este no eventualmente [Música] sí sí porque Bueno entonces es porque el método pues ya no está dentro del candado simplemente vale si esto Sí se
(27:46) detiene porque sucede aquí entonces lo cambia y ya está todo lo que estaba dentro de del Gran código no O sea bueno del Gran bloque de de este si puede pero por ejemplo es distinto No si en vez de poner sincronize aquí lo dejamos solamente aquí no en increment es distinto ya vieron Por ejemplo si en vez de ponerle sincron Ahí está todo al block Run se lo ponemos solo al increment También tenemos como algo O sea no suceden inconsistencias porque pues protegemos el el código pues sensible que es este pero ya permitimos
(28:34) que que este que los hilos avancen no porque r pues es el ejecutable de todos los hilos entonces permitimos que todos los hilos traten de obtener el candado Entonces por ejemplo aquí pues lo obtien el hilo uno Este Bueno en realidad se imprimen de forma distinta no en realidad pues primero el hilo cero Pues que tiene lo que incrementen luego el uno luego el dos no luego otra vez el un luego el cer Y luego el se luego el s y así pero ya vieron o sea como van cambiando ahora s cambian los hilos es distinto no pero por ejemplo
(29:22) aquí si utilizamos este sincron no en Stop pues quiere decir que el hilo Main también se pelea por eventualmente tomar ese stop no O sea ya no está como ya no tenemos el un candado sobre esta lectura No si solo utilizamos syron los métodos anteriores pero no en este Entonces esta lectura no está dentro del mismo candado Bueno del candado no del candado único Vamos a ponerle y se detiene vale Ajá sí por qué se detuvo porque antes al estar sincronize en todo este
(30:30) bloque digamos que todo lo que estaba aquí pues era código sensible no O sea era estaba todo dentro del mismo Entonces qué quiere decir que que este entonces quiere decir que que la que esta lectura porque pues esta es una lectura no sobre la variable stock quiere decir que esta lectura también estaba dentro del mismo candado vale o sea por eso por eso ahora sí se detiene Pero si metemos a esta lectura dentro del mismo candado que esta no o sea puede ser que no vale o sea como sí sí no se va a detener si metemos
(31:11) esta misma lectura y por qué también porque solamente el que tiene el candado es increment no Entonces le das chance a que los demás hilos eventualmente puedan leer no este W stop o sea como que dejas aquí el candado y todo esto todo el bloque que está acá no dejas que alguien más lo haga y vuelves otra vez aquí y Es más hasta te duermes no te duermes 100 en los segundos y con eso le das chance a que alguien más no este trate de adquirir el candado en increment vale se ahí sí se detiene pero si le ponemos a todo
(31:47) no más o menos Sur vale Bueno entonces ya si no este Eh bueno ahita veo no lo vuelvo a explicar e Entonces este ya pues acá es un ejemplo con con Lo eh este aquí Cómo funcionaba miren pues simplemente Tenemos aquí tres hilitos no eh todos comparten el mismo Run y por lo tanto en el mismo rable comparten pues la misma variable count este también hay un stop Y tenemos todos compartimos un mismo candado vale que es en este caso reentrante algo un candado ya predefinido en jav entonces eh Ay borré la Sí entonces
(32:55) este en todos los métodos no les ponemos eh que inicie el candado y y lo deje no TR lock y muy importante usamos try Finally por si pues no sé hay alguna falla aquí no algo pasa pues que siempre lo deje siempre siempre liber el candado para que alguien más puede entrar entonces eh todos los métodos pues tienen lo mismo no leer el valor también stop eh También está dentro del candado y y aquí [Música] este también funciona de la mismita forma mientras est falso stop Pues que los los incrementen no nos dormimos
(33:40) tantito entonces como que en lo que nos dormimos pues como que damos chance no de que alguien más lo tome que tome el candado en increment Entonces eventualmente el hilo Main este hace hace que la variable Stop sea verdadero y acaba No termina todo entonces se parece un montón al anterior o sea como que ya vi que en este caso podemos hacer cosas muy similares no O sea casi las implementaciones Son igualitas por ejemplo pues aquí se cuenta de c hasta 30 pero bueno es porque le le di más en el Run no este pero también acá o sea como que van
(34:21) cambiando los hilos no 1 do 0 2 1 o sea vamos dejando que como que todo se vaya moviendo pero siento que es se ve más bonito con lo Ajá sí no es como que más limpio y es que te permite o se esto Un ejemplo muy sencillo es como el ejemplo que dice no bueno Y es mejor utilizar sincron utilizar lo pues depende Si vas a hacer algo así muy simple pues inon te funciona no este igual como dice se ve muy bonito no como que justo dices qué está dentro de sección crítica queé está dentro no y ya vale entonces bueno este y aquí
(35:12) puse la línea 22 se detiene el contador Ah bueno claro no hay que tener cuidado también donde ponemos que se detiene porque si lo detenemos aquí no O sea bueno pero es algo que nosotros ya vimos desde la anterior Si no si en vez si comentamos esta no y comentamos esta y le decimos que se detenga mejor después de que se hace el join no nosotros ya sabemos bien que el join lo que hace pues es esperar a que todos se acaben pero pues o sorpresa la línea 26 yo les estoy diciendo que acaben no Y si no le digo que acaben pues no O sea como que
(35:49) aquí la lógica está no espero que todos acaben pero yo soy quien les va a decir cuándo entonces pues es un programa que no va a acabar nunca no se hay el problema Entonces Bueno hay que tener cuidado no dónde ponemos el Stop Ah en este caso y y ya Bueno creo que es el único ejemplo que que puse aquí Pero bueno también te puedes meter el pie no Ah También acá si le pones el lock a todo esto no a todo el a todo digamos que el método Run porque nunca lo vas a dejar entonces como los hilos justo en Start Pues es lo que Ejecutan el método
(36:31) ron No ni siquiera le das chance a los demás de que empiecen y no se diga el hilo Main No si metes también el Stop dentro del mismo candado o sea como también puedes llegar a una misma situación si metes todo en mismo candadito no vale entonces bueno se está como bueno siento que está como tan difícil no pero si hay que tener cuidadito con esas cosas no Sí porque puede ser que tengamos eh pues O sea que diseñamos sistemas que se congelan no con deadlock que se congelan vale entonces ya de aquí 44 Ah Perfecto entonces Bueno después eh es
(37:15) eso es este lo muy sencillito de utilizar Ah bueno y la interfaz lo también Pues en realidad tiene más cosas tiene tenemos tiempos este l va H Tenemos también tiempos de Time out o sea como de expiración tenemos eh distintas este dónde lo puse HM bueno a ver aquí está Entonces tenemos así este distintos métodos Ah pues el típico locky unlock es lo que necesitamos para hacerlo funcionar vale Pero en realidad
(38:19) también está este este método interr Ay Bueno no sé este que simplemente quiere el candado este A menos solamente solamente si el hilo que lo tiene se encuentra como este pues sí como interrumpido no O sea tiene tiene una interrupción e también podemos agregarle condiciones Pero eso lo vamos a ver después está otro que trock no adquiere solamente el candado si este está libre en el al momento justo de hacer La invocación y si no no lo intentes no si no vete o sea es como el trock si está ocupado y no lo vas a no vas a obtener la sección
(39:06) crítica enseguida este Vete no eh Y este hasta tiene como con tiempo no este intenta adquirir el candado si no lo adquieres en un periodo de tiempo muy definido pues ni lo intentes no son como las cosas que hay Pero bueno eso lo vamos a ver lo de las condiciones y el tiempo lo vamos a ver después porque también tiene chiste eh Pero bueno ya también están los semáforos que es otro pero bueno eso lo vemos ahorita que les explique lo de los ejercicios igual es muy sencillito ahora en los candados en vez de usar lock y
(39:42) unlock utilizas adquire y Release como igual adquiérelo y libéralo déjalo eces lo mismito Nada más que ahí pues los semáforos los inicializa con una capacidad porque pues ahora permites que más de uno esté en la sección crítica es la diferencia es muy muy sencillo o sea bueno lo sencillo es utilizarlo no ya lo difíciles analizar Cómo es que funciona Eh entonces luego lo siguiente es este las puls de hilos ya también ya tiene este predefinidos eh las puls de hilos las puls pues simplemente son implementaciones de eh de muchos hilos o
(40:28) sea te permite en vez de utilizar eh de crear un hilito por hilito no sea nosotros así a manita No e aquí creamos este cuatro tres hilitos No primero los los este los creamos aquí el el un este un objeto de tipo TR les pasamos el Run luego les damos Start y y este no como que hací a manita cada uno no se queremos carar 10 hilitos pua manita pero acá las puls de hos que lo que nos permiten es este pues le dices le dices a a al objeto en este caso es la interfaz no le dices pues yo quiero una pool de Hilos de 10 no O Quiero unos
(41:14) 20 yos unos 100 entonces así ya tienes que estarlos creando manita Esa es la diferencia entonces eh creas un grupo de hilos y una vez que los creas los hilos ya están esperando tareas o sea como y esas tareas digamos que se les dan no se les entregan a los hilos Y entonces el hilo algún hilo que esté disponible la va a tomar la va a ejecutar y pues va a finalizar no y va a esperar por otra tarea o sea por ejemplo si ponemos 10 hilos y les damos 100 tareas pues este cada uno va a tomar una no y y en cuanto se se liberen van a ir tomando otra y
(41:52) otra y otra hasta acabarla 100 o sea no no precisamente como en un orden No simplemente es como en disponibilidad y ya este entonces así es como no darles este un montón de tareas a un grupo de hilos y ya está eh utilizamos puls Bueno o sea como que me imagino no que siempre es la duda para qué O sea para qué utilizar así puls Bueno pues una de las cosas es para reusar los hilos este una de las cosas es para para reusar los hilos eh Y así podemos mejorar el rendimiento Pues si nuestra compu tiene nada más por ejemplo la mía
(42:34) pues está muy chafita no bueno he visto sus compos Están muy padres pero bueno la mía solo tiene 10 hilos entonces si yo quiero ejecutar 100 tareas pues los pongo a reutilizarse no para que entre todos hagan las 100 tareas Ah entonces para eso nos convendría y bueno También nosotros nos conviene para probar nuestras implementaciones y no estar haciéndolos así todos no a manita de un dos tres no no estar haciendo eso e Entonces no conviene utilizar puls Pues si si utilizamos O sea si en realidad hacemos procesamiento
(43:13) secuencial no en bat O sea si pues como que no tiene mucha mucho sentido No mejor pona un solo hilo o si no importa la cantidad de los que ocupemos no pues si no te importa si estás bien con dos pues para que usas una pool no y ya es es como Pues tampoco es como que ocupes muchas razones no para para usar una p entonces bueno en Ja ya tenemos la interfaz executor este de aquí y tiene un método execute y que recibe como parámetro O sea la tarea que va a ejecutar que están esperando todos son van a ser tareas Run entonces di en una pool entonces los
(43:57) cilos están como en una como en la puerta de la sección crítica y solo están esperando a que uno entre y así Ah no precisamente no hay secciones críticas ahí o sea HM digamos que están una pul los tiene inicializados a todos o sea como que [Música] sería sería como esta parte están creados no están esperando empezar están esperando que suceda la línea 16 no Start pero no precisamente una sección crítica eh Por qué Por es porque no los Ejecutan O sea no los mandan este en orden no O sea si hay 100 tareas entonces eh Y tenemos 10 hilos pues 10
(44:47) hilos van a currir al mismo tiempo no y y todo el tiempo van a estar eh Pues ansiosos por por agarrar otra y otra y otra Entonces en realidad si tenemos 10 hilos pues van a haber al menos 10 tareas que se ejecuten este como de forma concurrente vale o sea no no es como que un hilo acabe y luego empieza el otro y luego empieza el otro Sí le podemos dar esa opción a la a la pool no O sea también la podemos personalizar para que sí funcionen en así justo en paralelo no y que sea como sección crítica pero no precisamente vale o sea
(45:20) como que los tienes ahí esperando nada más solo están esperando que haya alguna tarea que ejecutar y no precisamente en orden y no precisamente Ajá Exacto sí Exacto zel Sí todos pueden estar haciendo una tarea al mismo tiempo entonces Eh bueno Esta es la la interfaz no Pero además ya nos simplifica un poquito más la vida y este y tenemos esta sub interface de execut que implementa estos siguientes métodos y que son suficientes y mínimo no para bueno y suficiente así para crear pues una full Vale entonces Bueno
(46:07) Este Entonces esta interfaz de Java pues es documentación vale esto que ven aquí es documentación no más que se las puse aquí porque pues está como bien resumido eh entonces tiene todos estos métodos que es vo shd que es por ejemplo Bueno voy a mostrarles mejor acá en un programita No acá Entonces por ejemplo tenemos un exec una exec service entonces este así Bueno aquí está tenemos la Pull la creamos y le decimos no que sea una p fija de cu hilos vale Crea una
(47:13) p de cu hilos s O sea inamovibles no O sea no puedes agregar cinco más o así fija luego le dices que ejecute 10 tareas ejecuta 10 tareas y muy importante no este no hay que esperar que una termine para ejecutar otra vale entonces lo que recibe es la tarea ejecutar la tarea pues es una tarea Run es esta que está acá Vale y simplemente le pasamos Pues el nombre como de la tarea que vo a ejecutar y simplemente este método de
(48:18) shutdown lo que hace pues lo tengo acá No pero bueno lo que hace es termina las tareas que se hayan enviado al ejecutor pero digamos que muy importante HM no las termina de golpe vale este o sea como simplemente lo que hace el executor Shot es le dice al executor termina las que ya tienes vale No aceptes nuevas pero termina la que ya tienes entonces quiere decir que pues va a ejecutar estas 10 y ya no va a ejecutar más pero no precisamente es que ahí vayan a acabar vale es como lo que lo que tarden No simplemente es como que le ponen ahí
(49:07) un como este pues no sé cosa como que el cadenero no de de una fiesta pues deja entrar las tareas no que son y quieren entrar más simplemente ponen la cadena de que ya no hay pero no es como que las tareas dentro ya se hayan acabado vale o sea no es como que cortemos a la ejecución simplemente cortamos que haya nuevas es lo que nos nos dice shutdown vale mm sí O sea no es como como un stop no es un stop es como un ya no permitas que entren más eh Y bueno después está esta otra que es este Shut down Now y también
(49:52) bueno est shutdown Now Pues también es como shutdown acaba eh corta que ya no entran más Pero además trata de de de como Cancelar las que ya envió y además este por ejemplo bueno es que aquí tenemos dónde lo anoto este bueno el executor digamos que este bueno el executor una vez que que le enviamos las tareas por ejemplo aquí no le decimos executor execute y ejecuta por favor 10 tareas no Entonces si solamente tenemos cuatro hilitos y pues en realidad este Ford pues va a suceder en segundos no O sea bueno muy rapidísimo no sea el for no se
(50:45) va a detener entonces a dónde se van a ir las tareas que no empiecen los los hilos toman las tareas Eh bueno las tareas las primeras tareas y las tareas que no no se hayan tomado se guardan en una vale la kiwi de la p Y entonces la kiwi tiene las tareas pendientes esperando a un hilo disponible es lo que sucede Vale entonces esta de execution shutdown Now lo que nos dices que bueno no le vas a quitar al execut al executor o sea cada hilo la tarea que ya tiene este
(51:50) procesando no pero si hay tareas que están este en la kiwi que no se hayan empezado pero que ya las tiene el ex bueno El ejecutor guard este pues lo que lo que dices es cancelas no O sea que nadie las tome Vale entonces es así este ejecutor pues tiene como su cola de las pendientes Y entonces bueno Tenemos también esta esta pregunta no de shutdown que pues también la podemos ver acá Este también está de si si to de la pila o sea como is down es si ya no ya no hay más no O sea ya ya no hay más tareas y si es termin is terminate es
(52:35) que realmente este ya no hay ni una sola tarea que se está ejecutando por algún hilo vale eso es como este comprobar si ya terminó eh También puedes eh poner como otra bueno preguntar no si ya terminó y esperas a que por un intervalo de tiempo no para preguntar y si no ha terminado pues V vas a tirar o sea bueno este hasta puedes tirar excepciones no de que se interrumpa Eh vale entonces por ejemplo bueno igual ustedes podrían ya jugar con ello m pero por ejemplo vamos a ver la de este is termin a ver este Okay entonces por ejemplo
(53:59) aquí [Música] Este sí Mira por ejemplo aquí preguntamos terminó no ha terminado no terminó no ha terminado Este pero por ejemplo podremos preguntar también si se hizo el shutdown y cómo se escribe [Música] Sí por ejemplo realmente como que lo que
(55:14) nos dice aquí es Eh sí eh Bueno ya no se acepta tareas pero No han terminado los hilos no de ejecutar todas las tareas es lo que nos dice Vale entonces Okay entonces también a termination puedes esperar por un interval que preguntes después de no sé n Bueno este 100 nanosegundos y sí terminó y bueno así se ve un ejecutor
(56:19) ahí es muy importante también notar aquí que si se dan cuenta este tenemos cuatro hilitos no Y si se agrega el Shot Cómo se vería Ah pues fuerzas a que pero por ejemplo aquí y es que el Shot lo que nos dice Dejen dónde está aquí sh regresa bueno Además tengo que poner una lista Pues creo que lo que nos podría decir H
(58:14) no regresa veo có lo cambio dice que my Run Ah miren por ejemplo es muy curioso no lista este si se acuerdan devuelve las tareas que están en la es decir que no han sido tomadas no han sido bueno procesadas ningún Entonces se vería de esta forma nos devuelve la Run este el spf el B3 o sea una dos 3 4 5 1 dos 3 4 cco seis no en este caso seis Entonces nos devuelve seis tareas
(59:20) Quiere decir que lo cerró así enseguida y de las 10 tareas no devuelve seis tiene sentido no quiere decir que de nuestros cuatro hilos pues cada uno no tomó una cada uno tomó una una una tarea se puso a hacerla y ya este este pues no no acab no empezó ni con la otra no O sea había seis tareas listas o sea porque solo tenemos cuatro hilos no pero por ejemplo qué tal que usamos seis 1 dos 3 cu cuatro tareas ya vieron o sea 1 dos 3 1 dos 3 cu tareas y usamos se hilos mi compo es de 10 pero como Tengo un buen de cosas
(1:00:10) este abiertas a ver si Ah miren 10 hilos 10 hilos 10 tareas ya vieron si tengo nu hilos y lo paro enseguida nos queda solamente una tarea Sí pues sí Okay entonces Bueno ya vieron noas así funciona este executor Ah bueno y curioso no las tareas se van agregando este por ejemplo la tarea cer la procesa el Lito un no la dos el Lito dos la trito 3 Pues mir casi en orden la 5 el se sí casi en orden los por el nombre de hilitos no pero por ejemplo si tenemos otra vez nuestros cuatro hilos no no hacemos Esto del shd no porque eso hace
(1:01:08) que acabe todo mu vamos a poner m por ejemplo aquí Ah tenemos cuatro cuatro hilos Ah sí sí aquí por ejemplo hilo tres toma tres tareas no es como el hilo que más toma o tampoco controlas como quién toma más simplemente en cuanto están disponibles para tomar otra vale o sea como que no no es este no es así que vayan formaditas Vale entonces este Counter [Música] Ah si est nada más es así no les pasa las tareas es es lo que hago aquí con el le paso la tarea le imprime y este Counter po lo que hace es este también
(1:02:12) usamos un executor de cuatro hilitos e igual ponemos este las tareas como por como en orden no y le pasas la tarea al este al al método increment es muy curioso aquí si se dan cuenta bueno bueno imagino bueno dónde acá la clase implementa la interfaz y acá no está resulta que DEA 8 Java 8en nada más una for distinta de como de esbir faes vale de como de implementar estas interfaces y te permiten usar la notación lambda que es como similar a la que se usa Bueno yo la conocía de Ja de javascript la anotación lambda este Pero
(1:03:10) bueno es muy como de de este programación funcional no Pero simplemente es como sintaxis entonces este en vez como de poner rable pues nada más pones la notación lambda este y lo que esté dentro o sea lo que esté de este lado dan por hecho por default que es el método Run Okay es como que y como como en el método Run tienes este método increment no que aquí es donde si está la variable y como todo está en la misma clase pues puedes acceder a ella no hay problema Entonces este le mandas no al execute que ejecute pues el
(1:03:54) contador en entonces Ah miren de 300 no que ejecute el contador y Este pero por ejemplo Ah sí muy bien ya se me hace raro bueno ejecuto el contador y le das que sea bueno que no acepte más tareas que se apague ya el contador Y entonces aquí Bueno miren pude haber usado la wiit no el preguntar si ya terminó este Pero bueno lo que yo hago pues es simplemente poner a dormir el hilo Main Para esperar en lo que realmente terminan todas las tareas que son aquí 300 para cuatro hilitos y este y y y pues nada más regresar la cuenta
(1:04:53) final vale entes por ejemplo en este caso este la cuenta final fueron 295 y son 300 Pues aquí sabemos no que hay una una este carrera por Bueno cómo se condición de carrera no una este r condition Exacto se laed re Entonces tenemos aquí una r condition y ya está entonces pues es una forma ya vieron como que queda más compacto más bonito no no creen y pues aquí podemos este poner que en vez de cuatro pues sean 10 no 10 hilitos y a ver bueno por aquí son 299 y ya está no ya no tenemos que hacer a manita las cosas a vi van las
(1:05:43) ldas Sí sí y bueno entonces eh una cosa es utilizar rbles y la otra es utilizar cbls que son pues este pues son son como runes pero que regresan están basados de hecho en ellos no en creo que son están mismo bueno igual son es como una subinterfaz de rable un cable y como su nombre lo dice esperan eh A diferencia de los runs que son vacíos se acuerda no O sea el método aquí se ve Ah sí implementan un este buen nosotros tenemos no que que hacer este Run y es vacío siempre o o sea regres nada y y los call si regresan
(1:06:28) este pues lo que lo que lo que nosotros queramos oa cualquier tipo de Java entonces este también es un contador aquí está la clase increment no e y este aquí tengo una lista de futures eh Ahorita les voy a decir qué son tenemos la el el executor service el executor simplemente lo que va a hacer es que va a ejecutar este e varias tareas eh Bueno aquí agregué los features para para mostrar no cómo va entonces bueno digamos que un carab Eh pues lo que te regresa es este pues algún tipo por ejemplo en este caso podríamos dejarlo o sea podríamos
(1:07:24) descomentar no esta línea y este lo que nos regresaría pues serían increment ahora es entero ya vieron o sea como que nos regresa este el valor que se aumentó eh Pero bueno les quería Mostrar además y bueno también se pueden escribir al estilo de lambda porque Cab es una interfaz Okay entonces pero lo que les quería Mostrar era que es un Future Aquí tengo la no entonces bueno eh cuando nosotros utilizamos el método submit y este el método submit lo que hace es este método submit lo que hace es que te regresa un Future y un Future nada más
(1:08:16) es el resultado este que nos devuelve el cable entonces quiere decir que y este bueno hgan de cuenta que este submit siempre te va a devolver Pues el el resultado del C y los futures te van a ayudar como para guardarlos no en esta variable y después no sé por ejemplo depende no para que ocupes este pues todo lo que te devuelve el c no bueno que para los ejercicios si les puse yo como una forma Entonces siempre que usemos a diferencia son como análogos pero la diferencia es que el sub te devuelve siempre un resultado un objeto
(1:09:04) execut como plano me importa el resultado meev un poco entre la definición de [Música] Bueno voy a ponerlo acá es un objeto Pues voy a ponerlo así vale es una interface pero que siempre bueno que puede volver e Pues [Música]
(1:10:08) un un valor vale Y ese valor puede ser e de tipo este pues no sé entero String un objeto lo que sea vale es un una una este una interfaz también vale que en vez de devolver void no sea r Pues siempre no no devuelve nada si es vacío pero siempre o sea te puede devolver un valor es la única diferencia con c Vale entonces para digamos que Para aprovechar para aprovechar los cabs no usamos futures un Future es un objeto en Java así como Bueno pues así como cualquier objeto no un objeto en Java que lo que hace Aquí está Bueno de hecho es
(1:11:12) interface ya vi es una interface que lo que te permite es este como que guardar un valor y puede ser de cualquier tipo vale o sea por ejemplo como es como el Perfecto amigo de calab No si Cab devuelve algo pues Future lo va a guardar entonces lo que nos devuelva calab lo podemos guardar en un Future entonces eh el Future eh tiene varios métodos vale usamos features eh para guardar el valor que devuelve para Vale entonces este fure lo que nos va a permitir es este pues uno no tiene el método get que eh devuelve el resultado
(1:12:02) del cabor y va a esperar va a esperar de ser necesario O sea si le ponemos feature.get este no va a dejar que el código siga A menos que obtengamos ese el resultado del Cab es como bloqueante vale Y este si utilizamos podemos también utilizar ese mismo método get pero con un Time out eh Podemos esperar nada más un tiempo o sea en vez de pues esperar hasta que sea necesario hasta para que acabe pues esperamos Hasta que expire el Time out es Es como una opción y además podemos preguntar si realmente este ya tenemos
(1:12:44) el Future o sea como si ya realmente el Future devuelve verdadero si la tarea se realizó O sea si el c ya acabó Ya tenemos el resultado eh También te permite arlo este y bueno el cancel como que es bien rudo Porque si si se envió El carab y a un o sea está en la k y aú no lo toman lo cancelan no Y si ya lo tienen pues pues ni modo o se Ya pues manda este ajá si puede puede llegar a interrumpir el objeto o sea puede llegar a interrumpir el Cab Aunque puede ser que el no acabe no es como bien rudo el canel Y también puedes preguntar si
(1:13:28) realmente funcionó No si realmente está cancelado es lo que nos permite hacer un Future Pero bueno Ahí les van para que para que vean como bien para qué se ocupan Entonces esta línea de aquí pues es como se ve un Cab vale o sea digamos que esto no esto es un Cab estilo L por qué Porque a diferencia del Run que vimos acá que que pues este tiene el increment vacío aquí si no tiene un increment con entero Entonces se vuelve enteros pero bueno entonces para poder como cachar los futures el exec para poder cachar los
(1:14:14) futures lo que lo que para tenemos que utilizar el método submit Entonces el submit acepta el vale este Cab como parámetro de submit y lo guarda en eh la lista de futures vale porque yo aquí creo una lista de features Okay entonces at pues es en realidad de la lista no o sea es una un método de de un objeto de tipo lista Entonces los va a ir guardando y y va a acabar aquí o sea bueno va a preguntar por ejemplo va a decir Oigan el Future el el primer Future que guardaste ya acabo vale n task es el calab no no no el cabol es todo esto o
(1:15:20) sea es está es la función lambda vale [Música] es esto vale ajá si es que es una o si lo buscan Java Java lambda Java expresiones lambda son las expresiones lambda y lo que te van a decir es que las interfaces aj bueno las interfaces las podemos escribir de esa forma pero bueno Dónde está una buena explicación pero bueno este Ah bueno a ver cualquiera Ah no aquí está la pero sí no está muy linda esta no Pero bueno está si lo leemos con cuidado Dónde estará un ejempl bueno
(1:16:26) mira creo que está mejor Este ejemplo de acá por ejemplo cuando tenemos un una Ah en este caso vale tenemos una clase que implementa una interfaz runnable no en este caso runnable y pues la interfaz o sea es la clase de que se compone de atributos de métodos y de este muy importante no que la clase r tiene por default que este que implementa bueno que se debe sí se debe implementar el método Run vale se debe sobreescribir Entonces cuando lo queremos hacer de forma estilo lambda este solamente se hace así porque son funciones anónimas así
(1:17:23) les llaman entonces digamos que lo que está de este lado en realidad es lo que está eh es el método r en este caso vale lo que está de y lo está del otro lado eh Pues como la función es anónima no O sea como que te permite hacer eso y no te acepta adás O sea si lo escribes de esta forma no te acepta parámetros de este lado no O sea este Bueno pero bueno no sé creo que si lo buscas estará como mejor explicado no de cómo se hace como pero pues es algo de sintaxis vale o sea no es algo como de Pues sí como de no sé que tenga como
(1:18:20) algo más de semántica no de explicación simplemente este dice no es una forma de escribir las las clases Run entonces en vez de aventarme yo todo esto pues simplemente lo escribo así sobre todo les digo cuando pues es algo muy corto no O sea y de hecho ya tengo aquí la la el método Entonces lo puedo meter de esta forma y Pero bueno hay varias formas de escribirlo creo que no me acuerdo sea tengo pésima memoria pero la otra es [Música] eh la otra es y hasta lo escribes como como variables Ah De hecho también están las streams
(1:19:08) junto con eso nacieron las streams no este en Java Sí ahora ya tien como lenguaje estilo funcional no Ajá bueno por ejemplo esto se ve como bien python no Pero bueno ya también te permiten hacer esto o incluso esto no Esto es para referirnos a un a un este atributo del método no pero bueno se creo que bueno tal vez te saldría mejor no no lo tengo aquí preparado para explicarlo pero este Entonces es muy importante no el método Cab o sea el Cab es esto Vale entonces el c quiere decir que también lo podemos escribir
(1:19:53) [Música] esta forma así vale o sea también podemos aventar como un cl no sé myal ponerle nombre no que no se un anónimo como en las funciones lambda y muy importante el carab le gusta no s no que sea de tipo String y así vale o sea se escribe de la misma forma y pues también tiene un método Run pero en este caso como es strings Pues sería String porque el cáo la diferencia del del Run pues regresa este entonces así Bueno entonces le importamos no ent bueno se podría escribir de esta forma okay sí se parece a javascript también a mí
(1:20:57) Yo también es que también este un tiempo aprendí javascript Pero ya cuando vi esto dije a Qué onda Bueno como que ya no siempre como tan rudo tan tan no s tan estricto y luego hacen estas cosas como que meedo ay no lo esperaba de l este Bueno entonces si no no no creen porque ya ves que pues es un relajo no O sea pues pero ya va como que bien estricto todo bien este con sus tipos no los cast Ajá Y ahora resulta que tenemos este programación funcional Pero bueno e entonces que me quedé Ajá pues hay que ver esto no cóm se
(1:21:50) implementa no es que si dije algo ahí escrito mal Bueno hay que ponerle a esto Entonces ya vieron bueno por ejemplo Qué pasa aquí no este se Ejecutan los los este las tareas las n tareas la que son 300 no entonces Esperamos que al final pues la cuenta sea 300 pero bueno ni siquiera no utilizamos aquí sincronize no Pero bueno ya vieron en esta s se logró no si no utilizamos sincronize o sea como que no hay consistencia en una de estas nos va a salir un número extraño no Ah mira Ah miren aquí no nos salió 299 porque no usamos sincronize si le
(1:22:38) ponemos aquí sincronize ya con eso vamos a tener siempre 300 no o si usamos logs lo que sea entonces a ver aquí Qué pasa No primero creamos la lista de features Por qué Porque pues Son un montón Son 300 no Entonces no puedo crear nada más hay un Future tengo que crear una lista Bueno o sea es lo que yo quiero no para para guardar todos los futures este y un Future que que simplemente pues es un objeto que me va a permitir guardar lo que me devuelva el cabol Vale entonces y ya está predefinido en Java entonces Ah bueno Y
(1:23:14) que el feature puede ser de cualquier tipo por eso en este caso pues van a ser enteros Por qué Porque pues estamos aquí guardando enteros Okay el C de vuelve enteros entonces este Bueno entonces hago execut submit porque el submit lo que hace es que me devuelve un Future Entonces le paso el c y y este entonces esto se va a guardar no en el fure después Bueno aquí nada más puse como esta línea para que veamos cómo sale No si pras si se terminó la tarea y qué tarea la número cero de la lista Okay entonces este get lo que nos dice se
(1:24:05) acuerdan lo que nos dice este get es e e Bueno este get Es sobre la lista aj si es solamente como accede a al índice cero de la lista y pregunta si ya terminó no es lo que nos dice esta línea eh a pero no es la de los gets de F Entonces es la de la lista vale la del índice entonces aquí qué hacemos pues simplemente este le decimos al executor no No acepte más tareas pero no le decimos o sea bueno no lo no lo terminamos en realidad le decimos que no acepte más y ya finalmente acá qué hacemos
(1:25:11) este le decimos que nos imprima [Música] este mientras eh el Future y e este terminado Eh bueno mientras el fure no esté terminado Me detengo vale o sea tengo que esperar para imprimirlos todos o sea para realmente imprimirlos todos no acceder a ellos ocupo pues ver que realmente hayan terminado pero si no me voy a quedar en este While vale ya vieron o sea como que me quede dando vueltas hasta que realmente ese Future acabe entonces pues acá esta línea se ejecuta pues una vez que ese Future Ya está entonces [Música]
(1:26:07) e guarda en el valor del Future no que es future.get y pues nos da el índice no el índice I y el punto get ya ahora sí es este se refiere a este método de acá al método el método de aquí no get a este de aquí vale entonces qué nos va a devolver el resultado del Cab y va a esperar de ser necesario pero bueno ahora no va a esperar porque yo aquí esperé no O sea no lo forcé a terminar no lo bloqueé aquí lo imprimo Vale entonces ya finalmente Bueno aquí lo guardo y aquí lo imprimo no el res entonces eh Por qué hago ese try
(1:27:01) Catch porque el Future los futures cuando hago future.get ajá si es bien raro no ver el Future el W y los corchetes pero en el mundo concurrente lo solemos ocupar un montón Ajá como como en los programas por ejemplo no este del el peterson no cómo sería con corchetes pues Bueno nada más a ver si si está bien pues sería así no verlo así O sea qué voy a hacer mientras sucede esto nada pero ahí me quedo vale s Ajá O sea sí no sería No no va nada dentro pues este nada más esa línea como que te hace quedarte ahí vale Ajá vale Vale entonces
(1:27:51) este los vas guardando no eh Y los imprimes y bueno pones todo en el trycatch Por qué Porque el Future Cuando haces Future pun get te avienta una interrupción una excepción no entonces hay que cachar y ya este y bueno acá Este ya después me duermo tantito no para que realmente esperar que todo haya acabado y este Pero bueno en realidad creo que ya habría acabado desde acá pero bueno para para revisar la cuenta final porque Bueno aquí implica no que todas las tareas ya terminaron o sea en esta línea como que forzamos no a que a
(1:28:33) esperar o sea por eso se tarda un poquito en imprimir si se dan cuenta no O sea como que va medio lento y en este caso ya vieron la cuenta final es 29 no Ajá sí creo que aquí pues bueno 98 al 99 a ver esa también es 299 y se tarda no como que lo imprime lento por qué Porque va viendo no que todos hayan terminado Ah miren est 298 y hasta aquí podemos repasar no eh es curioso no quién quién fue quien leyó doble o Quien escribió el mismo quien se retrasó no pero sí entonces supone si utilizamos sincron aquí d se conect 300 No ahora sí y se supone que
(1:29:44) debe dar siempre 300 300 No ya con eso miamos el problema vale o sea bueno ya en la la teoría vamos a ir viendo No qué otras formas podemos mitigar estos problemas pero este entonces bueno así así funciona vale lo de los futures más o menos es como que en esta práctica estamos viendo no Cómo utilizar ya lo que vale igual si Cualquier duda me dicen va entonces ya después llegamos a a los ejercicios ahora sí Sí bueno Y acá no más Les comento que Ah bueno que ya va adás o sea todo esto de los PS pues es todo el mundo vale o sea
(1:30:36) hay gente que se dedica como que analizar el o sea como performance Cuántas tareas puede ejecutar los sigos hacen gráficas si las prueban en computadoras con 64 cor cosas así no todo el mundo pero buen se en Java además de del executor el executor service además de este tenemos una clase que ya implementa la interfaz no sea tod nos hacen el trabajo más fácil no Bueno más difícil no sé pero o sea todavía una especificación de la interfaz que se llama threadpool executor que lo que hace pues es implementa la clase execut
(1:31:19) service y nos dan herramientas para ejecutar y terminar las tareas y nos permiten especificar las características de la cola para las tareas porque como les comenté las tareas que no se no las hayan iniciado los procesos a los hilos pues se guardan en la cola como que de tareas pendientes entonces Eh pues tiene su chiste o sea hay distintas implementaciones de colas hay colas que usan candados no colas que no usan colas que son acot no sea que tienen un número fijo O sea que no aceptan más tareas conas que no
(1:31:58) lo son O sea que son ilimitadas que puedes meter el número de tareas que quieras entonces Bueno pero eso es así más específico y pues ocupamos saber un poquito más no de teoría Este Entonces yo creo que este Bueno voy a ver no si lo meto hasta el final Depende como como vayamos entonces bueno en el siguiente link pues ahí les dejé los pram más este entonces Vamos hasta ahorita vimos hasta el programa 6is no hasta el seis pues son los son los ejemplos y pues ahí jueguen no con los métodos estos que que vienen con el ag termination por ejemplo
(1:32:41) no sea como cosas que quisieran ver no aunque creo que no lo ocupamos en la para la práctica Eh entonces bueno para para la tarea vamos a ocupar el programa siete y el ocho entonces bueno las instrucciones son las mismas no muy importante Ah bueno Yo creo que pasando con este fin le califico la mayoría ya le revisé algunas y están muy bien ya les el este la calificación vale a a un par de equipos este Pero bueno se Espero ya este esta semana que viene a más tardar ya darle su calificación y pero bueno entonces con Java 21 vale
(1:33:29) igual todo todo igual e este en un PDF me entregan la solución no de lo que escriban y también la descripción de sus programas entonces Bueno vamos a ello el programa cola secuencial el que vamos a ver ahorita es una implementación de una cola secuencial Pues sí no entonces lo que tienen que hacer Ustedes es implementar una cola concurrente Pero bueno eso cómo lo van a hacer pues simplemente van a utilizar la secuencial no la van a mover no nada no así como está Y lo que van a utilizar va a ser una pool de hilos es con executor
(1:34:10) service o sea lo que vimos ahorita y y muy importante primero no le van a poner ni candados ni sincronize vale o sea como que así como viene así la van a poner Entonces por ejemplo pues aquí tenemos la cola no la cola y este y pues simplemente este por ejemplo No yo aquí puse no un deq un enq este enq de X en q a luego borro borro x luego pongo B pongo c y luego hago un montón deq y al final pongo x no sa no sé eso es una ejecución vale una ejecución secuencial entonces bueno así así funciona no sé si no le pongo los los
(1:34:58) este todos estos de esta forma entonces así una cola eh común y corriente vale Eh pues este pues sí muy común y corriente no pues tiene tiene Tail este el nodo está acá solamente pues tiene el ítem no este vas a guardar el nombre del em el el el next que va a apuntar el siguiente nodo y este y pues se inicializa simplemente guardando el ítem entonces pues el enq funciona de esta forma el deq de esta forma no sea Ay perdón de esta forma así muy sencillito vale como es una cola entonces lo que tienen que hacer Ustedes
(1:35:51) es tomar no implementación o sea bueno hacerla este con un executor este por ejemplo con este no Entonces qué hacen pues toman el executor no este bueno no les puse Cuántos hilos solo les puse concurrente Ah pero bueno los que quieran no pero bueno utilicen menos de los que tiene su kungu vale no le pongan s no tiene casos o sea los hilos que creen van a ser falsos no a los Pues solo va va a poder crear no sé si tienen 10 pues 10 y los Reales entonces usen menos de los que tiene su comp e entonces bueno van a crear su su pool de hilos y luego
(1:36:38) le van a poner no sé este executor execute y que primero ejecute Pues un enq luego un deq No sé no O sea en orden eh como ustedes quieran o sea le dan método a su a su cola Acá está entonces así eh pues lo van a hacer vale Cuántos hilos nos recomienda usar pues hasta tienen hay así este análisis de Cuántos hilos debemos usar ahí lo vi en un libro este usen usen este usen máximo máximo su número de de hilos menos dos vale Ah sí los 24 que tengo no sí que he presumido este usen usen los hilos que tienen menos do vale o sea por ejemplo
(1:37:34) si Sebastián tiene 24 Pues que use 22 no O sea Pero bueno también Si usas 22 Cuántos métodos le tienes que dar no para ejecutar o sea Cuántas Cuántas Este sí o sea cuántos eh Porque bueno por por ejemplo aquí pues yo le puse No que ejecute esto eh Entonces si le pones 22 hilos pues me imagino que que mínimo unas 22 este eh operaciones no para que se vea como realmente que todos trabajan porque pues para qué le pones no sé 10 10 operaciones y si vas a hacer 22 hilos no O sea yo creo que el ocho está bien vale o sea la mayoría
(1:38:20) tenemos como 10 12 los que tienen cuatro hilos Pues bueno los cuat no Ajá sí O sea pues sí no hay sí modo pero sí O sea este los que tienen muy poquitos Pues si usan sus cuatro y los que tienen unos 10 pónganle unos menos dos vale Y y Sebastián que tiene 24 Pues yo creo que la mitad está bien o sea tampoco tanto porque pues sí O sea cua no ocupamos mucho ahorita o sea la ejecución se tienen que armar una ejecución Vale entonces ya este es eso y luego bueno tienen que o sea lo crean no crean este ponen su Pull para su cola y
(1:39:05) ya sin sincronize y sin lock y luego en el inciso dos lo que tienen que hacer es este ejecutar varias ve su implementación con diferentes secuencias de llamadas a métodos o sea por ejemplo pues es una secuencia No yo primero H un deq y luego enq luego unq Así no s entonces ponen varias secuencias O sea no muchísimas no este eh prueben unas unas tres unas tres secuencias entonces e van a van a ver si su implementación funciona la lo que de acuerdo a lo que se espera de una cola no O sea si suceden cosas raras no suceden
(1:39:44) inconsistencias es decir si por ejemplo tenemos no la secuencia de enq a en qb y de q y al final resulta que no se borró ninguno no O sea a pesar de que Us un de no se borró este si es que miren en este caso en pues devuelve un buano no y y de devuelve un String Así que a fuerzas tienen que usar cabol y no ron Okay se es un un de fuerzas c como bien dices entonces y el cabol pues o sea un cabol debe capturar buanos y otro cabol debe capturar strings Ajá Por ende también Future Sí sí sí y Bueno e Entonces este pues deben cachar vale
(1:40:46) si existen cosas extrañas no O sea y s van a pasar o sea bueno es lo es lo que yo espero que pase que que como no usan candados pues s va va a suceder así o hasta que se va a quedar Auro este bueno van a pasar cosas raras con los apuntadores al no usar este candados ni sincron igual o sea si les marca como un este como de No pues es que apun apunta nulo Y entonces hay un fallo no o algo así pues también no lo reportan esa es una inconsistencia aunque también sería una inconsistencia que que pues existiera este que hicieron un deq y no
(1:41:25) se elimine nada no O que hacen un enq de algo y no se puso en la cola qué onda no O sea como que esas son inconsistencias entonces tienen que que ponerme una capturada de pantalla de como miren aquí debía suceder o sea debía el resultado de la cola debía ser solo a o solo b y resulta que están los dos no a pesar de que puse un deq entonces que qu se ver o sea eh eh Cómo sucede Esta inconsistencia bueno se como que la comprobación Vale entonces si para analizar si hay inconsistencias hay que utilizar Future porque Future lo que nos va a permitir
(1:42:02) va a ser guardar el resultado no de de lo que es o sea bueno por ejemplo el enq Pues realmente devolvió true o este el de que si este nos devolvió No sé x y no debería devolver eso no Entonces si ocupamos Future ahora muy importante Future punto get o sea cuando cuando utilizamos future.get en esta línea la 40 se acuerdan que get en Future lo que nos hace es que nos devuelve el resultado del Future pero lo fuerza de tenerse o sea entonces si nosotros imprimimos si hacemos e fures no Esto entonces
(1:43:04) forzamos a que eh el ciclo por se detenga hasta que se devuelva el valor Vale entonces tengan cuidado no lo pongan aquí porque que si lo si hacen el submit y luego esperan Justo a que les regrese el valor quiere decir que no eh este no van a meter en digamos que no le van a dar al executor todas las tareas o sea el executor no va a tenerlas y y va va a pasar como que se se Ejecutan de forma secuencial vale o sea si si nos detenemos a cada rato por el valor quiere decir que no le vamos a pasar otra hasta que tengamos el resultado y
(1:43:51) no se van a ejecutar de forma concurrente así que no podemos meter este el get aquí vale o sea como que en el mismo for del submit no puede ser por eso yo por eso Se imprime acá sí tiene sí tiene su razón Vale entonces así les toca O sea que futures espera hasta obtener el valor Ajá Exacto sí Sebastián sí espera se detiene sí O sea no como siempre devuelve este eh ahora sí que get devuelve siempre eh el tipo del Future y no no puede ser nulo Entonces se detiene así bueno así está diseñado Vale entonces Ajá es
(1:44:36) bloqueante hacia los demás sos Exacto O sea si ponemos un get aquí o sea el el futures get este eh hacemos que sea bloqueante O sea no le vamos a pasar las tareas todas de un jalón al executor vamos a pasarle una obtenemos el resultado y le pasamos otra obtenemos el el resultado y le pasamos otra entonces pues vamos a formar a nuestros hilos y pues no no va a ser muy concurrente no O sea no sí Exacto al final deben imprimir los futures los imprimen antes pues siempre Al contrario van a suceder cosas buenas no se va a ejecutar de forma
(1:45:15) secuencial Vale entonces ese es este la la Ah Ah bueno Sí entonces ya finalmente contestan la la tres que pues deben decir si existen o este ya bueno deben decir si existen dat ris conditions y este y explicar En qué variables Y por qué suceden Vale entonces por ejemplo dónde existí No pues probablemente Cuando se quiere agregar al siguiente [Música] este por ejemplo el nodo anterior no el nodo anterior este que es al que apunta ta pues es uno no Entonces tú quieres cambiar esa ese apuntador que apunte a ti no entonces
(1:46:15) ahí bueno haces las igual al nuevo nudo no pero probablemente haya algún otro hilo que quiera hacer lo mismo porque que Pues todos nos queremos meter después no Entonces tal vez bueno Y bueno si más bien Ahí va a existir una Data Race no dice zuriel por eso sería mejor irlos almacenando de una lista no y al final solo devolvemos los valores de la lista de features Ajá Exacto Sí por eso los almacenamos en una lista si es la razón de que no los imprimamos ahí sí sí entonces bueno la tres es así como Pues teórica no que analicen en su
(1:46:57) programa qué está sucediendo luego la cuatro este van a utilizar candados y sincronize o sea pueden utilizarlo sincronize lo que quieran vale en los métodos Pues en q y deq y los deben hacer una sola sección crítica o sea utilizan sincronize en los dos o utilizan lock el mismo candado en ambos y y pues ya bueno analizar si existen inconsistencias en ese o sea en nuestra Cola y pues lo esperado es que no no O sea si si los metemos en Sección crítica se ejecuta eso de forma secuencial y no debería no pero bueno
(1:47:39) sea deben deben ver O sea que realmente no no existan y bueno la cinco es eh que ustedes eh Como que bueno analicen Y también pueden buscar No si si O sea qué pasa No si utilizamos más Silos quiere decir que existe un mayor TR O sea que eh que las las targas hacen o sea como de forma cada vez más rápida no O sea si en vez de utilizar 10 utilizamos 20 o 100 resolvemos este o bueno como el Es que este permitimos que entren más eh tareas y que en esa bueno sea como que ent más entre más tareas haya más rápido resolvemos vale eso equivale como el
(1:48:31) Pero bueno ya si no ustedes lo buscan bien la definición Pero bueno se refiere a eso como perform si realmente como por ejemplo no s mi comp tiene cuatro hilos No si utilizo cuatro hilos este va con esta rapidez o bueno puedo despachar las 10 tareas que puse no en en cierto tiempo Entonces si utilizo no sé 20 hilos voy a poderlo hacer a no sé al doble no O al triple es como la pregunta vale o sea si realmente eh que nuestra pool utilicemos más hilos realmente equivale a un mayor trf Okay entonces bueno argumentar Por qué digo
(1:49:15) se lo pueden buscar como ver como qué se dice no de los hilos y bueno lo esperado es que que encuentren no que en realidad depende de nuestro sistema a simple vista parece que sí no pero bueno depende de nuestro sistema y de la cantidad de de la cantidad de hilos muchas veces si nuestro sistema es de cuatro y le ponemos 10 Pues no va a ser más rápido No porque solo tenemos cuatro hil Los Reales Así que simplemente se crean como 10 hilos virtuales y esos cuatro hilos que tenemos pues de repente van a funcionar
(1:49:54) este o sea como que van a personificar no a los otros hilos O sea no son nuevos no son distintos entonces bueno esa es la 5 y a las 6 es este es este problema no supón que perteneces a un equipo de trabajo y tú das acceso se eres aquí el el este pues no sé cómo se diga esto pero bueno er es el encargado del servidor entonces eh Tú tienes trabajas tú con seis personas y todos te pueden mandar tareas y Todos quieren utilizar pues tiempo del servidor no ocupan ocupan ejecutarlas ahí pero tú eh pues tienes la instrucción de aceptar una tarea por
(1:50:39) integrante administrador Exacto Sí gracias Dani sí administrador entonces tien la instrucción de aceptar una tarea por integrante y no puedes dar acceso a más de tres al mismo tiempo entonces eh diseña e implementa una solución Bueno entonces eh yo aquí les puse el programa scheduler no y el de tarea vale Entonces qué Vamos a utilizar para resolver este problema eh vamos a utilizar un semáforo y un candadito Entonces el scheduler por ejemplo lo que va a hacer es que va a ejecutar por ejemplo Bueno aquí le puse yo 26 tareas
(1:51:23) no pero le pueden poner lo que más o menos no un poquito más entonces eh ejecuta este 26 tareas entonces las tareas están aquí son son un rable Entonces es tenemos eh el tiempo de la tarea y Pues digamos que el número de tarea Entonces digamos que hay tareas que que este bueno digamos que puse seis seis como que personifica a los seis integrantes Vale entonces la tarea eh Son este cada integrante obtiene su ID Vale y su ID es único y le puse módulo 6 porque creen que los ID Van como de 21 22 23 24
(1:52:27) entonces para que realmente sean del un al se Perdón del o al un del o al se más bien entonces los ID van del C al 6 Vale entonces el integrante integrante c y dos tardan 500 nanosegundos vale el integrante un tarda 2000 nanosegundos y los demás tardan 3000 nanosegundos Vale entonces eh este tarda el integrante uno y entonces los integrantes este 3 4 y C del C al c más bien no entonces este y es el tiempo que se van a dormir vale o sea como que el tiempo que van a tardar eso representa que están haciendo
(1:53:31) algo entonces La pregunta es No si esto es lo que tarda cada uno no así se ven las tareas de cada uno cómo le hacemos para que realmente solo le demos acceso a tres al mismo tiempo y que además este solamente podemos darle acceso a uno a la vez O sea no puede ser que que le demos acceso a tres y que uno solo esté ejecutando dos tareas vale o que tenga ocupado el semáforo con candados Ajá Exacto yo aquí les puse eh o sea lo que tienen que hacer es pensar a bueno analizar Cómo cómo utilizamos el semáforo Y cómo
(1:54:18) utilizamos los candados o sea el candadito para que realmente suceda de esta forma vale es como lo que lo que tienen que hacer m pero ya son las 4 como un candado dentro del semáforo Ajá Exacto Sí sí sí entonces a ver m ya no me da tiempo pero bueno esper y ya si no la siguiente clase la siguiente sí les doy clase y vemos no al final ya como hacerlo pero como que quiero que quede mejor ahorita para que este Pero dónde la escribo dejen esper tantito el tiempo y as no lo dejo Ahí grabado vale Y este compartir Okay cómo
(1:55:31) vas simplemente así Este Entonces tenemos la instrucción de Son seis personas no entonces e aceptamos una tarea por integrante y solo tres al mismo tiempo Vale entonces qué quiere decir que eh digamos que tenemos un semáforo aquí no y nuestra sección crítica no entonces puede haber solamente tres monitos no sé el uno el tres el uno el dos y el cco vale Y mientras los demás pues están aquí tratando de entrar no por ejemplo el TR y el cu eh No sé y el cero no están aquí tratando de entrar pero Además queremos tenemos una restricción
(1:56:19) más que es que este que que es que solo queremos que uno a la vez eh Bueno solo aceptar una tarea de cada uno a la vez vale o sea no podemos tener no sé repetido aquí el dos no O sea que el dos tenga ahí doble tarea en el en la sección crítica que es nuestro server no no queremos esto Entonces cómo vamos a utilizar eh o sea como que nos suena no hay que utilizar un candado entonces todavía no tenemos que ponerle aquí un lock un lock del hilo cero del hilo un no del hilo dos de todos los hilos no entonces cada hilo debe tener un solo candadito para
(1:57:13) que sus tareas se formen y además una vez que que que tienes tu candado pasas al semáforo vale para que no puedas hacer tareas al mismo tiempo entonces este una vez que tú ganaste tu candad uno eh pasas al semáforo y este y tomas tu sección crítica vale se vería así sí O sea digamos que es más bien un semáforo dentro de un candado dentro de cinco candados no O sea de cada uno vale se vería de esa forma Sí porque si metemos los candados dentro del semáforo Pues más bien ahí ya ganó No ya ganó el que tiene el semáforo es
(1:58:00) al revés como detenerlo antes de que llegue al semáforo Vale entonces este más o menos Bueno ya tengo más poquitos a se parece modificamos ambos el de tarea lo tienen que modificar Ah Pues digamos que solo se modifica tarea no se modifica el el este no se modifica el scheduler vale o sea como que no hay necesidad solo la tarea y solo hay que ver sabemos no que semáforo tiene este adquire o sea se toma no adquire y Release vale es tomar el semáforo y dejarlo Okay entonces es lo único distinto en comparación a un candadito Okay entonces
(1:59:06) nada más sería así entonces hay que ver No por ejemplo dónde ponemos eh ajá si por ejemplo hay que ver aquí donde ponemos No simplemente el este por ejemplo es el loog no comentas esta y esta y por ejemplo Dónde pongo el log no l tu lo y lo dejo No acá yo creo que Ah sí okay Y por ejemplo no cómo le hago lo pongo
(2:00:19) ahí y luego el semáforo donde lo pongo no eh No sé acá semáforo ahí voy a poner no y acá no sé vale eso es como la pregunta Ah bueno es muy importante no el lo que nos devuelven excepciones Así que las tenemos que poner dentro de un TR Catch pero es la pregunta vale dónde lo ponemos Quién va primero el semáforo va dentro del log no o el semáforo va antes del lock Cómo utilizamos esto ves como más o menos lo tienen que responder dice aquí otra eh podemos cambiar firmas de métodos firmas como firmas a formas las formas de los
(2:01:19) métodos que reciben Ah okay te refieres al de la cola o a este ah se si podemos cambiar los parámetros que reciben Ah sí sí sí Ah Sí por supuesto Sí para pasarlo ahale s Por eso hay hay que Modificar el scheduler Entonces porque el semáforo lo creo acá no sí sí tienes razón o sea también entonces modifiquen skeder y tarea pero skeder es lo m que pues que habría que pasarle no el semáforo vale vale sí Entonces sí Habría que ver no cómo se resuelve esto y ya finalmente hay que probar que funciona bien Sí Exacto sí O sea que
(2:02:15) realmente tenemos tres a la vez okay Y que solamente puede pasar uno a la vez no entonces Bueno después hay que responder solo estas dos preguntitas si tu implementación cumple con justicia y si no es así como la podemos garantizar Okay cómo cumpliría con justicia no O sea como una forma de verlo ahí justamente no es en la ejecución ver si el reentrante el reentrante es justo buena pregunta este no no sé justo Ah mira es un parámetro s lo puedes poner si es un parámetro aj Mira pues sí entonces así
(2:03:24) este preguntar no si así como está cumple con justicia Vale aj dice Entonces si no lo ponemos que sea justo es válida la solución Ajá sí Exacto sí O sea no tiene por qué ser justo no no les estoy pidiendo justicia solo como analizar como Bueno mi implementación es justa Ya pues por ejemplo Camila podría decir No pues este como como rentrant ni siquiera es justo no y el semáforo no es justo Entonces pues no no es No y en la implementación se ve claramente que siempre pasa más el hilo uno no los hilos que su tarea es más rápida en los
(2:04:00) el cer Y el dos pasan más no Ajá y este y bueno si y como Pues no va a ser así hay que describir como la garantizamos no Ajá Y si se podría porque pues si estos tardan siempre mucho menos pues casi siempre van a pedir el candado antes no van a van a van a tratar no de adquirirlo Siempre antes tal vez ganen sipre O sea pasen más no su tarea su tarea este es más lenta es más rápida Okay entonces eso es eso sería la práctica vale es como realizar una implementación la de la cola y esta otra en realidad como dos no y ya de ahí nada más son
(2:04:53) modificaciones muy sencillitas la de ponerle sincronize y est siendo que se resuelve así no se tarda nada en realidad ya que piensa en la solución no se tarda nada lo difícil siento que es como ver cómo lo Cómo se acomoda Okay entonces eso sería todo y nos vemos el el jueves este entro al discord vale Bueno les aviso que entro al discord para por si alguien quiere meterse a un louch y y preguntarme Vale Nos vemos nos vemos mañana que tengan bonita tarde Gracias recording
