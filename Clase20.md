(61) Clase 20 2024 08 29 - YouTube
https://www.youtube.com/watch?v=MEhYeCehTG8

Transcript:
(00:01) record prog este ya les subí su siguiente práctica Entonces más o menos ya vieron la lógica no de cómo vamos con las prácticas y el curso Entonces vamos como una semana no una semana práctica y ya pues nos tardamos dos semanas más o menos este bueno semana y cachito y dejo la otra nos cansamos tantito de no hacer y así vamos eh así entonces Eh bueno no hubo dudas la semana pasada igual creo que no estuve muy al pendiente pero bueno como que di por hecho que estaba más sencilla pero esta semana yo creo que me voy a conectar en
(00:53) discord ven que tenemos nuestras este en discord está la sección como de launch entonces me voy a meter a ahí para o sea bueno voy a estar ahí no para ver si alguien se mete estar al pendiente vale de si tienen dudas sí estaba muy fácil verdad sí pero bueno igual está tal vez surgen algunas dudas pero bueno siento que como vamos así poco a poco siento que no se complica tanto la verdad eh creo que la parte teórica eh de este curso es muy pesada y está más difícil siento son muchos conceptos y ya vieron bueno
(01:32) Isabel me comentó de de que les explicó un montón de cosas de la tarea no Entonces sí como que este siento que tardamos un poco bueno no también al inicio para como cachear bien Esto de deadlock free starvation free Pero bueno siento que es lo pesado la parte práctica como en realidad pues no podemos enseñar grandes cosas y no entendemos la teoría pues como que va Sí yo siento que un poquito más baja Este pero nada más para que vayamos viendo no O sea cómo pues lo que cómo se implementa eso que vemos en la teoría
(02:06) entonces bueno eh la anterior pues nada más vimos este diferencias no entre hilos procesos cor procesadores y todo esto no de multicor multihilo multiprocesador todo eso y pues algo muy sencillito no de cómo implementar la clase runnable Perdón la interfaz runnable la clase thre e así muy sencillito entonces bueno en esta práctica este se titula exclusión mut al oxy puls en Java se llama así porque y le pongo en Java porque vamos a ver mucho ya cosas que están predefinidas para hechas en Java vale como que vamos a usar las
(02:51) librerías que que Java nos nos tiene este les puse Aquí se trabó y se trabó sí okay Bueno voy a quitar mi cámara porque tengo conexión fea Déjenme Sí bueno si me me avisan vale Sí gracias entonces ya quité la cámara a ver si funciona mejor Eh entonces eh el Primero lo primero que vamos a ver antes de de meternos así en
(03:55) los logs y vamos a ver Bulls vamos a les voy a platicar de dos conceptos que se utilizan un montón el primerito es el concepto de la condición de carrera o Race condition y el segundo es la el concepto de carrera por los datos o Data races me imagino que ya han escuchado de ellos este no sé tal vez como las risco no como famosas este entonces eh Dónde dónde las vemos surgir no en situaciones donde vemos tenemos cosas raras en los programas y digamos que esto esos términos es para que ya no me escuchen decir suceden cosas raras no es
(04:41) ya para nombrar esto como tal esos problemas que surgen entonces la Race condition o sucede cuando en una ejecución dos o más hilos acceden a un recurso compartido por ejemplo un recurso compartido Pues podría ser una variable Entonces el resultado depende del orden de la ejecución Y eso lo vemos claramente este en el contador na por ejemplo acá Ay no lo tengo abierto en eclipse este aquí en el contador na este de la práctica un teníamos esta ejecución eran pues cuatro hilitos y utilizaban un el objeto Counter simplemente se acuerdan que nada
(05:29) más tenía el increment aquí la práctica un Aquí está No nada más tenía increment y get value no y pues no usaba candados ni nada así pelón Entonces al momento de que los los ejecutaban pues obtenían por ejemplo aquí s da 40 no Ah aquí da 40 otra vez 39 no entonces y veíamos que iba variando el resultado del contador y en realidad si se dan cuenta varía dependiendo la ejecución Entonces ya para que nosotros Bueno hablemos como mejor no en este mundo concurrente en vez de decir mira Ocurre algo raro no o en vez de decir simplemente ocurre una
(06:19) inconsistencia podríamos decir existe una condición de carrera existe una rais condition Por qué se llama así condición porque este condición de carrera porque en realidad tu resultado o sea el resultado de tu ejecución depende de Pues de cómo se ejecuten los hilos no por eso como que es de qué depende tu resultado de la condición de carrera de ejecución pues no Ajá sí Exacto ocur un condition Exacto Entonces esa es una forma de describir esto también otra otro concepto muy importante es esta de por los datos que ocurre cuando dos o
(07:02) más hilos realizan una llamada a un método de un objeto compartido al mismo tiempo y este pues sí O sea Ejecutan un método No simplemente de y un método de un objeto compartido sea lo que sea sea cola pila contador lo que sea no y este una de ellas es una escritura no Entonces esto como específico por ejemplo Igual acá tenemos ocurren datas ríes voy quitaro aquí entonces una Data Race por ejemplo sería en dónde ocurre la datace en la variable Counter pues es la la variable por porque cuando dos o más hilos tratan de
(08:00) modificarla Pues digamos que uno de ellos es una es pues una escritura no O sea de hecho para modificar con lo que hacen los hilos es este este modifican con una escritura al menos no sabemos que en realidad ahí pues hay una escritura es no le es no la variable Counter la escribes en tu variable personal o sea eso no lo vemos no pero pasa abajo la escribes en tu variable personal la aumentas y luego por fin se se se ve no en en lo este en la variable pues compartida global que todos vemos entonces Dónde existe una Data
(08:53) Race en la variable count Vale entonces por qué bueno como aquí es no existen dos o más hilos exacto no O sea en esa implementación Pues hay cuatro que tratan de escribir la misma variable Y entonces existe una Data Race en la el encounter no en count en este caso entonces así se dice eh más o menos como que cachan la diferencia o sea digamos que una ris condition es en general no O sea ves la ejecución Y dices Ay el resultado varía dependiendo cómo lo ejecutes Sí porque es este eh Porque pues pasan ahí cosas extrañas
(09:34) no abajo o sea Pasa una ris condition no y en la carrera por los datos en las datas ríes lo que dices es Mira hay una variable que está siendo escrita por más de un hilo Vale entonces eh Cómo puedo escribir ahí Ah bueno Sí hay una variable que está siendo escrita por más de un hilo no es como la la forma fácil de decirlo y este entonces es lo que nos dice la dat Race y justo en Dónde existe una dat Race justo en la variable cont va Y entonces la diferencia ya cuando o sea es distinto no a decir Eh bueno la la implementación
(10:21) Counter na provee errores e inconsistencias sí Pero además tiene una condición de carrera yem adás tiene una Data Race justo en la variable count no es distinto ya lo como nos podemos referir Vale entonces Bueno realmente estos Pues sí son Pues un par de problemillas No si existen Data races Y si existen r conditions Pues sí realmente a veces los programas no son lo que queríamos no en este caso un contador que no cuente No Pues que chafa no entonces este el concepto de sección crítica vimos nosotros en teoría no de cómo
(11:01) hacer un candadito y este bueno de de evitar no que que un bloque de código pues sea ejecutado por más de uno a la vez Es simplemente esto pues este este concepto nos puede ayudar a evitar Data races y Race conditions Por qué Porque por ejemplo podemos evitar una Data Race Ah si metemos nuestra variable en esta sección crítica entonces hacemos que ya no pueda ser escrita por varios cielos a la vez no de esa forma y podemos este evitar una ris condition porque como ya no pueden ya no puede ser escrita por más de la vez esa variable Y
(11:42) esa variable es la que nos ocasionaba que que el resultado fuera distinto cada vez pues evitamos ris conditions entonces este pues s no se es como que otra maravilla no de las secciones críticas candados entonces bueno ahora sí ya pues provee implementaciones de secciones críticas no O sea implementaciones de candados la primera muy famosa pues es synchronize y otra pues es toda la interfaz look Eh pues tiene en realidad varios candados no solo el reentrante el que hemos visto en teoría Pero bueno nosotros solo ocupamos el
(12:21) reentrante Pero bueno todos son lo mismo o sea tal vez no más es ver como la documentación no de como ve bueno este qué garantías me da qué garantías más me da pero la mayoría este bueno todos cumplen con deadlock free todos no estar Vision free hay algunos que no otros que sí y con justicia eso es todavía más reducido entonces bueno en la clase pues vimos que un candado no resuelve este pues la exclusión mutua no O sea te permite construir una sección crítica entonces la diferencia entre usar sincrona y utilizar la la palabra lock este pues
(13:06) en realidad nada más es una situación como de personalización Por qué Porque sincronize dónde se pone simplemente se pone Acá está voy a quitar esto se pone simplemente eh en los métodos o sea los métodos son los que son sincron entonces sincronice lo que te dice es que haz de todo este método una sección crítica entonces Eh pues como que se pone por método Vale y la diferencia es que lo se pone eh tienes que poner no el inicio cuando adquieres el candado y el final cuando lo dejas o sea como que es una situación
(13:57) de personalización vale porque por Porque si se dan cuenta este si lo ponemos en un método Pues todo lo que está dentro se convierte en esta sección crítica no y al contrario como que ponerlo solo en las variables que tú quieres o sea como que el lo te permite personalizar más es es la diferencia no y ya de más este de que te permite personalizar más eh También es distinto por ejemplo palabra sincron a todo a todo lo que ustedes le pongan sincronize se va a convertir en una sola sección crítica hgan de cuenta
(14:38) que aunque Ustedes pongan un método no O sea por ejemplo Aquí tengo otro ejempl si ustedes tienen no sé este método no y le ponen sincron pero también le ponen a este a este y luego también le ponen a este todo le ponen sincron hagan de cuenta que todo se va un bloque solo de código de sección crítica o sea quiere decir que ningún hilo va a poder acceder a cualquiera o sea este si alguien está utilizando solo Run Pues tampoco va a poder acceder a get value o a increment porque todo está en mismo candado vale o sea como que es
(15:17) la diferencia y con el log Pues sí O sea puedes personalizar justo dónde no incluso puedes crear varios logs y ponerle distintos candados a tus métodos es lo malo con sincronize no lo sincronize es como cuando ocupas un candado solamente uno y solamente un método y lo es cuando pues quieres dividir como que esa sección crítica quieres vivir el alcance eso es más específico utilizar lo Entonces por qué podemos utilizar sincronize No pues porque en Java cada objeto de Java está creado de forma que tiene asociado un candado
(15:52) Entonces cuando nosotros utilizamos synchronized pues lo lo usamos V es como que lo activas entonces por eso como que a todos le puedes poner sincron y además también sincronize previene que que dos o más los accedan no a distintos métodos no solamente por por métodos sino por ejemplo si un objeto este lo p por ejemplo en este caso no si tenemos en este ejemplo tenemos eh estas dos variables count y stock Vale entonces eh estas dos variables si le ponemos por ejemplo Run solo funciona Eh bueno en run aumentas en increment la variable count Entonces
(16:49) si nosotros le ponemos sincronize aquí este va a haber O sea no podemos no ejecutar increment eh de forma como sola no o sea porque para para modificarlo este Digamos que ya está ocupado el candado de Pues que que modifica la variable count y de la misma forma con stop Vale entonces como stop está aquí también no podemos modificarlo acá porque se está modificando ya aquí o sea como que sincronizas así super como que todo lo meten en el mismo candado entonces Pues es lo malo no no es muy personalizable A diferencia de la classe
(17:34) lo que es así no por ahora sí que pones eh donde quieres que inicie y donde quieres que acabe entonces la diferencia en realidad Pues podría ser el scope no el alcance e como que es más fácil utilizarlo eh Bueno o sea cuando queremos personalizar Ajá Exacto sí como dice Sebastián no eh un un buen este como un buen resumen no O sea todos los métodos y funciones que utilicemos dentro de de un sincron se bloquean para todos los demás hilos Exacto o se todo se vuelve un candado enorme Sí y bueno entonces es la gran
(18:17) diferencia no pero nosotros ya vimos secciones críticas entonces como que siento que no hay mucho que decir aquí más que pues ver si acaso la documentación Vale dice uel Entonces es mejor usarlo Pues sí O sea en realidad si Eh Pues bueno van a ver no si nada más ocupamos no sé un candadito no para un contador y solo queremos ponérselo a la al método increment pues está bien no O sea usa sincronize no O sea solo ocupamos algo así pero si ocupas no sé por ejemplo en la en el ejercicio se no que les voy a dejar Si ocupas si te dejo no
(18:59) e por ejemplo perteneces a un equipo de trabajo estás a cargo de de dar acceso no a un servidor O sea tú eres ahí el que da acceso y seis personas te pueden mandar tareas para que las ejecutes en el servidor Pero tú solo puedes este aceptar una tarea por integrante y además no puedes dar acceso a más de tres al mismo tiempo no como que Ah sí como que usar sincronize Pues no va a funcionar No porque te están pidiendo demasiadas cosas o sea tienes que solo puedes aceptar a tres y y solamente una tarea por por cada de esos de esas seis
(19:33) de esos seis integrantes no Entonces ahí como le haces con sincron pues como que no no o sea sinon es para cosas así bien bien triviales bien sencillitas y lock es cuando realmente queremos ahí hacer cosas no este más complejas por qué Porque lo por ejemplo pede usar un candado dentro de otro no O puedes tener 10 candados a la vez distintos Este y sincron pues es un mismo candado solo no O sea como que no te permite mucho eh Pues resolver cosas así muy muy complejas como o sea bueno no tan complejas Esto no es complejo no
(20:07) pero o sea es más este más elaborado no O sea no es tan sencillo tan trivial entonces bueno eh Esos son los logs y la clase semafor semafor ya viene también prediseñada en en Java y simplemente pues un semáforo que es es una generalización de un candado Por qué Porque te permite en vez de que entre un hilo a la vez a una crítica te permite no O sea la sección crítica de un candadito te dice solo un a la vez y este te dice Ah pues deja que entren tres no y cuando haya espacio si hay dos pues deja que entre otro si hay uno Deja que enten dos pero
(20:56) siempre máximo tres entonces este o n no O sea el número que sea entonces Bueno vamos a ello Vale entonces este es el el de la práctica anterior de la inconsistencia entonces Aquí empieza entonces Bueno aquí más grande esto Aquí está entonces eh aquí tenemos tres hilitos no y los tres hilitos este utilizan la misma este pues clase que implementa runnable y esta clase pues se llama contador synchronize no O sea este entonces empiezan los tres luego eh esperamos no a que todos terminen con
(22:01) Joy y finalmente regresamos el valor no Entonces qué hace cada uno de los tres o sea cada uno de los tres ejecuta este bueno primero ve cuál es su nombre no luego este hace eh en estas líneas se duerme tantito unos 100 nanosegundos y Ya entonces eso hace cada uno vale Y bueno cómo funciona sincronize si lo ponemos este así miren es muy curioso como lo ponemos en el método Run tenemos este 10 ejecuciones no de 0 a 9 del del hilo cero luego 10 ejecuciones del hilo dos y luego 10 ejecuciones del hilo uno porque como lo ponemos en el Run Y eso es lo
(23:02) que hace cada uno en Start pues ahora sí que el que gane primero en en tomar es en ejecutar el ron en este caso ganó el hilo cero luego el hilo dos y luego el hilo uno no o sea porque bien sabemos nosotros que este esto se ejecuta en orden así O sea en el orden que que sea pero digamos que aquí el gón es el que entra primero en Run y hasta que no acabe de ejecutar las 10 va a dejar el candado que es pues es todo el método y Y entonces el otro puede hacer pues este ejecutar no después su r dice puede pasar que un hilo lo tome
(23:38) dos veces seguidas Sí si puede pasar si puede pasar a sincron si puede pasar o sea como que no es no es este no es justo Pero bueno en este caso no no lo vemos no O sea Bueno nada más se forman 0 dos y un otra vez no otra vez ganó el dos otra vez ganó el dos Este pero sí O sea sí puede pasar no sincron no es justo solo es starvation free pero justo no O sea eventualmente todos pasan pero no no este no en orden Este Entonces por ejemplo aquí pues todo se forma no en este otro ejempl tenemos igual no los tres hilitos la misma el mismo rable
(24:24) eh pero miren ahora este utilicé ahora ya no cuentan de en un for o sea de como de 0 a 10 Ahora cuentan mientras no se ponga la variable en stop Vale entonces eh Cómo modificamos la variable en stop bueno para que se digamos que mientras sea falso que que funcione no y cuando se ponga en verdadero que pare y que Dejen de estar contando no entonces eh quiénes son todos los métodos no increment value excepto est y también este el método Run no pero pues bueno en realidad ponerle sincronize aquí pues es un poco redundante no
(25:14) este porque Bueno aquí ejecutamos el increment no pero pues como les dije en realidad te permite hacer esas cosas no O sea ponerle a todo aunque sea métodos que usas dentro de otros pero todo lo mete en un gran candado entonces aquí Qué sucede este Bueno aquí lo que hace el método Elo Main es que se duerme tantito 400 nanosegundos y luego lo detiene my Run St no y finalmente Espera a que terminen todos y este y obtiene el valor no Entonces eso hace pero por ejemplo o sea también como aquí Este ejemplo Porque tampoco es tan
(26:03) trivial utilizar sincronice en todo porque Bueno no sé Luego me pasa que tengo alumnos que no vienen en todo el curso luego vienen al examen final y les pido implementar algo y pues a todo le ponen sincronize no literal a todo a todo este y pues bueno tampoco es tan trivial o sea ustedes creen o sea Lu esos alumnos creen que si es así como Ah mira ahorita paso el curso así pero no es tan trivial utilizarlo a veces puedes crear programas que no se detienen por ejemplo aquí no se va deener nunca Por qué Porque si pones a sincronize a stop
(26:43) también en sincronize qué va a pasar que que este Bueno ya hay que detener esto si si lo pones en este también adentro del Gran candado que es sincronize pues se va a formar entonces si pones a dormir al hilo no este 400 y luego le das Así que se detenga pues como este esta este método está dentro del Gran candado único no de pero aquí pues ya lo tiene eh el primer hilo no se buen uno de estos hilos uno ya está dentro del único candado no y no va a parar hasta que lo detengan con
(27:52) estop igual a true entonces nunca va a suceder No tampoco es tan trivial o sea si hacemos estas cosas no pues no se va no se va a detener porque nunca va a dejar de dar vueltas aquí nunca va a dejar su candado no por ejemplo mira aquí V ven todas son del mismo hilo no del hilo cero todo todo por el mismo hilo Entonces es lo malo de sincron O sea hay que saber dónde lo ocupas si si ocupas una variable no que funcione independiente a lo que está dentro no este Entonces aunque le quite el sincron tampoco se va a detener si se lo quito
(28:33) Sí y de hecho aj se lo quito s porque ya este digamos que el objetivo de de este pues es nada más O sea digamos que del método Run Es simplemente leerlo no entonces si yo lo cambio pues ya se va a reflejar en este no eventualmente Ah sí sí porque Bueno entonces es porque el método pues ya no está dentro del candado simplemente vale si esto Sí se detiene porque sucede aquí entonces lo cambia y ya está es todo lo que estaba dentro de del Gran código no sea bueno del Gran bloque de de este si puede pero por ejemplo es
(29:28) distinto no si en vez de poner sincronize aquí lo dejamos solamente aquí no en increment es distinto ya vieron Ah por ejemplo si en vez de ponerle sincroniza todo al block Run se lo ponemos solo al increment También tenemos como algo eh o sea no suceden inconsistencias porque pues protegemos el el código pues sensible que es este pero ya permitimos que que este que los hilos avancen no porque ron pues es el ejecutable de todos los hilos entonces permitimos que todos los hilos traten de obtener el candado Entonces por ejemplo aquí pues
(30:13) lo obtienen el hilo uno Este Bueno en realidad se imprimen de forma distinta no en realidad pues primero el hilo cero Pues que tiene lo que incrementen un luego el uno luego el dos no luego otra vez el uno luego el cero Y luego el seis no luego el siete y así pero ya vieron o sea como van cambiando Ahora sí cambian los hilos es distinto no eh pero por ejemplo aquí si utilizamos este synchronized no en stop pues quiere decir que el hilo Main también se pelea por eventualmente tomar ese stop no O sea ya no está como
(31:04) ya no tenemos el un candado sobre esta lectura No sí solo utilizamos syncron en los métodos anteriores pero no en en este Entonces esta lectura no está dentro del mismo candado Bueno del candado no del candado único Vamos a ponerle y se detiene vale Ajá sí por qué se detuvo porque antes al estar sincronize en todo este bloque digamos que todo lo que estaba aquí pues era código sensible no O sea era estaba todo dentro del mismo Entonces qué quiere decir
(32:08) que que este entonces quiere decir que que la que esta lectura porque pues esta es una lectura no sobre la variable stock quiere decir que esta lectura también estaba dentro del mismo candado vale o sea por eso por eso ahora sí se detiene Pero si metemos a esta lectura d del mismo candado que esta no o sea puede ser que no vale o sea como sí sí no se va a detener si metemos esta misma lectura y por qué también porque solamente el que tiene el candado es increment no Entonces le das chance a que los demás hilos eventualmente
(32:47) puedan leer no este While stop o sea como que dejas aquí el candado y todo esto todo el bloque que está acá no dejas que alguien más lo haga y vuelves otra vez aquí y Es más hasta te duermes no te duermes 100 enos segundos y con eso le das chance a que alguien más no este trate de adquirir el candado en increment vale o sea ahí Ahí sí se detiene pero si le ponemos a todo no no o sea es más o menos Sur vale bueno Entonces yaas no este Eh bueno ahita veo no lo vuelvo a explicar e Entonces este ya pues acá es un ejemplo con con
(33:40) Lo eh este aquí Cómo funcionaba miren pues simplemente Tenemos aquí tres hilitos no eh todos comparten el mismo runnable y por lo tanto en el mismo runnable eh comparten pues la misma variable count este también hay un stop Y tenemos todos compartimos un mismo candado vale que es en este caso reentrante algo un candado ya predefinido en jav entonces eh Ay se borré la r sí entonces este en todos los métodos no les ponemos eh que inicie el candado y y lo deje no try lock y muy importante usamos try Finally por si pues no sé hay
(34:36) alguna falla aquí no algo pasa pues que siempre lo deje siempre siempre lib el candado para que alguien más puede entrar entonces eh todos los métodos pues tienen lo mismo no leer el valor también stop también está dentro del candado y aquí este eh También funciona de la mismita forma mientras est en falso stop Pues que los hos incrementen no nos dormimos tantito entonces como que en lo que nos dormimos pues como que damos chance no de que alguien más lo tome que tome el candado en increment Entonces eventualmente el
(35:17) hilo Main este hace hace que la variable stop sea verdadero y acaba no termina todo entonces se parece un montón al anterior o sea como que ya vi que en este caso podemos hacer cosas muy similares no O sea casi las implementaciones Son igualitas por ejemplo pues aquí se cuenta de cer hasta 30 pero bueno es porque le di más en el Run no este pero también acá o sea como que van cambiando los hilos no 1 do 0 do1 o sea vamos dejando que como que todos se vayan moviendo pero siento que es se ve más bonito con Loc Ajá sí no es
(36:01) como que más limpio y es que te permite o se Esto está Un ejemplo muy sencillo es como el ejemplo que dice Uriel no bueno Y es mejor utilizar sincronize o utilizar lo pues depende Si vas a hacer algo así muy simple pues inon te funciona no este igual no como dice dice dan se ve muy bonito sí no como que justo dices qué está dentro de tu sección crítica qué está dentro no y ya vale entonces bueno este y aquí puse la línea 22 se tiene el contador Ah bueno claro no hay que tener cuidado también donde ponemos que se
(36:48) detiene porque si lo detenemos aquí no O sea bueno pero es algo que nosotros ya vimos desde la anterior si no si en vez si comentamos esta no amos esta y le decimos que se detenga mejor después de que se hace el join no nosotros ya sabemos bien que el join lo que hace pues es esperar a que todos se acaben pero pues o sorpresa la línea 26 yo les estoy diciendo que acaben no Y si no les digo que acaben pues no O sea como que aquí la lógica está no espero que todos se acaben pero yo soy quien les va a decir cuándo entonces pues es un
(37:23) programa que no va a acabar nunca no se hay el problema Entonces Bueno hay que tener cuidado no dónde ponemos el Stop en este caso y y ya Bueno creo que es el único ejemplo que que puse aquí Pero bueno también te puedes meter el pie no Ah También acá si le pones el lock a todo esto no a todo a todo digamos que el método Run porque nunca lo vas a dejar Entonces como los hilos justo en Start Pues es lo que el método ron No ni siquiera le das chance a los demás de que empiecen y no se diga Main No si metes también el Stop dentro del mismo
(38:05) candado o sea como también puedes llegar a a una misma situación si metes todo en mismo candadito no vale entonces bueno está como bueno siento quean difícil no pero si hay que tener cuidadito con esas cosas no Sí porque puede ser que tengamos Eh pues O sea que diseñamos sistemas que se congelan no con deadlock que se congelan vale entonces ya de aquí 44 Ah Perfecto entonces Bueno después eh eso eso es este lo muy sencillito de utilizar Ah bueno y la interfaz loog también Pues en realidad tiene más cosas Ah tiene tenemos tiempos este Ay me
(38:55) lleva Tenemos también tiempos de Time out oa como de expiración tenemos eh distintas este lo puse bueno a ver Aquí está Entonces tenemos así este distintos métodos Ah pues el típico lock unlock es lo que necesitamos para hacerlo funcionar vale Pero en realidad también está este este método interr Bueno no sé este que simplemente adquiere el candado este A menos
(40:01) solamente solamente si el hilo que lo tiene se encuentra como este pues sí como interrumpido no O sea tiene tiene una interrupción e también podemos agregarle condiciones Pero eso lo vamos a ver después está este otro que TR no adquiere solamente el candado si este está libre en al momento justo de hacer La invocación y si no no intentes no si no vete o sea es como el trock si está ocupado y no lo vas a no vas a obtener la sección crítica enseguida este Vete no e y este hasta tiene como con tiempo no este intenta adquirir el candado si no lo
(40:43) adquieres en un periodo de tiempo muy definido pues ni lo intentes no son como las cosas que hay Pero bueno eso lo vamos a ver lo de las condiciones y el tiempo lo vamos a ver después porque también tiene su chiste eh Pero bueno ya también están los semáforos que es otro pero bueno eso lo vemos ahorita que les explique lo de los ejercicios igual es mu muy sencillito ahora en los candados en vez de usar lock y unlock utilizas adquire y Release como igual adquiérelo y libéralo déjalo Eh entonces lo mismito Nada más que ahí
(41:20) pues los semáforos los inicializa porque pues ahora permites que más de uno esté en sección crítica es la diferencia es mu muy sencillo o sea bueno lo sencillo es utilizarlo no ya lo difícil es analizar Cómo es que funciona Eh entonces luego lo siguiente es este las puls de hilos ya también ya tiene este predefinidos eh las pulls de hilos las pulls pues simplemente son implementaciones de de muchos hilos o sea te permite en vez de utilizar de crear un hilito por hilito no sea nosotros así a manita No aquí creamos este cuatro tres hilitos No
(42:08) primero los los este los creamos aquí este un objeto de tipo TR les pasamos el Run luego les damos Start y y este no como que así a manita cada uno no Si queremos crear 10 hilitos Pues a manita pero acá las PS de hilo que lo que nos permiten es este pues le dices le dices a al objeto en este caso es la interfaz no le dices pues yo quiero una p de Hilos de 10 no O Quiero unos 20 hilos unos 100 entonces así ya tienes que estarlos creando manita Esa es la diferencia entonces creas un grupo de hilos y una vez que los creas los hilos ya están
(42:53) esperando tareas o sea como y esas tareas digamos que se les no se les entregan a los hilos Y entonces el hilo algún hilo que esté disponible la va a tomar la va a ejecutar y pues va a finalizar no y va a esperar por otra tarea o sea por ejemplo si ponemos 10 hilos y les damos 100 tareas pues este cada uno va a tomar una no y y en cuanto se se liberen van a ir tomando otra y otra y otra hasta acabar la 100 o sea no no precisamente como en un orden No simplemente es como en disponibilidad y ya este entonces así es como no darles
(43:28) este un montón de tareas a a un grupo de hilos y ya está eh utilizamos puls Bueno o sea como que me imagino no que siempre es la duda para qué O sea para qué utilizar así puls Bueno pues una de las cosas es para reusar los hilos este una de las cosas es para reusar los hilos eh Y así podemos mejorar el rendimiento Pues si nuestra compu tiene nada más por ejemplo la mía pues está muy chafita no bueno he visto sus compus Están muy padres pero bueno la mía solo tiene 10 hilos entonces si yo quiero ejecutar 100 tareas pues los pongo a
(44:11) reutilizarse no para que entre todos hagan las 100 tareas Ah entonces para eso nos convendría em y bueno También nosotros nos conviene para probar nuestras implementaciones y no estar haciéndolos así todos no una manita de un dos tres no no estar haciendo eso Eh entonces no conviene utilizar puls m Pues si si utilizamos O sea si en realidad hacemos procesamiento secuencial no en batch O sea si pues si como que no tiene mucha mucho sentido No mejor pone un solo hilo o si no importa la cantidad de los que ocupemos no pues
(44:50) si no te importa si estás bien con dos pues para que usas una Pull no y ya es es como pu tampoco es como que ocupes muchas razones no para para usar una po entonces Bueno ya ya tenemos la interfaz executor este de aquí y este tiene un método execute y que recibe como parámetro O sea la tarea que va a ejecutar que están esperando todos son van a ser tareas rable entonces di en una pool Entonces los hilos están como en una como en la puerta de la sección crítica y solo están esperando a que uno entre y así Ah no precisamente no hay secciones
(45:34) críticas ahí o sea digamos que están una pool los tiene inicializados a todos o sea como que sería sería como esta parte están creados no están esperando empezar están esperando que suceda línea 16 no Start pero no precisamente una sección crítica eh Por qué por qué suriel porque no los Ejecutan O sea no los mandan este en orden no O sea si hay 100 tareas entonces eh Y tenemos 10 hilos pues 10 hilos van a currir al mismo tiempo no y y todo el tiempo van a estar eh Pues ansiosos por por agarrar otra y otra y otra Entonces en realidad si tenemos 10
(46:25) hilos pues van a haber al menos 10 tareas que se ejecuten este como en de forma concurrente vale o sea no no es como que un hilo acabe y luego empieza el otro y luego empiece el otro Sí le podemos dar esa opción a la a la pool no O sea también la podemos personalizar para que sí funcionen en así justo en paralelo no y que sea como sección crítica pero no precisamente vale o sea como que los tienes ahí esperando nada más solo están esperando que haya alguna tarea que ejecutar y no precisamente en orden y no precisamente Ajá
(46:57) Exacto sí Exacto zel Sí todos pueden estar haciendo una tarea al mismo tiempo entonces eh Eh bueno Esta es la la interfaz no Pero además ya nos simplifica un poquito más la vida y este y tenemos esta sub interface de executor que implementa estos siguientes métodos y que son suficientes y lo mínimo no para bueno suficiente así para crear pues una full Vale entonces Bueno Este Entonces esta interfaz de Java pues es documentación vale esto que ven aquí es documentación nada más que se las puse aquí porque pues está como bien
(47:44) resumido eh entonces tiene todos estos métodos que es vo shd que es por ejemplo eh Bueno voy a mostrarles mejor acá en un programita No acá Entonces por ejemplo tenemos eh un execute una un execut service entonces este ahí Bueno aquí está no la tenemos la la la Pull la creamos y le le decimos no que sea una Pull fija de cuatro hilos vale una Crea una p de cuatro hilos sí O sea inamovibles no O sea no puedes agregar cinco más o
(48:48) así O sea fij eh luego le dices que ejecute eh 10 tareas runy no ejecuta 10 tareas r y muy importante no este no hay que esperar que una termine para ejecutar otra vale eso Y execute entonces lo que recibe es la tarea ejecutar la tarea pues es una tarea rable es esta que está acá Vale y simplemente le pasamos Eh Pues el nombre como de la tarea que voy a ejecutar y simplemente este método de shutdown lo que hace Eh pues lo tengo acá No pero bueno lo que hace es termina
(49:52) las tareas que se hayan enviado al ejecutor pero digamos que muy importante H no las termina de golpe vale este o sea como simplemente lo que hace el executor Shot es le dice al executor termina las que ya tienes vale No aceptes nuevas pero termina la que ya tienes entonces quiere decir que pues va a ejecutar estas 10 y ya no va a ejecutar más pero no precisamente es que ahí vayan a acabar vale es como lo que lo que tarden No simplemente es como que le ponen ahí un como este pues no sé cosa como que el cadenero no de de una fiesta pues deja
(50:43) entrar las tareas no que son y quieren entrar más simplemente pone la cadena de que ya no hay pero no es como que las tareas dentro ya se hayan acabado vale o sea no es como que cortemos a la ejecución simplemente cortamos que haya nuevas es lo que nos dice shown vale Sí o sea no es como como un stop no es un stop es como un ya no permitas que entren más eh Y bueno después está esta otra que es este Shut down Now y también bueno est Shut down Now Pues también es como shd acaba corta que ya no entran más pero más trata de
(51:28) de de como Cancelar las que ya envió y además este por ejemplo bueno es que aquí tenemos dónde lo an este bueno el executor digamos que este bueno el executor una vez que que le enviamos las tareas por ejemplo aquí no le decimos execut execute y ejecuta por favor 10 tareas no Entonces si solamente tenemos cuatro hilitos y pues en realidad este Ford pues va a suceder en segundos no O sea bueno en en muy rapidísimo no O sea el Ford no se va des detener entonces a dónde se van a ir las tareas que no empiecen los los
(52:21) hilos toman las tareas eh bueno las tareas en las primeras tareas y las tareas que no no se hayan tomado se guardan en una kiwi vale es la kiwi de la pool Y entonces la kiwi tiene las tareas pendientes esperando a un hilo disponible es lo que sucede Vale entonces esta de execution shutdown Now lo que nos dice es que bueno no le vas a quitar al execut al executor o sea cada hilo la tarea que ya tiene este procesando no pero si hay tareas que están este en la kiwi que no se hayan empezado pero que ya las tiene el exec
(53:25) exec bueno ejecutor guardadas este pues lo que lo que dices es eh cancal las no O sea que nadie las tome Vale entonces es así este este ejecutor pues tiene como su cola de las pendientes entonces bueno Tenemos también esta esta pregunta no de shutdown que pues también la podemos ver acá Este también está de si si el estado de la pila o sea como es si ya no ya no hay más no O sea ya no hay más tareas y si es ter es terminate Es que realmente este ya no hay ni una sola tarea que se está ejecutando por algún hilo vale eso
(54:09) es como este comprobar si ya terminó eh También puedes eh poner como otra bueno preguntar no si ya terminó y esperas a que por un intervalo de tiempo no para preguntar y si no ha terminado pues vas a tirar o sea bueno este hasta puedes tirar excepciones no de que se interrumpa Eh vale entonces por ejemplo bueno igual ustedes podrían ya jugar con ello pero por ejemplo vamos a ver la de este ah punto y esp a ver este Okay entonces por ejemplo aquí
(55:49) Este sí Mira por ejemplo aquí preguntamos terminó no ha terminado no terminó o no ha terminado Este pero por ejemplo podremos preguntar también si se hizo el shutdown y sh cómo se escribe Sí por ejemplo realmente como que lo que nos dice aquí es Eh sí eh Bueno ya no se aceptan tareas
(56:53) pero no han terminado los hilos no de ejecutar todas las tareas es lo que nos dice vale Eh entonces d lo cerr sí lo cerré no Okay entonces también a termination puedes esperar por un intervalo que preguntes después de no sé n Bueno este 100 nanosegundos sí terminó y bueno así se ve un ejecutor ahí es muy importante también notar aquí que si se dan cuenta este tenemos cuatro hilitos no Y si se el sh Cómo se vería
(57:58) Ah pues fuero que pero por ejemplo aquí y es que el Shot lo que nos dice Dejen dónde está aquí sh regresa bueno Además tengo que poner una lista Pues creo que lo que nos podría decir H
(59:43) regres veo có lo cambio dice que my r my Ah miren por ejemplo es muy curioso no la lista este si se acuerdan devuelve las tareas que están en es decir que no han sido tomadas no han sido bueno procesadas por por ningú Entonces se vería de esta forma nos devuelve la Run este el spf el B3 o sea una 2s 3 4 5 1 dos 3 4 5 6 no en este caso seis Entonces nos devuelve seis tareas
(1:00:47) Quiere decir que lo cerró así enseguida y de las 10 tareas nos devuelve seis tiene sentido no quiere decir de nuestros cuatro hilos pues cada uno no tomó una cada uno tomó una una una tarea se puso a hacerla y ya este este pues no no AC no empezó ni con la otra no O sea había seis tareas listas o sea porque solo tenemos cuatro hilos no pero por ejemplo qué tal que usamos seis 1 dos 3 cuat cuatro tareas ya vieron o sea un dos 3 1 dos 3 cuat tareas y usamos se hilos mi compo es de 10 pero como Tengo un buen de cosas
(1:01:37) este abiertas a ver si Ah miren 10 hilos 10 hilos 10 tareas ya vieron si tengo nueve hilos y lo paro enseguida nos queda solamente una tarea Sí pues sí Okay entonces Bueno ya vieron noas así funciona este executor Ah bueno curioso no las tareas se van agregando este por ejemplo la tarea cer la procesa el Lito un no la dos el Lito dos la TR el Lito 3 Ah pues mir casi en la 5 el se sí casi en orden el nombre de hilitos no pero por ejemplo si tenemos otra vez nuestros cuatro hilos y no no hacemos Esto del shutdown no porque eso hace que
(1:02:35) acabe todo muy vamos a poner este por ejemplo aquí Ah tenemos cuatro cuatro hilos Ah s Sí aquí por ejemplo el hilo tres toma tres tareas no es como el hilo que más toma o tampoco controlas como quién toma más simplemente es en cuanto están disponibles para tomar otra vale o sea como que no no es este no es así que vayan formaditas Vale entonces este Counter Ah s est nada más es así no les pasa las tareas eso es lo que hago aquí con el r le paso la tarea le imprime y este Counter po lo que hace es este también
(1:03:39) usamos un executor de cuatro hitos eh igual ponemos este las tareas como por como en orden no y le pasas la tarea al este al a al método increments es muy curioso aquí si se dan cuenta Bueno bueno Me imagino no dicen Bueno dónde está el r acá un No acá la clase que que implementa la interfaz y acá no está no Pues resulta que cre que a partir de Java 8 si de Java 8 meten nada más una forma distinta de como de escribir las interfaces vale de como de implementar estas interfaces y te permiten usar la notación lambda que es
(1:04:31) como similar a la que se usa Bueno yo la conocía de jav de javascript la anotación lambda este Pero bueno es muy como de de este programación funcional no Pero simplemente es como sintaxis entonces este en vez como de poner Run pues nada más pones la notación lambda este y lo que esté dentro o sea lo que esté de este lado dan por hecho por default que es el método Run Okay es como que y como como en el método Run es tienes este método increment no que aquí es donde sí está la variable y como todo está en la misma clase pues puedes
(1:05:11) acceder ella no hay problema Entonces este le mandas no al execute que ejecute pues el contador entonces Ah miren de 300 no eh que que ejecute el contador y Este pero por ejemplo Ah sí muy bien s ya se me hace raro bueno que ejecuta el contador y eh le das que sea bueno que no acepte más tareas que se apague ya el contador y entonces aquí Bueno miren pude haber usado la Wi no el preguntar si ya terminó este Pero bueno lo que yo hago pues es simplemente poner a dormir el hilo Main Para esperar en lo que realmente terminan todas las tareas que
(1:06:10) son aquí 300 para cuatro hilitos y este y y y pues nada más regresar la cuenta final vale ent por ejemplo en este caso este la cuenta final fueron 290 35 y son 300 Pues aquí sabemos no que hay una una este carrera por Bueno cómo se condición de carrera no una este r condition Exacto se la quedó bien Entonces tenemos aquí una ris condition y ya está entonces pues es una forma ya vieron como que queda más compacto más bonito no no creen y pues aquí podemos este poner que en vez de cuatro puesan 10 no 10 itos y a ver
(1:06:59) bueno por aquí son 29 y ya está no ya no tenemos que hacer a manita las cosas a vian lasas Sí sí y bueno entonces una cosa es utilizar rbles y la otra es utilizar cables que son pues este pues son como runes pero que regresan están basados de hecho en ellos no en creo que que son está mismo bueno igual son es como una subinterfaz de Run un cable y como su nombre lo dice esperan eh A diferencia de los runs que son vacíos se acuerda no O sea el método aquí se ve Ah sí implementan un este buen nosotros tenemos no que que hacer este Run y es
(1:07:48) vacío siempre vo o sea regresan nada y y los cabs si regresan este pues lo que nosotros queramos o sea cualquier tipo de Java entonces este también es un contador aquí está la clase increment y este aquí tengo una lista de futures Ahorita les voy a decir qu son tenemos la el executor Service simplemente lo que va a hacer es que va a ejecutar este eh varias tareas Bueno aquí agregué los features para para mostrar no cómo va entonces bueno digamos que un cabol Eh pues lo que te regresa es este pues algún tipo por ejemplo en este
(1:08:48) caso podríamos dejarlo o sea podríamos descomentar no esta línea y este lo que nos regresaría pues serían increment ahora es entero ya vieron o sea como que nos regresa este el valor que se aumentó eh Pero bueno les quería Mostrar además y bueno también se pueden escribir al estilo de lambda porque Cab es una interfaz Okay entonces pero lo que les quería Mostrar era que es un Future Aquí tengo la entonces bueno eh cuando nosotros utilizamos el método submit y este el método submit lo que hace es este método lo que hace es que te
(1:09:40) regresa un Future y un Future nada más es el resultado este que nos devuelve el cable entonces quiere decir que este bueno hg de cuenta que este submit siempre te va a devolver Pues el resultado del C y futur te van a ayudar como para guardarlos no en esta variable y después no sé por ejemplo depende no para que ocupes estees todo lo que te devuelve el c no bueno para los ejercicios les puse yo como una forma Entonces siempre que usos A diferencia de executor son como análogos pero que submit si te devuelve siempre un
(1:10:29) resultado o sea un objeto Future y el executor no O sea el execut es como va plano no sea no me importa el resultado me revolv un poco entre la definición de Ok ahí voy este dónde bueno voy a ponerlo acá es un objeto Pues voy a ponerlo así vale es una interface eh similar a Run pero que siempre bueno que puede volver Pues
(1:11:35) un un valor vale Y ese valor puede ser de tipo este pues no sé entero String un objeto lo que sea vale es un una este una interfaz también vale que en vez de devolver void no sea r Pues siempre no no devuelve nada si es vacío pero Cab siempre o sea te puede devolver un valor es la única diferencia con c Vale entonces para digamos que Para aprovechar para aprovechar los no futures un Future es un objeto en Java así como Bueno pues así como cualquier objeto no un objeto enva que lo que hace Aquí está Bueno de hecho es
(1:12:40) interface es una interface que lo que te permite es este como que guardar un valor y puede ser de cualquier tipo vale o sea por ejemplo como que es como el Perfecto amigo de Cab no siab devuelve algo pues Future lo va a guardar entonces lo que nos devuelva AC lo podemos guardar en un Future entonces eh el feature tiene varios métodos vale usamos features eh para guardar el valor que devuelve Vale entonces este Future lo que nos va a permitir es este pues uno no tiene el método get que devuelve el resultado del
(1:13:30) C y va a esperar va a esperar de ser necesario O sea si le ponemos feature.get este no va a dejar que el código siga A menos que obtengamos ese el resultado del Cab es como bloqueante vale Y este si Us utilizamos podemos también utilizar es mismo método get pero con un Time out Podemos esperar nada más un tiempo o se en vez dees esperar hasta que sea necesario hast para que acabe pues esperamos Hasta que expire el Time out eso es como una opción y además podemos preguntar si realmente este ya tenemos el Future o sea como si ya realmente
(1:14:14) Future devuelve verdadero si la tarea se realizó O sea si el Call ya acabó Ya tenemos el resultado también te permite cancelarlo este y bueno el cancel como que es bien rudo Porque si si se envió El carab y a unos o sea están la aquí y aún no lo toman lo cancelan no Y si ya lo tienen pues pues ni modo O sea ya pues manda este ajá si puede puede llegar a interrumpir el objeto o sea puede llegar a interrumpir el calab Aunque puede ser que el no acabe no es como bien rudo el cancel Y también puedes preguntar si realmente funcionó No si realmente está
(1:14:58) cancelado es lo que nos permite hacer un Future Pero bueno Ahí les va no para que para que vean como bien para qué se ocupan Entonces esta línea de aquí pues es como se ve un Cab vale o sea digamos que esto no esto es un c estilo lamb Por qué Porque a diferencia del Run que vimos acá que que pues este tiene el increment vacío aquí si no tiene un incremento con entero Entonces se vuelve enteros Pero bueno sea entonces este el executor para poder como cachar los futures el executor para poder cachar los features lo que lo que para tenemos
(1:15:45) que utilizar el método submit Entonces el submit acepta el Cab vale Este C como parámetro de submit y lo guarda en eh la lista de futures vale porque ya aquí creo una lista de futures Okay entonces add pues es en realidad de de la lista no o sea es una un método de de un objeto de tipo lista en Entonces los va a ir guardando y vaar aquí o sea bueno va a preguntar por ejemplo dec Oigan el Future el primer fure que guardaste ya acabó vale es el no no el es todo esto o es la función lda vale es esto vale ajá si es que es una O sea
(1:16:59) si lo buscan jaa Ja Java lambda Java expresiones lambda son las expresiones lda y lo que te van a decir es que las interfaces Ajá bueno las interfaces las podemos escribir de esa forma pero bueno Dónde está una buena explicación pero Bueno este Ah bueno a ver cualquiera Ah no aquí está la pero s no está muy linda esta no pero bueno se si lo leemos con cuidado Dónde estará un ejempl Bueno mira lo creo que está mejor Este ejemplo de acá por ejemplo Cuando tenemos una Ah en este caso vale tenemos un un
(1:18:08) una clase que implementa una interfaz runnable no en este caso runnable y pues la interfaz o sea es la clase de que se compone de atributos de métodos y de este muy importante no que la clase de rabol tiene por default que este que implementa bueno que se debe sí se debe implementar el método Run vale se se debe sobreescribir Entonces cuando lo queremos hacer de forma estilo lambda este solamente se hace así eh Porque son funciones anónimas así les llaman entonces eh digamos que lo está de este lado en realidad es lo que está
(1:19:06) eh es el método Ron en este caso vale lo que está de este lado y lo está del otro lado eh Pues como la función es anónima no O sea como que te permite hacer eso y no te acepta adás O sea si lo escribes de esta forma no te acepta parámetros de este lado no O sea este Bueno pero bueno no sé creo que si lo buscas estará como mejor explicado no de cómo se hace como pero pues es algo de sintaxis vale o sea no es algo como de Pues sí como de no sé que tenga como algo más de semántica no de explicación simplemente este dice no es una forma de
(1:19:52) escribir las clases Run entonces entonces en vez de aventarme yo todo esto pues simplemente lo escribo así sobre todo les digo cuando pues es algo muy corto no O sea de hecho ya tengo aquí la la el método Entonces lo puedo meter de esta forma y Pero bueno hay varias formas de escribirlo creo que no me acuerdo tengo pésima memoria pero la otra es e la otra es y hasta lo escribes como como variables Ah De hecho también están las streams junto con eso nacieron las streams no este en Java ahora tien como lenguaje estilo
(1:20:43) funcional no por ejemplo esto se ve como bien python no Pero bueno ya también te permiten hacer esto o incluso esto no Esto es para referirnos a un a un este atributo del método no pero bueno o se ya creo que bueno tal vez te saldría mejor no no lo tengo aquí preparado para explicarlo pero este Entonces es muy importante no el método cabol o sea el cabol es esto Vale entonces el cabol quiere decir que también lo podemos escribir eh de esta forma así vale o sea también podemos aventar como un un Class no sé mya ponerle nombre no que no sea un un
(1:21:33) anónimo como en las funciones L y muy importante al carab le gusta no sé no que sea de tipo String y así vale sea se escribe de la misma forma Y pues también tiene un método Run pero en este caso como es strings Pues sería Stream porque el cabo la diferencia del del Run pues regresa este no entonces así Bueno entonces le importamos no entonces bueno se podría escribir de esta forma Okay sí se parece a llp también a tamb es que también este un tiempo aprendí japt Pero ya cuando vi esto dije quéda Bueno como que ya siempre como tan rudo tan tan tan
(1:22:40) estricto y luego hacen estas cosas como que no lo esperaba de este Bueno entonces cre porque yaes que es un relajo Noa pero ya que estricto todo bien este con sus tipos no los cast Ajá Y ahora resulta que tenemos este programación funcional Pero bueno e entonces que me quedé Ajá pues hay que ver esto no cómo se implementa Ah es que si dije algo ahí escrito mal Bueno hay que ponerle a esto toces ya vieron bueno por ejemplo Qué pasa aquí no este se Ejecutan los los este las tareas las n tareas la que son 300 no entonces Esperamos que al final
(1:23:44) pues la cuenta sea 300 pero bueno ni siquiera no utilizamos aquí sincronizo Pero bueno ya en esta sí se logró no si no utilizamos sincronize o sea como que no hay consistencia en una de estas nos va a salir un número extraño no Ah mira Ah miren aquí no nos salió 299 porque no usamos sincronize si le ponemos aquí sincronize ya con eso vamos a tener siempre 300 no o si usamos los lo que sea entonces a ver aquí Qué pasa No primero creamos la lista de futures Por qué Porque pues Son un montón Son 300 no Entonces no puedo crear nada más
(1:24:22) hay un Future tengo que crear una lista bueno o sea es lo que yo quiero no para para guardar todos los features este y un fature que que simplemente pues es un objeto que me va a permitir guardar lo que me devuelva el Cab Vale entonces y ya está predefinido en Java entonces Ah bueno Y que el feature puede ser de cualquier tipo por eso en este caso pues van a ser enteros Por qué Porque pues estamos aquí guardando enteros Okay el c devuelve enteros entonces este Bueno entonces hago este execut submit porque el submit lo que hace es que me
(1:25:04) devuelve un Future entonces eh le paso el cable y y este entonces esto se va a guardar no en el F después eh Bueno aquí nada más puse como esta línea para que veamos eh cómo sale No si preguntas si se terminó la tarea Y qué tarea la número cero de la lista ok entonces este get lo que nos dice se acuerdan lo que nos dice este es bueno este get Es sobre la lista ajá si es solamente como accede a al índice cero de la lista y pregunta si ya terminó no es lo que nos dice esta línea a pero no es la de los de Entonces
(1:26:11) es la de la lista vale la del índice entonces aquí qué hacemos pues simplemente este le decimos al executor no No acepte más tareas pero no le decimos o sea bueno no lo no lo terminamos en realidad le decimos que no acepte más y ya finalmente acá qué hacemos este le decimos que nos imprima este mientras eh el Future y e esté terminado Eh bueno mientras el feure no esté terminado Me detengo vale o sea tengo que esperar para imprimirlos todos o sea para realmente imprimirlos todos no
(1:27:15) acceder a ellos ocupo pues ver que realmente hayan terminado pero si no me voy a quedar en este Wi vale ya vieron o sea como que me quedo dando vueltas hasta que realmente ese feure entonces pues acá esa línea se ejecuta pues una vez que ese Future Ya está entonces eh guarda en result el valor del Future no que es future.
(1:27:46) get y pues nos da el índice no el índice I y el punto get ya ahora sí es este se refiere a este método de acá H al método al método de aquí no get a este de aquí vale entonces qué nos va a devolver el resultado del calab yba a esperar de ser necesario pero bueno ahora no va a esperar porque yo aquí esperé no O sea no no lo forcé a terminar O sea no lo bloqueé aquí lo imprimo Vale entonces ya finalmente bueno Aquí lo guardo y aquí lo imprimo no el res Entonces por qué hago ese try Catch porque el Future los futures cuando hago
(1:28:33) future.get aj si es bien raro no ver el Future y los corchetes pero en el mundo concurrente lo solemos ocupar un montón a como en los programas por ejemplo no este el Peters no cómo sería con corchetes pues Bueno nada más a ver si si está bien Pues sería así no verlo así O sea qué voy a hacer mientras sucede esto nada pero ahí me quedo vale Sí ajá O sea sí no sería No no va nada dentro pues este nada más esa línea como que te hace quedarte ahí vale Ajá vale Vale entonces este los vas guardando no y los los imprimes y bueno
(1:29:23) pones todo en el trycatch Por qué Porque el Future Cuando haces future.get Te avienta una interrupción una excepción no entonces hay que cachara y ya este y bueno acá Este ya después me duermo tantito no para que realmente esperar que todo haya acabado y este Pero bueno en realidad creo que ya habría acabado desde acá pero bueno para para revisar la cuenta final eh Porque Bueno aquí implica no que todas las tareas ya terminaron o sea en esta línea como que forzamos no a que a esperar o sea por eso se tarda un poquito en
(1:30:02) imprimir si se dan cuenta no O sea como que va medio lento y en este caso ya vieron la cuenta final es 29 no ajá si creo que aquí sí porque. pues bueno es del 298 al 99 a ver esa también es 299 y se tarda no como que lo imprime lento por qué Porque va viendo no que todos hayan terminado Ah miren esto 298 y hasta aquí podemos repasar no eh es curioso no quién quién fue quien leyó doble o Quien escribió el mismo quien se retrasó no pero sí entonces supone amos sincrona está aquí dónde se p 300 No ahora sí y se supone que debe
(1:31:12) dar siempre 300 300 No ya con eso mitig el problema vale o sea bueno ya en la la teoría vamos a ir viendo no qué otras formas podemos mitigar estos problemas pero este entonces bueno así así funciona vale lo de los futures más o menos este es como que en esta práctica estamos viendo no Cómo utilizar ya lo que vale igual si Cualquier duda me dicen va entonces Eh ya después llegamos a a los ejercicios Ahora sí sí bueno Y acá no más Les comento que Ah bueno que ya va además o sea todo esto de los PS pues es todo el mundo vale o
(1:32:02) sea eh Hay gente que se dedica como que a analizar el trp o sea como el performance Cuántas eh tareas puede ejecutar los siglos hacen gráficas si las prueban en computadoras con 64 cores así oa cosas así no todo un mundo Eh pero buenoa en Java además de de el executor el executor service además de este tenemos una clase que ya implementa la interfaz No todavía no hac el trabajo más fácil no Bueno más difícil no sé pero o sea todavía una especificación des de la interfaz que se llama thread executor que lo que hace pues es implementa la
(1:32:45) clase executor service y nos dan herramientas para ejecutar y terminar las tareas y nos permiten especificar las características de la cola para las tareas porque como les comenté las tareas que no se no no las hagan iniciado a los procesos a los hilos pues se guardan en la cola como que de tareas pendientes entonces Eh pues tiene su chiste o sea hay distintas implementaciones de colas hay colas que usan candados no colas que no usan colas eh que son acotadas no O sea que tienen un número fijo O sea que no aceptan más tareas conas que no lo son O
(1:33:26) sea que son ilimitadas que puedes meter el número de tareas que quieras entonces Bueno pero eso es así más específico y pues ocupamos saber un poquito más no de teoría Este Entonces yo creo que este Bueno voy a ver no si lo meto hasta el final eh Depende có cómo vayamos entonces bueno en el siguiente link pues ahí les dejé las las los programas este entonces Vamos hasta ahorita vimos hasta el programa 6 no hasta el seis pues son son los ejemplos y pues ahí jueguen no con los métodos estos que que vienen con el a termination por ejemplo no sea como
(1:34:09) cosas que quisieran ver no aunque creo que no lo ocupamos en la para la práctica entonces bueno para para la tarea vamos a ocupar el programa s y el o entonces bueno la instrucciones son las mismas no muy importante Ah bueno Yo creo que pasando con este fin le califico a la mayoría ya la revisé algunas y están muy bien ya sales el la calificación vale a a un par de equipos este Pero bueno se Espero ya este esta semana que viene a más tardar ya darle su calificación y este pero bueno entonces con Java 21 vale igual todo
(1:34:57) todo igual e este en un PDF me entregan la solución no de de lo que escriban y también la descripción de sus programas entonces Bueno vamos a ello el programa cola secuencial el que vamos a ver ahorita es una implementación de una cola secuencial Pues sí no entonces lo que tienen que hacer Ustedes es implementar una cola con currente H Pero bueno eso cómo lo van a hacer pues simplemente van a utilizar la secuencial no la van a mover no nada no así como está Y lo que van a utilizar va a ser una pool de hilos ese con executor
(1:35:38) service o sea lo que vimos ahorita y y muy importante primero no le van a poner ni candados ni sincronize vale o sea como que así como viene así la van a poner Entonces por ejemplo pues aquí tenemos la cola no la cola y es este Y pues simplemente este por ejemplo No yo aquí puse no un deq un enq este enq de X enq a luego borro borro x luego pongo B pongo c y luego hago un montón deq y al final pongo x no O no sé eso es una ejecución vale una ejecución secuencial entonces bueno así así funciona no sé si no le pongo los los
(1:36:25) este todos estos de esta forma entonces así una cola comú y corriente vale Eh pues este pues muy común y corriente no pues tiene tiene Tail este el nodo está acá solamente pues tiene el ítem no este donde vas a guardar el nombre del ítem el el el next que va a apuntar el siguiente nodo y este y pues se inicializa simplemente guardando el ítem entonces pues el enq funciona de esta forma el deq de esta forma no O sea Ay perdón de esta forma así muy sencillito vale como es una cola entonces e lo que tienen que hacer Ustedes es eh
(1:37:19) tomar no una implementación o sea bueno hacerla este con un executor este por ejemplo con este no Entonces qué hacen pues toman el executor no este bueno no les puse Cuántos hilos solo les puse concurrente Ah pero bueno los que quieran no pero bueno utilicen menos de los que tiene su compu vale no le pongan s no tiene casos o sea los hilos que creen van a ser falsos no o sea los solo va va a poder crear no sé si tienen 10 pues 10 y los Reales entonces usen menos de los que tiene su entonces bueno van a crear su su pool
(1:38:04) de hilos y luego le van a poner no sé este executor execute y que primero ejecute Pues un enq luego un deq No sé no O sea en orden como ustedes quieran le dan métodos a su a su cola Acá está entonces así pues lo van a hacer vale Cuántos hilos nos recomienda usar pues hasta tien ha así este análisis de Cuántos hilos debemos usar lo vi en un libro este usen usen este usen máximo máximo su número de hilos menos do vale Ah sí los 24 que tengo no sí que he presumido este usen usen los hilos que tienen menos dos vale o sea por ejemplo
(1:39:01) si Sebastián tiene 24 Pues que use 22 no O sea Pero bueno también Si usas 22 Cuántos métodos le tienes que dar no para ejecutar o sea Cuántas Cuántas este o sea cuántos porque bueno por ejemplo aquí pues yo le puse no testo Eh entonces si le pones 22 hilos pues me imagino que que mínimo unas 22 este eh operaciones no para que se vea como realmente que todos trabajan porque pues para qué le pones no sé 10 10 operaciones y si vas a hacer 22 hilos no O sea yo creo que el ocho está bien vale o sea la mayoría tenemos como 10 12 los que tienen cuatro
(1:39:50) hilos Pues bueno los cuatro no Ajá sí O sea pues sí no hay s modo pero sí O sea este los que tienen muy poquitos Pues sí usan sus cuatro y los que tienen unos 10 pónganle unos menos dos vale Y y Sebastián que tiene 24 Pues yo creo que la mitad está bien o sea tampoco tantos porque pues sí O sea cua no ocupamos mucho ahorita o sea la ejecución se tienen que armar una ejecución Vale entonces ya este es eso y luego bueno tienen que o sea lo crean no crean este ponen su Pull para su cola ya sin sincronize y sin lo y luego en el
(1:40:36) inciso dos lo que tienen que hacer es este ejecutar vari su implementación con diferentes secuencias de llamadas a métodos o sea por ejemplo pues es una secuencia No yo primero hce un deq y luego Así no s entonces ponen varias secuencias O sea no muchísimas no este prueben unas unas tres unas tres secuencias entonces van a van a ver si su implementación funciona la lo que de acuerdo a lo que se espera de una cola no O sea si suceden cosas raras no suceden inconsistencias es decir si por ejemplo tenemos no la secuencia de nqa enq y deq
(1:41:19) y al final resulta que no se borró ninguno no O sea a pesar de que Us un deq no se borró este si es que miren en este caso en pues devuelve un buano no y y de devuelve un String Así que a fuerzas tienen que usar cabol y ron Okay es un un de fuerzas Camilo como bien dices entonces y el o sea un cal debe capturar buanos y otro Cab debe capturar strings Ajá Por ende también Future Sí sí sí y bueno Entonces este pues deben cachar vale si existen cosas extrañas no O sea y si van a pasar o sea bueno es lo es lo que yo espero que pase que que como no
(1:42:22) usan cados Pues sí va va a suceder así o hasta que se va a quedar Auro este bueno van a pasar cosas raras con los apuntadores al no usar este candados ni sincron igual o sea si les marca como un este como de No pues es que apun apunta nulo Y entonces hay un fallo no o algo así pues también no lo reportan esa es una inconsistencia aunque también sería una inconsistencia que que pues existiera este que hicieran un deq y no se elimine nada no o que hacen un enq de algo y no se puso en la cola qué onda no O sea como que esas son
(1:42:58) inconsistencias entonces tienen que que ponerme una capturada de pantalla de como miren aquí debía suceder o sea debía el resultado de la cola debía ser solo a o solo b y resulta que están los dos no a pesar de que puse un deq entonces que qué sa vea O sea eh eh Cómo sucede esta inconsistencia Bueno o sea como que el el la comprobación vale Entonces sí para analizar si hay inconsistencias hay que utilizar Future porque Future lo que nos va a permitir va a ser guardar el resultado no de de lo que es o sea bueno por
(1:43:34) ejemplo el enq Pues realmente devolvió true o este el deq si este nos devolvió No sé x y no debería devolver eso no Entonces si ocupamos Future ahora muy importante Future punto get o sea cuando cuando utilizamos fature pun get en esta línea la 40 eh se acuerdan que get en Future lo que nos hace es que nos devuelve el resultado del Future pero lo fuerza detenerse o sea entonces si nosotros imprimimos e aquí si hacemos e futures no Esto entonces forzamos a que e el ciclo por se
(1:44:41) detenga hasta que se devuelva el valor Vale entonces tengan cuidado no lo pongan aquí porque si lo si hacen el submit y luego esperan Justo a que les regrese el valor quiere decir que no eh este no van a meter en digamos que no le van a dar al executor todas las tareas o sea el executor no va a tenerlas y y va va a pasar como que se se Ejecutan de forma secuencial vale o sea si si nos detenemos a cada rato por el valor quiere decir que no le vamos a pasar otra hasta que tengamos el resultado y no se van a ejecutar de forma
(1:45:19) concurrente Así que no podemos meter este el get aquí vale o sea como que en el mismo for del submit no puede ser por eso yo por eso Se imprime acá si tiene si tiene su razón Vale entonces así les toca O sea que futures esperas obtener el valor Ajá Exacto sí Sebastián s espera se detiene sí O sea no como siempre devuelve este o sea ahora sí que get devuelve siempre eh el tipo del Future y no no puede ser nulo Entonces se detiene así bueno así está diseñado Vale entonces Ajá es bloqueante hacia los demás sos Exacto O sea si ponemos un get aquí o
(1:46:07) sea el el futures get este eh hacemos que sea bloqueante O sea no le vamos a pasar las tareas todas de un jalón al executor vamos a pasarle una obtenemos el resultado y le pasamos otra obtenemos el resultado y le pasamos otra entonces pues vamos a formar a nuestros hilos y pues no no va a ser muy concurrente no O sea no sí Exacto al final deben imprimir los futures los imprimen antes pues siempre Al contrario van a suceder cosas buenas no se va a ejecutar de forma secuencial Vale entonces ese es este la la col Ah Ah bueno Sí entonces ya
(1:46:50) finalmente contestan la la tres que pues deben decir si existen Data o este ya bueno deben decir si existen Data rises o ris conditions y este y explicar En qué variables Y por qué suceden Vale entonces eh Por ejemplo dónde existirían No pues probablemente Cuando se quiere agregar al siguiente Ah Es este por ejemplo el nodo anterior no el nodo anterior este que es al que apunta Tail pues es uno no Entonces tú quieres cambiar esa ese apuntador que apunte a ti no entonces Ah bueno haces igual al nuevo nudo no pero probablemente haya algún
(1:47:48) otro hilo que quiera hacer lo mismo porque pues todos nos queremos meter después no Entonces tal vez bueno Y bueno si más bien Ahí va a exir una Data Race dice zuriel por eso sería mejor irlos almacenando de una lista no y al final solo devolvemos los valores de la lista de futures Ajá Exacto Sí por eso los almacenamos en una lista si es la razón de que no los imprimamos ahí sí sí entonces bueno la tres es así como Pues teórica no que analicen en su programa qué está sucediendo luego la cuatro este van a utilizar candados eh Y o sincronize o
(1:48:34) sea pueden utilizarlo con sincronize lo que quieran vale en los métodos Pues en que y deq eh Y los deben hacer una una sola sección crítica o sea utilizan sincronizan los dos o utilizan lock el mismo candado en ambos y y pues ya bueno analizar si existen inconsistencias en ese o sea en nuestra Cola y pues lo esperado es que no no O sea si si los metemos en Sección crítica se ejecuta eso de forma secuencial y no debería no pero bueno o sea deben deben ver O sea que realmente no no existan y bueno la cinco es eh que ustedes
(1:49:14) eh Como que bueno analicen Y también pueden buscar No si en una pool de hilos si O sea qué pasa No si utilizamos más hilos qui decir que existe un mayor TR O sea que eh que las las targas hacen o sea como de forma cada vez más rápida no sea si en vez de utilizar 10 utilizamos 20 o 100 resolvemos este o bueno sea como el Es que este permitimos que entren más eh tareas y que en esa bueno sea como que entre más entre entre más tareas haya más rápido resolvemos vale eso equivale como el Pero bueno ya si no ustedes lo buscan bien la
(1:50:01) definición Pero bueno se refiere a eso como al perform si realmente como por ejemplo no s mi comp tiene cu hilos No si utilizo cu hilos este va con esta rapidez bueno puedo despachar las 10 tareas que puse no en cierto tiempo entonces hizo no sé 20 hilos voy a poderlo hacer No sé al doble no al triple es como la pregunta vale o sea si realmente que nuestra pool utilicemos más hilos realmente equivale a un mayor entonces bueno argumentar por digo se lo pueden buscar como ver como qué se dice no de los hilos y bueno lo esperado
(1:50:49) es que que encuentren no que en realidad depende de nuestro sistema aj a simple vista parece que sí no pero bueno depende de nuestro sistema y de la cantidad de Tas Eh sí O sea de la cantidad de hilos no muchas veces si nuestro sistema es de cuatro y le ponemos 10 Pues no va a ser más rápido No porque solo tenemos cuatro hos reales Así que simplemente se crean como 10 hilos virtuales y esos cuatro hilos que tenemos Pues de repente van a funcionar este o sea como que van a personificar no a los otros hilos O sea no son nuevos
(1:51:26) no son distintos entonces bueno esa es la 5 y ya las 6 es este es este problema no supón que perteneces a un equipo de trabajo y tú das acceso se eres aquí el el este pues no sé cómo se diga esto pero bueno er es el encargado del servidor entonces eh Tú tienes trabajas tú con seis personas y todos te pueden mandar tareas y Todos quieren utilizar pues tiempo del servidor no ocupan ocupan ejecutarlas ahí pero tú eh pues tienes la instrucción de aceptar una tarea por integrante administrador Exacto Sí gracias Dani s administrador
(1:52:11) entonces tien la instrucción de aceptar una tarea por integrante y no puedes dar acceso a más de tres al mismo tiempo entonces eh diseña e implementa una solución bueno entonces eh yo aquí les puse el programa scheduler no y el de tarea vale Entonces qué Vamos a utilizar para resolver este problema eh vamos a utilizar un semáforo y un candadito Entonces el scheduler por ejemplo lo que va a hacer es que va a ejecutar por ejemplo Bueno aquí le puse yo 26 tareas no pero le pueden poner lo que más o menos no un poquito más
(1:52:56) entonces ejecuta este 26 tareas entonces las tareas están aquí son son un rable Entonces es tenemos el tiempo de la tarea y Pues digamos que el número de tarea Entonces digamos que hay tareas que que este bueno digamos que puse seis seis como que personifica a los seis integrantes Vale entonces la tarea e son este cada integrante obtiene su ID Vale y su ID es único y le puse módulo se porque qué creen que los ids van como de 21 22 23 24 entonces para que realmente sean del un al se Perdón del 0 al un del C al se
(1:54:01) más bien entonces los ID van del C al 6 Vale entonces el integrante integrante 0 y 2 tarda nanosegundos vale el integrante uno tarda 2000 nanosegundos y los demás tardan 3000 nanosegundos Vale entonces eh este tarda el integrante uno y entonces los integrantes este TR cu y c C al entonces este y es el tiempo que se van a dormir vale o sea como que el tiempo que van a tardar eso representa que están haciendo algo entonces e La pregunta es No si esto es lo que tarda cada uno no así se
(1:55:06) ven las tareas de cada uno cómo le hacemos para que realmente solo le demos acceso a tres al mismo tiempo y que además este solamente podemos darle acceso a uno a la vez O sea no puede ser que que le demos acceso a tres y que uno solo esté ejecutando dos tareas vale o que tenga ocupado el semáforo con candados Ajá Exacto yo aquí les puse eh o sea lo que tienen que hacer es pensar a bueno analizar Cómo cómo utilizamos el semáforo Y cómo utilizamos los candados o sea el candadito para que realmente suceda de esta forma vale es como lo que lo que
(1:55:53) tienen que hacer pero ya son las 4 como un candado dentro del semáforo Ajá Exacto Sí sí sí entonces a ver ya no me da tiempo pero bueno es unito y yao la siguiente clase la siguiente s les doy clase y vemos no al final ya có hacerlo pero como que quiero que quede Mejor ahorita para que este Pero dónde la escribo dejen esper tantito el tiempo y si no lo dejo hay grabado vale Y este compartir Okay cómo
(1:56:59) va simplemente así Este Entonces tenemos la instrucción de Son seis personas no entonces aceptamos una tarea por integrante y solo tres al mismo tiempo Vale entonces qué quiere decir que digamos que tenemos un semáforo aquí no y nuestra sección crítica no entonces puede haber solamente tres monitos no sé el uno el tres el un el dos y el cco vale Y mientras los demás pues están aquí tratando de entrar no por ejemplo el tres y el cu eh No sé y el cero no están aquí tratando de entrar pero Además queremos tenemos una restricción
(1:57:46) más que es que este que que es que solo queremos que uno a la vez eh Bueno solo aceptar una tarea de cada uno a la vez vale o sea no podemos tener no sé repetido aquí el dos no O sea que el dos tenga Ah doble tarea en el en la sección crítica que es nuestro server no no queremos esto Entonces cómo vamos a utilizar eh o sea como que nos suena no hay que utilizar un candado Entonces todavía no tenemos que ponerle aquí un lock un lock del hilo cero del hilo uno no del hilo dos de todos los hilos no entonces cada hilo debe tener un solo candadito para
(1:58:41) que sus tareas se formen y además una vez que que que tienes tu candado pasas al semáforo vale para que no puedas hacer mil tareas al mismo tiempo entonces este una vez que tú ganaste tu candad uno eh pasas al semáforo y este y tomas tu sección crítica vale se vería así sí O sea digamos que es más bien un semáforo dentro de un candado dentro de cinco candados no O sea de cada uno vale se vería de esa forma Sí porque si metemos los dentro del semáforo Pues más bien ahí ya ganó No ya ganó el que tiene el semáforo es
(1:59:27) al revés como detenerlo antes de que llegue al semáforo Vale entonces este más o menos Bueno ya tengo más poquitos a se parece modificamos ambos el de tarea sí lo tienen que modificar Pues digamos que solo se modifica tarea no se modifica el el este no se modifica el skeder vale o sea como que no hay necesidad solo la tarea y solo hay que ver sabemos no que semáforo tiene este adire o sea se toma noire y rel vale es tomar el semáforo y dejarlo Okay entonces es lo único distinto en
(2:00:30) comparación a un candadito Okay entonces nada más sería así entonces hay que ver No por ejemplo dónde ponemos eh Ajá sí por ejemplo hay que ver aquí donde ponemos No simplemente el este por ejemplo es el lock no comentas esta y esta y por ejemplo Dónde pongo el log no en log punto log eh lo dejo No acá creo que Ah por ejemplo no cómo le hago lo pongo
(2:01:47) ahí y luego el semáforo dónde lo pongo no no sé acá semáforo ahí voy a poner y acá no s vale eso es como la pregunta Ah bueno es muy importante no el que nos devuelven excepciones Así que las tenemos que poner dentro de un trch pero es la pregunta vale dónde lo ponemos Quién va primero O se el semáforo va dentro del log no o el semáforo va antes del loog Cómo utilizamos esto ves como más o menos lo tienen que responder dice aquí otra eh podemos cambiar firmas de métodos firmas como firmas Ah formas las formas de los métodos
(2:02:52) que reciben Ok te refieres al de la cola o este ah si podemos cambiar los parámetros que reciben Ah por supuesto para pasarlo ahale Por eso hay hay que Modificar el sker Entonces porque el semáforo lo creo acá no s si tienes razón también modif per es lo mínimo arle no el semáforo vale vale sí Entonces sí Habría que ver no cómo se resuelve esto y ya finalmente hay que probar que funciona bien Sí Exacto sí O sea que realmente eh tenemos tres a la vez okay Y que solamente puede pasar uno a la vez no entonces Bueno después hay que responder
(2:03:53) solo estas dos preguntitas si tu implementación cumple con justicia y si no es así cómo la podemos garantizar Okay cómo cumpliría con justicia no O sea como una forma de verlo ahí justamente no es en ejecución ver si el reentrante el reentrante es justo buena pregunta este no no sé Ah mira es un parámetro si lo puedes poner si es un parámetro aj Mira pues entonces así preguntar no si así como está cumple con justicia vale
(2:04:56) Ajá dice Entonces si no lo ponemos que sea justo es válida la solución Ajá sí Exacto sí O sea no tiene por qué ser justo no no les estoy pidiendo justicia solo como analizar como Bueno mi implementación es justa Ya pues por ejemplo Camila podría decir No pues este como como rentrant ni siquiera es justo no y el semáforo no es justo Entonces pues no no es No y la implementación se ve claramente que siempre pasa más el hilo uno no los hilos que su tarea es más rápida los el cero Y el dos pasan más no Ajá y este y bueno si y como Pues no va a ser
(2:05:37) así hay que describir como la garantizamos no Ajá Y si se podría porque pues si estos tardan siempre mucho menos pues casi siempre van a pedir el candado antes no van a van a van a tratar no de adquirirlo Siempre antes tal vez ganen siempre o sea pasen más no su tarea su tarea este es más lenta es más rápida Okay entonces eso es eso sería la práctica vale es como realizar una implementación la de la cola y esta otra en realidad son como dos no y ya de ahí nada más son modificaciones muy sencillitas la de ponerle sincronize y esta siento que se
(2:06:26) resuelve así no se tarda nada en realidad ya que piensa en la solución no se tardan nada lo difícil siento que es como ver cómo lo Cómo se acomoda Okay entonces eso sería todo y nos vemos el el jueves este entro al discord vale Bueno les aviso que entro al discord para por si alguien quiere meterse a un lounge y y preguntarme vale nos vemos nos vemos mañana que tengan bonita tarde Gracias
