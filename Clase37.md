2024 09 20 10 04 17 - YouTube
https://www.youtube.com/watch?v=E6QHbBAGhLk

Transcript:
(00:02) este un pequeño paréntesis ven que les había comentado que en el discord les había comentado ayer cómo tenían que hacer el ejercicio un este bueno comparto pantalla a ver recording
(01:22) progress Entonces les había comentado que utilizaran el pseudocódigo de Ah Disculpa Camilo aquí estoy mostrando tu código pero este Bueno pues es el seudocódigo de Double peterson no entonces este aquí está qu Qué es peterson haces pones tres logs e este ves tienes cuatro hilos Así que a los que tienen el ID módulo 40 y 1 los metes que compitan por el loog uno y a los otros los pones a competir por el loog dos y luego el ganador de estos se va a enfrentar en el loog 3 no es lo que había que hacer en el sí Camila disculpa
(02:12) entonces Bueno eso es este para tomar el candado no en Double peterson y luego para dejarlo pues dejas primero el lock 3 luego el lock un y el lock 2 no Y entonces toman tres instancias del código que les pasé que es peterson que es este de acá entonces [Música] este eem bueno concéntrense en el código tengo garabatos pero bueno entonces les había pasado este código pues nada más O sea en realidad el candado funciona bien solito para dos hilos no pero este pues s Camilo fue el primero en darse cuenta que si lo uní así tal cual así tal cual
(02:59) tal cual pues a veces le contaba extraño Entonces este pues ya analizando nos dimos cuenta que este que por ejemplo en su compu él tiene los ids así los ID de los hilos o sea así vienen los TR ID este tiene el 19 el 20 el 21 y el 22 no Entonces digamos que cuando pone a competir a los hilos por el candado un los que entran a competir por este son el el 19 y el 22 y los que entran a competir por el log 2 son el hilo 20 y el 21 cuando se hace el módulo 4 o sea pues en módulo 4 así así se dividen los hilos pero sorpresa no cuando a veces gana el
(03:53) hilo este el hilo 19 y el 21 parece pero es así entonces puede ser que ganen estos dos o sea puede ser que el hilo 19 gane en el log 1 y el hilo 21 en el log 2 no entonces se van a enfrentar en el log 3 y en el log 3 resulta que como peterson en la implementación que les pasé hace módulo dos Pues resulta que en el módulo dos este ambos el 21 tienen el índice uno entonces ahí pues surge el problema no Entonces este pues en realidad teóricamente se es así como las cosas no teoría la práctica de forma teórica el programa es correcto
(04:40) no peterson es correcto Y dou peterson pues también no O sea si peterson cumple Por qué dou peterson no cumpliría exclusión mutua pero pues bueno Aquí el problema no de Pues de llevarlo a la práctica entonces este hay que modificar peterson para que quede o bueno se en realidad pueden hacer o sea ya entendiendo el problema no ustedes podrían tener varias soluciones a m una solución así que se me ocurrió no este sencilla para no mover el código es este pues conservar los módulos el módulo 4 tanto en Double peterson como
(05:19) en peterson entonces para ello lo que yo les recomendé pues es en peterson hagan de cuenta que pues tienen que hacer el Double peterson como está Vale o sea es el seudocódigo así este lo deben tomar pero en el peterson además de las banderas de flag este cero y un no de índice 0 y un hay que agregar otras dos más para que siempre tengamos módulo cuatro Vale entonces este agregas la bandera no de dos y de tres y bueno obviamente Aquí también en vez de dos le ponemos cuatro y Big pues mejor la inicializando en menos un no
(05:58) para que no sucedan cosas raras entonces este aquí igual no en vez de poner módulo dos ponemos módulo cuatro y entonces esta pues ya no lo ocupamos no eh la la J de peterson estas dos la línea seis y siete siguen igualitas Y entonces nada más en la línea ocho que hay que cambiar en vez de poner de checar solamente la bandera J no O sea la la del otro pues hay que checar la de los otros no la realidad es que a peterson siempre van a entrar Solo dos hilos pero pues no sabemos si entraron los hilos el cer y un no o el
(06:38) uno y el tres o el uno y el dos o sea no sabemos como quién de estos quién de este par no O sea solamente entraron dos no pero no sabemos cuál de estas banderas pues entró entonces este en la línea ocho aquí va a cambiar un poquito en vez de checar la la la flag este con el índice J hay que aj Sí ándale sí Sebastián si entran dos al mismo tiempo pues va a haber dos en fals y dos en true no pero siempre va a haber una sola víctima entonces hay que checar todas las banderas no Y como no sabemos Quién es el índice que entró
(07:16) pues hay que usar módulos Entonces en las banderas pues checamos No si por ejemplo si si mides el id3 pues este si le sumo uno módulo cuatro pues va a ser flag cero no este si le sumo dos módulo cuatro pues va a ser la flag uno y si le sumo tres módulo cuatro va a ser la flag dos no entonces así ya con eso o sea no importa qué ide tengas siempre esta línea te va a permitir eh verificar las otras banderas Vale entonces este o sea es lo que tenemos que hacer o sea Bueno a mí se me ocurr eso otra cosa Este eh Y bueno y de
(07:58) hecho a uno de sus compañeros pues ya le salió perfecto este con este tip no eh Pero bueno otra forma pues es no sé me imagino en peterson en el lock pues agregar como el ID por ejemplo no que entren desde antes o sea que desde aquí digamos eh si el ganador de lock 1 le asignamos el ID cer y el ganador de log 2 le asignamos el id1 y así entren a log 3 o sea podríamos hacer algo así no pero como que habría que modificar la entrada a peterson este o sea ponerle un argumento del ID y y bueno eso como que te modifica un poco más el problema
(08:41) Entonces yo pensé como que esta es la más sencilla mover peterson Pero pues en realidad pueden este mover Double peterson también pero bueno entonces es por eso les comentaba este que tenían que hacer esta modificación aj hay que sí o s hay que hacer dou peterson vale Ah vale Qué bueno Sebastián s Que bueno hay que hacer peterson porque el que me mandaste parece un filter Pero no nombras por víctimas no entonces pasan varios a la vez Entonces pequeño cler Aquí vos acá Okay entonces este Bueno y qué tal no sea como siento que de la práctica
(09:39) tres Ay como que esto Estuvo un poquito como O sea no fue tan trivial no O sea como de hacerlo y este había que acoplarlo pero siento que los otros están sencillos no o sea los otros ejercicios pues este siguen la implementación como que no hubo tanto problema Ajá sí sí sí este cómo qued sería el While así este digamos que hay que checar eh los módulos no digamos que checas la entrada I + 1 módulo 4 bueno Obviamente con paréntesis no luego la i + 2 La y + 3 en flash no digamos que así va el gu y se tiene que cumplir alguna no por
(10:31) por y así esor sí este y con que se cumpla alguna de estas ya con eso no digamos que alguna Además del victim aj Además del victim Ah y ya esto todo y luego le ponemos un an vitim y no ahí sí y todo esto es el W Sí pero bueno todo esto entra en honor con que alguna de estas se cumpla y que yo sea la víctima di sebasti que se le hizo más fácil que el anterior yo siento que ot estuvo muy fácil pero esta se me hizo Yo pensé que esta se les iba hacer poquito más difícil no
(11:36) ya haciendo sus candaditos ustedes y no usándolos de Java e Pero bueno son candaditos sencillos no O sea no son muy escalables no son que se usan en la práctica No este Pero bueno s porque acercan dados Así que sean escalables que que este sean eficientes No sí es otro rollo ocupamos ya primitivas lo que les comento como la última La verdad la última implementación pues como que es una generalización de Bakery pero siento que no es muy eficiente Este pero ya en la práctica cu vamos a ver este no no vamos a hacerlas no porque digo esto es
(12:14) muy complicado pero vamos a ver implementaciones de candados que si se usan en la práctica este Pero bueno en distintas configuraciones Pero bueno ya para aquí sigo hablando a mí se me hizo más difícil esta que la anterior Ay qué bueno sí Si lo importante es que la O sea que sí la hagan no O sea que que la acaben Sí que bueno pero este no s estuvo divertida no Bueno e y ahora sí este qué habíamos visto en la clase anterior eh los snapshots atómicos obstruction fro Eh bueno una implementación de un Snap atómico que
(12:57) que cumple con tener Esa condición de Progreso eh Por qué obstruction free Porque e tiene un método obstruction free Okay entonces si se dan cuenta en como que en el mundo concurrente cuando les dicen eh Hola creé una implementación de no sé de un snapshot que es Wi free Ah pues si es we free quiere decir que todos sus métodos son we fre Eh entonces aquí nos dicen que es free porque al menos un método lo es o sea un método es weight free el update pero no se va a llamar Snapchat weight free se va a llamar como digamos que
(13:40) como la la condición de Progreso más e más débil Vale entonces por qué Por qué el método update era weit free Pues porque todos los hilos pueden acabar en un número finito de pasos al ejecutar el update por porque solo como solo modifican su registro pues no depende de nadie no O sea yo lo me registro No me tardo lo que yo quiera y ya eventualmente la línea 14 este se va a reflejar el punto de linealización creo que está acá no hasta acá en la línea 14 Ah sí la línea 14 es el punto de linealización es decir que es el punto cuando este se
(14:26) refleja que pues unilo hizo un update no Mientras haciendo esto nadie se va a dar cuenta que ese hilo está haciendo algo eh Entonces el método pues es weight free y es linealiza luego el método scan habíamos visto que que es obstruction free Por qué Porque puede ser que como todo el tiempo o sea solamente va a acabar si si dos collects que haya tomado O sea si dos copias se acuerdan el collect pues es nada más literal regresar como en un for no leer en un for todos los registros entonces va a acabar si el resultado no de las copias
(15:08) que obtuvo con el collect son iguales con que dos sean iguales y acaba no entonces este aquí yo les había puesto una una este un ejemplo No que cómo podría ser bueno pues que siempre eh al tomar la nueva pues notas que hay algo distinto no O sea siempre notas que hay algo distinto y luego Esta bueno esta nota que esta Se movió no O siempre hay algo distinto entonces finalmente aquí pues este cuando vuelva a a tomar otra otra copia se va a dar cuenta no que pues ahora sí ya nadie Se movió y va a acabar Entonces por qué es obstruction
(15:46) free porque el scan va a acabar siempre que vaya solo y si no va solo pues puede ser que no acabe No si alguien si se están moviendo todo el tiempo updates este entonces eh el punto de linealización de este método scan es la línea 28 porque qué pues es la que va a determinar si ya acabamos no y nos vamos o sea regresamos el resultado ya de la última copia o si no hemos acabado y volvemos a a regresar y a regresar no entonces eh este bueno y teníamos aquí los casos yo les habíamos visto Este primer caso que pues es cuando
(16:34) e la vista V Pues contendrá el último update claro no O sea si si aquí por acá Tenemos un montón de updates este scan debe tener la última actualización de cada de cada este pues este registro en este arreglo no debe tenerlas Ah me había quedado el caso dos el caso dos nos dice que que que un scan cuando se traslapa con un update la vista puede contener o no a a y será correcto bajo la al elizabad Ah creo que ese también lo habíamos visto no les había comentado que que por ejemplo este scan dependiendo dónde se haga la línea
(17:21) 28 o sea cómo cómo se haga el Old la old copy y la New copy este dependiendo puede contener a o no por qué Porque puede ser que a Pues aquí por fin este sea la línea 14 y puede ser que el scan este pues no se hizo aquí la All copy acá la New copy resultaron iguales Y entonces solo va a tener solo va a tener a a no puede ser aunque también podría ser eh Ese es un escenario Déjenme Bueno mejor sin nada y ahita le regreso para poner otros ejemplos no de qué podría pasar de Por qué s es laliz
(18:28) esto entonces Este es un ejemplo aquí así lo había puesto Entonces otro ejemplo [Música] sería esta de acá eh es es un ejemplo en el que este eh a es en B1 no y b no está en B1 Por qué Porque supongamos que B sucedió por acá no y ya c pues no no lo regresó eh otro ejemplo podría ser que que que B suceda aquí o sea la línea 14 no sé sucedió Aquí bien rápido No y podría ser que que que este no sé la All copy se hizo aquí imagínense que la New copy se hizo acá no entonces claramente va a ver que que pues se movió el hilo B no
(19:26) este eh Y no supongamos que después este este aquí escribe bueno supongamos que vio que se movieron los dos vale que se movió este B pero que también se movió a no en este punto entonces en la New copy pues está en a y b entonces Este sí pudo haber pasado que en este caso eh a y b estarán en B1 es otro caso otro caso podría ser o sea digo son las cosas que pueden pasar dado del código no O sea dependiendo dónde se haga la línea 14 puede ser que que estén o no estén pero ojo siempre este siempre siempre que un valor esté
(20:16) en un scan es porque el update se hizo concurrente o sucedió antes no siempre siempre o sea no va no va a ser que que no ha sucedido no O sea y por fin no esté otra puede ser que la línea 14 de este imagínense no la línea 14 14 aquí y está acá y supongamos que ay no s azares del destino no se pasan así copy cy sea y resulta que y la Ne copi solo vieron a este no O sea se hicieron así p pup enseguida y no tienen a este o sea como que no no vieron esto no esto sucedió justo antes Entonces al final puede ser que a no esté en B1 y b sí esté en
(21:20) B1 vale Pero por qué puede pasar esto por qué por qué Sí podría ser que que a no es y b s porque a y b son concurrentes o sea estos updates de a y de B son concurrentes o sea Tenemos aquí como escenarios vale o sea si se traslapan dos updates y además estos traslapan con un sc sucede esto Claro que si si los updates No se traslapan si sucediera algo como en vez de esto que sucediera algo fuera update y el scan ahí me fedo escribir bueno escan regresa a V no y hacemos el update de a por ejemplo y el update de B Entonces si sucede de esta forma y
(22:15) esto quiere decir que tienen un orden de precedencia no puede ser que e en este caso eh digamos que sucede puede ser que a y b están en v o que a está en v Este pero no puede ser que que a no est y b Sí vale por qu en este caso hay precedencia no Y si es linealiza no se puede reordenar el upate de B antes que a y el tampoco lo permite Por qué Porque si si O sea no puede ser que este vea este y no vea este no claramente o sea o sea quiere decir que este ya tuvo que estar escrito y en el código pues no tendría sentido o sea le es de de del a
(23:15) hasta d no en los collex y haces un doble no puede ser que que a no esté Vale entonces por eso es linealiza este y el caso tres Ah bueno siempre que se traslap con un scan pues la estas dos vistas se van a contener de alguna forma igual se van a poder reordenar es lo que nos dice el caso tres el caso tres Bueno aquí creo que no puse Ah sí si puse traslapes No est aquí son dos scans que se trasladan Y en este caso pues si se dan cuenta podrían ser diferentes estos dos porque podrían ser o se Se podrían contener o iguales no
(24:01) podrían ser distintos si este scan este no contiene a a c no porque este scan de aquí aquí termina quiere decir que todo lo que sucedió antes de este scan pues debe estar o sea las últimas actualizaciones pero este puede uno tener AC c no entonces simplemente podría ser que si si s Ay si c no está en b2 entonces e este b2 está contenido en B3 No pero si c sí está entonces b2 Es igualito a B3 dependiendo o sea podrían pasar estos dos escenarios Por qué Porque como ya vimos un scan que se traslapa con un update puede o no
(24:58) contener a ese update entonces así Este funciona no por eso es Line realizable ya Bueno aquí tenemos un Quiz no es correcto si c si decimos que c está en B3 y no en b2 Ah sí sí O sea que este es el c Aquí está c no entonces c se relaciona así se prede B3 no entonces La pregunta es Es correcto o sea podría pasar no el código y dado Pues también que ya analizamos que que un snapshot que este esta implementación es laliz Entonces debería cumplir con inabilidades en B3 y C y C en b2 no la
(26:06) pregunta Entonces miren digamos que sí si c está en B3 Pues sí no sí como dice Camilo este y bueno es como de a fuerzas no este la implementación Bueno voy a escribirlo con voy a poner mejor el código para que no seas el código nos asegura que c debe estar siempre en B3 no Porque e el update de c sucede antes que scan y el collect debio leerlo no O sea pues Sí obvio debe estar debe estar no puede ser que no esté pero la pregunta es puede
(27:11) ser que c no esté en b2 y como nosotros Sabemos que esta implementación es linealiza sabemos que podemos ordenar que update se haya pasado después que el esan o sea bueno este la esta línea de comparación no este y cuál esta de copy con New copy no all con New Entonces si esto sucedió antes pues sí puede ser que que c no esté en b2 no Por qué Porque puede ser que la All copy y la New copy sucedieron antes que se escribiera la línea 14 entonces queda bien con el código perfecto Camilo Sí luego este Ah bueno creo que es el único
(28:01) ejercicio que les puse acá pero bueno ya ya con Isabel este ven más vale Pero bueno o sea más o menos quedó como Bueno este claro puede repetir la diapositiva anterior no terminé de copiar Ah okay okay okay esta de aquí la bueno est el caso tres ah no sí esa del b2 o B3 Ah ya ya esto de acá sí sí sí okay Bueno este Ajá bueno sí déjalo Entonces lo escribo todo no e esto no eh lo que quise decir aquí es es esto que el código nos asegura que siempre va a suceder esto porque tenemos una precedencia y porque en el código
(28:56) Pues el cole qu hace el de todos los registros pues si eso se escribió antes debe estar No eso es y además como segundo punto Eh puede ser que la línea 28 del scan b2 sucedió antes que la línea 14 del update c vale en este caso entonces quiere decir que si es posible que c no esté en b2 Vale entonces estás Por qué pu en el código si se puede vale entonces esa es este y aquí lo quise representar no dibuj O sea como que pues el punto sucedió a antes
(30:01) eh que es este b2 como que es B3 dependiendo en qué momento Ajá sí sí esa es una configuración pero también como dices también podría ser que que c este en b c esté Ah bueno en B3 y también esté en b2 podría ser dependiendo qué tal que en realidad la línea 14 no pasó aquí sino pasó acá Este claramente y la Lía 28 de descanso se dio aquí lo tuvo que haber visto no Pero puede ser que Noa que sí que no Por qué Porque son concurrentes pero sí o sí este tuvo que haber estado en este Por qué sucedieron este porque
(30:44) una tienen una relación de precedencia no de primero suced update Y luego el scan de B3 vale este entonces Esta es otra nueva implementación Y es este es muy bonita muy interesante Pero bueno vamos en realidad o sea como que en el curso de cuenta que pues nos la pasamos viendo implementaciones pues gente no que ya las hizo y que las probó y todo este Pero bueno son unas en realidad Así Uy Hay un montón y dependiendo que te guste qué necesites y se han implementado de forma distinta estas implementaciones están en javas Sí este
(31:36) a les voy a pasar los códigos Es que tengo los códigos de herlich de de su libro de hecho é los hizo todos los códigos se puso a hacerlos entonces Este sí todo el todo el libro están los códigos pero luego hay unos que no jalan bien Este pero por ejemplo los spinlock los que vamos a ver la práctica cuatro Pues la verdad tomé puras implementaciones ya hechas de los Spin locks Este pero sí Se los voy a pasar se lo subo mañana porque hoy este ando ocupada pero sí se lo subo mañana Ajá sí y en realidad se han implementado
(32:16) en varios en varios lenguajes o sea estamos usando Java pero pues en realidad también se han hecho que en c más más Ay les encanta haos más eh para la concurrencia Hay un montón de gente este y siento que con como que rost Julia y así son como más nuevos Este pero como que si la gente ha estado más en Java y se más más en concurrencia pero bueno entonces esa es otra implementación este y esta sí cumple con ser weight free no Entonces si nos dicen que es weight free quiere decir que todos sus métodos son White free es
(32:53) decir si se acuerdan no que todos los hilos que ejecuten pues en este caso todos los métodos deben acabar en un número finito de pasos siempre acaban todos tenemos éxito Este Entonces el otro la otra implementación teníamos update free y scan este pues no no era Era obstruction no obstruction free ahora este pues ocupamos que esans with fre para que pues nuestra implementación est esté bien entonces este en esta implementación ahora está nueva cómo vamos a lograr que esc free Bueno pues vamos a poner a que los updates le ayuden a los scans a
(33:49) completar su llamada y cómo les van a ayudar a los scan Pues hgan de cuenta que cdate va a tomar un scan antes de modificar su registro entonces hg de cuenta que ahora va a ser vamos a tener scan no y un update va a ser un update de un valor no sé s va a tener siempre un escan antes siempre va a tener metido ahí un escan eso va a ser en esta implementación Entonces de qué forma esto le va a ayudar al scan No pues bueno tenemos dos hilitos no al a el a y el B Entonces el a va a observar va bueno va a hacer su scan y este y en el
(34:41) scan va a ver si alguien se movió dos veces si alguien se movió dos veces Entonces le va a robar el scan a ese que se movió dos veces Entonces por ejemplo no O sea el escan ahora este en el otro se acuerdan que nada más era como de copia vieja copia nueva y si no sigo y sigo No ahora en este va a tomar una Pues sí también no va a tomar una all copy y va a tomar una New copy Pero además este scan ahora se va va a analizar si alguien se movió dos veces o sea imagínense no que aquí se movió este línea 14 no este Bueno no sé
(35:24) imagínense Es que aquí ya es otra implementación mejor no no escribo las líneas no pero supongamos no que aquí sucedió el a entonces este eh cuando haga la comparación no imagínense que aquí aquí dice como de all desigual a New no Y además va a guardar va a tener aquí un arreglito no va a decir este además de Esto va a decir B Se movió una y luego luego acá va a volver a hacer otra copia no este New y y supongamos que aquí sucedió el update entonces otra vez van a preguntar Oye este bueno New igual a New 2 y y entonces dice no pues no no es no
(36:23) entonces ya este el llevaba la cuenta de que se había movido una vez el hilo B Pues ahora va a decir Ah Mira ya se movió otra vez se movió dos veces si se mueve dos veces Entonces qué voy a hacer me voy a robar la copia del último update me robo la vista de su scan y porque recordemos que los updates Aquí tienen su scam o sea Uy así scam Ay esan y también aquí no Entonces qué va a hacer se va a robar y entonces así como que se dan cuenta como que le cargamos el trabajo a los updates Pero bueno al menos los scan
(37:18) vamos a acabar en de forma wiit free no O sea no solamente si vamos solos vamos a acabar siempre entonces eh Cómo se ve Cómo se ve el código Pues si lo interesante no dicho lo interesante son los dos no está pero bueno el scan lo que va a hacer otra vez es tener una copia vieja y una nueva no entonces además como les comenté para ir contando quién se movió pues vamos a tener esta línea la línea 13 este línea 13 no Y entonces aquí vamos a ir eh es una es una es un arreglo de tamaño de nuestra de nuestro Snapchat no O sea
(38:07) Entonces tenemos aquí nosotros nuestro Snapchat este de los aable se acuerdan sea el arreglo de registros Entonces tenemos cada hilo por ejemplo no e cada vez que se va a hacer un escan no el hilo por ejemplo el hilo hilo a pues va a crear su arreglo move cada vez O sea cada vez que se haga el scan vale o sea y esto es local a cada hilo o sea el hilo a tiene su su variable move no el hilo B Pues también tiene su variable move y solamente la puede este Modificar el hilo el hilo a su propia variable mo o sea su propio
(38:58) arreglo move el hilo B también tiene su arreglo move y todos de forma local y cuando lo crean pues cada vez que van a hacer el escan vale o sea se crea y es un arreglo nuevo entonces para qué nos va a servir move pues simplemente vamos a poner este true si se movió ese hilo no Entonces este pues aquí tenemos no el hilo uno bueno supongamos que el hilo a el hilo B lo ha lo ve y también acá o sea aquí tenemos a todos los hilos entonces este así cada hilo tiene su propio su propio Entonces qué va a hacer Bueno pues la niña
(39:51) 14 Leo todos en for hago el col hago un for este y la All copy pues regresa el conjunto de de valores no que leí en el este En a Table luego en la línea 15 el collect lo que va a hacer Es que este Ah bueno es nada más la referencia no para regresar acá como en el anterior vale es una referencia aquí acá entonces entro al While y lo que me dice este es vuelve a hacer otra copia y Ahora va a ser la Ne copy no pero ahora miren para irlos este en el anterior solo nos importaba como de son iguales no O sea pues vuelve no
(40:36) no en este nos importa saber quién se movió entonces m Qué vamos a hacer vamos a ir revisando por por este por J no O sea si si la estampa se acuerdan la estampa pues es este e las veces o sea se va guardando de forma local para cada yo son las es que actualizado no Entonces digamos que lo que nos dice aquí en esta línea es si tengo si si si este si r copy tiene un valor más viejo que New copy para el hilo no sé J entonces márcalo Eh bueno acá vale te dice entonces márcalo y por ejemplo no sé supongamos que pues
(41:23) el hilo a vio que se movió el hilo B Y entonces le va a poner al hilo B no y Y entonces va a volver a haer all copy igual a New copy y regresa vale Y entonces va a seguir él no no supongamos que que como en este que les les este que les presenté no que ve se movía dos veces y ya este ya pues se robaba su su vista Bueno si imagínense que que ve se vuelve a mover [Música] Déjenme lo copio no para que no se imaginen tanto eh este lo pegamos acá Entonces como en este Vale entonces este supongamos que que aquí tenemos la
(42:21) línea en este caso sería la 14 del esan luego eh supongamos que acá sucede la línea 16 o sea termina no se de leer todos el update de a supongamos que se hace aquí este aquí se aquí lo actualiza vale Entonces digamos que la old y la New pues van a ser distintas entonces acá qué hace pues marca no dice mov B Se movió y pónganlo en true porque se movió aquí vale la línea 22 luego qué vuelve a hacer Pues toma otra toma otra entonces aquí hay New 2s Vale y este y supongamos que aquí se movió otra vez el hilo B no
(43:12) entonces en el New 2 Pues ahora va a salir que ve se volv a mover entonces va a entrar al for no y va va a andar analizando como alguien se movió alguien se movió y este y pues va a llegar no va a decir Ah mira B se volvió a mover entonces en la línea 19 vamos a comprobar si B se había movido entonces voy a ponerlo en Rosita si el hilo J bueno el hilo J en este caso no ya se había movido entonces regresa la copia este regresa el snapshot de este del hilo J en la All copy no sea digamos que que regresar la aj O sea va a regresar el de este no va
(44:17) a regresar el scan de la All cy no de la New Vale entonces este porque no se mover regresa la de Vale entonces regresa esta y esta esy punto Snap no y en esta Bueno voy a ponerle as copy de a Vale entonces lo que va a hacer al inicio tiene puros valores false aj s Sí considéralo así aunque aquí no está puesto no pero si consida lo que tiene puro
(45:20) false de seguro en el código ya se va a ver vale o sea pues an que no le pongan false este Pero bueno digo esta práctica va a ser la la cco Snapchat muy bonitos entonces Eh así funciona vale va va a regresar o sea como que va a acabar cuando este eh alguien se mueva dos veces pues me robo su Snap o sea su vista y además este o va a acabar o sea es es una opción no digamos que aquí la opción uno pues es que acabe en la línea 20 si me robé la vista de alguien o simplemente es que eh salgo de este for de este de aquí
(46:13) acá Ajá de aquí acá salgo de este for Y pues simplemente hice yo mi mi este mi scan limpio O sea no vi que nadie se movió no di más vueltas no terminé no me robé el Snap de nadie y pues este porque resultó que la All copy es igual a la New copy no está todo bien entonces este llego acá Y pues simplemente regreso el resultado entonces aquí hay como de dos opas no se acabo porque me robé la de alguien o acabo porque realmente encontré que las dos copias que tomé son iguales eh este Bueno entonces ahora aquí qué va hacer Bueno la gran
(46:58) diferencia es este no la línea tres el update ahora el update eh toma un scan no O sea toma eh También toma un escan antes y muy importante este Snap que obtenga de aquí lo va a guardar en el nuevo valor no O sea como que digamos que el el esta este valor que se está guardando en los registros ya no solo es este el Time stamp y el value ahora también y un Snap Entonces es lo mismito no de de la vez pasada eh el línea cuatro pues le es el viejo valor que tú tienes en tu propio este registro y para qué lo lees pues para aumentar el
(47:41) timestamp entonces eh hacer esto no O value stamp le aumentas uno luego pones el value que quieres este escribir y la el Snap no O sea la la vista eh ya simplemente pues lo guardas Entonces si se dan cuenta Aquí también es este la línea una línea bueno la línea importante es la línea si en donde Por fin se dan cuenta que actualicé mi valor entonces ahí también hay un punto importante no Bueno creo que ya aquí no lo pongo Ah miren s acá Está bueno entonces dejo la analizaba para después y mientras este Bueno no sé como los curiosos no se han
(48:33) de pensar o sea como que uno realmente acaba no sea realmente es weight free O sea sí acaba esto porque Bueno me imagino que han de pensar no Bueno es es como que la misma este como lógica no de regresar y regresar del continuo al colec no O sea regresas regresas todo el tiempo entonces o sea bueno no me imagino que que se han de preguntar No por qué Por qué O sea realmente acabamos no en en un tiempo finito o se si acaba esa es una y otra es este como de bueno Y por qué nos Por qué este nos robamos la vista no de un hilo que se mueve dos
(49:14) veces y no una no O no tres o así no O sea como que no sé Y ustedes como que tienen un poco de idea así como o sea se les ocurre como por qué Porque robarla dos veces y no solo una por ejemplo por ejemplo supongamos no que bueno es Quiz No si quieren participar Este Entonces tenemos aquí lo a y al B entonces supongamos que que este Qué pasaría si si hace un scan y este y y y ve acá no este hace otro vo a poner otro más para mostrar Porque si si solo se mueve una vez e de Vamos a ponerle no sé é
(50:41) pone y est tiene update vale Entonces miren qué podría pasar no supongamos que el scan que hace el hilo B lo hace voy a poner los scan en verde vale porque los update pues recordemos que tienen un scan no entonces aquí está en verde y este también no tiene que hacer un escan antes luego por fin Dónde tiene efecto la línea s no línea 7 es cuando ya vemos que escribe un valor entonces voy a ponerlo aquí 7 s vale línea S línea s Entonces qué podría pasar bueno imagínense que aquí hago la All copy la no y y acá hago la
(51:40) New Entonces si si ahí la no y luego la New este scan va a decir Oye este se movió el hilo B No pero si se dan cuenta eh el hilo c no digamos que vamos a voy a escribirlo así c ya estaba en en la old no Y también c ya estaba en la New pero este y bueno B no está en la old pero B si está en la New entonces imagínense que si solo se mueve una es no O sea en este caso eh suponiendo voy a ponerlo acá para que no nos perdamos suponer que robo snaps de hilos que se
(52:45) mueven una vez me cuesta bajar poquito así está Vale entonces si suponemos esto entonces quiere decir que el scan pues le va a robar el Snap a b robo a b entonces o sorpresa no B si se dan cuenta el Snap Snap dp no eh c no está en el Snap de B No por qué porque esta actualización se hizo antes no y este y Bueno voy a ponerlo un poquito más aquí para que se vea no la diferencia no está aquí no Entonces si analizamos aquí ay creo que
(53:52) est mu F esta p mejor hasta si analizamos esto Pues resulta que el update DC sucedió antes que el entonces podemos ver que este si me robo la vista de B pues quiere decir que este pues voy a tener a b no O sea bueno quiere decir que que por ejemplo no vamos a ponerle la vista de no que Pues en realidad es la vista robada de B resulta que que que c no está en ba no lo cual haría que no fuera linealiza porque no tenemos eh la actualización
(55:00) Eh precedente no O sea que sí pasa antes en el tiempo deberíamos tener c pero como nos robamos la vista de b y b no tiene la de C este pues no no tendrá sentido no sea el scan debe devolver todas las anteriores puede ser que no tenga B no puede ser porque son concurrentes pero en este caso sí deber tener a lac Vale entonces la idea es que eh si nos robamos la vista de esto pensando aquí si nos robamos la vista de este de alguien que se mueve dos veces nos aseguran que esta vista tuvo que ser
(56:07) concurrente lo escrib azul tuvo que ser concurrente B3 y supongamos que este es el2 y aquí asur tuvo que estar concurrente al escan al al que se o sea digamos que al ver que se mueve dos veces nos asegura que realmente el scan y el update están siendo concurrentes Entonces no pasan estas cosas porque si se dan cuenta en el update Pues hac el scan y de ahí Imagínate que uno se tarde un poquito porque ya hemos visto no cómo suceden las cosas en en la práctica si un hilo se tarda un poco este de llegar de la del tres al si pues el Snap pudo haber
(57:01) leído cosas como bien viejas en el tiempo no entonces si te robas esa vista de alguien que solo se movió una vez eh pues tenemos una vista desactualizada literal creo que está más actualizada la vista que había tomado en la old copy no en la New copy está más actualizada que que lo que vio B Vale entonces este Bueno no sé cómo cómo lo ven igual la siguiente clase pues Tom no pero sí más o menos porque no podemos solo robárselo a alguien que se movió una vez vale Bueno entonces nos vemos el el lunes no nos vemos el
(57:48) lunes Vale Nos vemos bye gracias y
