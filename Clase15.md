(61) Clase 15 2024 08 26 - YouTube
https://www.youtube.com/watch?v=yDrXyO9TDD8

Transcript:
(00:03) Hola buenos días Okay HM Bueno cómo van con su tarea no lo empieza Bueno
(01:14) pues [Música] mejor mejor pronto no para que por si tienen dudas porque bueno quedan la ayudantía del martes y jueves no o sea todavía está tiene buen tiempo todavía per mejor empezar bueno este si tienen alguna duda de la tarea Me comentan igual ya han este te han preguntado en el discord no está bien recording in progress Okay bueno el Este es el tercer tema Ya si objetos concurrentes eh entonces bueno este tema siento que es este y el del consenso son como muy pesados pero como teóricamente como que hay mucho muchos términos nuevos yo creo no
(02:14) tal vez que no han oído bueno en Sí por ejemplo del tema pasado pues tal vez no exclus mutua y de este tema vamos a ver otros otros este conceptos como weit free lock free linealiza bilidad consistencia secuencial o sea cosas así por eso les digo como que Está pesado teóricamente como que mucha mucho término pero en Sí pues siento que no está difícil bueno se estos temas se pueden complicar bastante no para hacer este papers así cosas así más pesadas Pero bueno sea como como lo vemos como introductorio siento que no
(02:54) Está pesado nada más le digo mucho mucho concepto entonces e Okay entonces bueno el tema el tema anterior pues vimos Eh Pues no más en realidad digo algunos problemas pero pues el fundamental que vimos fue exclusión mutua no y e y vimos sus soluciones entonces Bueno cómo cómo solucionamos la exclusión mutua Pues bueno implementa un obj c y vimos ahí implementación para dos hilos para para nilos no es lo que vimos el tema anterior todo el tiempo candados y bueno vimos también además que pedirlo en candado porque resolver la exclusión
(03:48) mutua yo les había comentado que era trivial la exclusión mutua dice pues que solo entre uno a este código este a este pedazo de código este bloque de código y para sol lo de forma trivial pues dices bueno que no entre nadie no O sea esa es una forma así entonces por eso están estas dos propiedades de lo free y estation free y bueno entonces nada más vimos este al final una vista no de cómo se usa Pues en realidad este problema exclusión mutua para resolver otro tipo de problemas pero les digo que hay muchos
(04:21) no sea productores y consumidores es uno muy clásico este para nosotros como como comput logos entonces la solución por ejemplo para este sería implementar un candado y Añadir una restricción Eh pues que solo se puede consumir si hay producto no y por qué ocupamos un candado porque dos productores Perdón dos consumidores no pueden consumir lo mismo no entonces ocupamos sincronización entonces bueno en el curso Siempre vamos a tener siempre les voy a estar hablando No pues el hilito el proceso así eh les digo que a veces
(05:00) los uso de forma distinta si me va eh Pero bueno ya vieron Por qué no en realidad pues pueden ser como lo mismo e Entonces siempre tendremos esto y además tendremos yo siempre les estaré hablando todo el tiempo de objetos y es un este esta esto de objetos lo vamos a ver un montón en este en este tema y bueno Buen A ver por qué entonces siempre en este tema vamos a vamos a ver qué relación existe entre ellos y bueno también vamos a ver cómo decir que un objeto es correcto Entonces qué relación existe entre los hilos y los objetos Pues bueno
(05:38) los hilos Ejecutan los métodos de los objetos no H estilo Java o sea como Sí o sea como mucho esta programación orientada a objetos no se parece un montón se teoriza de esta forma entonces eh Y bueno una ejecución no o sea los si los Ejecutan Pues esta ejecución se realiza en el tiempo y entonces lo malo o lo que nos interesa en el cómputo concurrente por lo que es difícil no es que lo Ejecutan pueden ejecutar métodos al mismo tiempo Entonces nosotros ahí es cuando hacemos un zoom en la ejecución para ver pues qué está pasando no
(06:19) e Entonces ya viéndolo así por ejemplo vemos no eh lo que vimos la toda la el tema anterior qué objeto vimos un cado no Qué es un cado pues es un objeto que permite que solo un hilo entre a una sección crítica solo un hilo a la vez y este candado qué tiene dos métodos Uno de ellos es lo que te permite entrar a la sección crítica y el otro es son lock para salir de ella no es como esta es la definición de este objeto y Y entonces es la diferencia en el libro y yo también me van a escuchar diciendo eh A veces les voy a decir
(07:02) miren vamos a hacer eh Este es un objeto de tipo candado no O Este es un objeto una cola un objeto est es una pila Este es un contador Este es un snapshot el siguiente tema vamos a ver snapchats entonces me van a escuchar decir como estos este Estos son objetos sí Y además existen implementaciones de objetos y se dan cuenta el objeto pues es como es como este eso aquí un objeto es como la descripción descripción voy escribirlo descripción teórica y y pues abstracta Vale o sea lo que esperamos una cola pues es un objeto que permite
(07:55) que los que primero entren sean los primeros que se consuman no e y tiene dos métodos en de así o sea es como esta descripción ya que implementos como se noses de la gana no como analicemos como lo que queramos es distinto entonces una implementación de un candado pues puede ser peterson puede ser Decker puede ser filter puede ser bery no de no s si lo vieron con is peroen es parece cadito igual para dos hilos e entonces estas son implementaciones vale o sea el candado pues es una o sea es una descripción abstracta Pero cómo lo
(08:38) llevamos nosotros a la práctica Pues con implementaciones Vale entonces es la diferencia lo digo porque vamos a o sea como que si siento que a veces dices Bueno o sea tengo el objeto y tengo la implementación Cuál es la diferencia no Entonces es Es okay entonces este es nuestro índice HM primero vamos a ver un ejemplo qu concurrente bloqueante entonces bueno Eh ya ya les platiqué ahorita no que es un objeto un objeto concurrente pues vamos a ponerlo así es eh un objeto eh Bueno es la descripción de Pues cómo podríamos
(09:33) decirlo no decir objeto no es la descripción de un conjunto de métodos atributos y y reglas bu como la abstracción de lo que implica un objeto vale que que puede ser ejecutado por varios hilos vale al mismo tiempo como la diferencia si se dan cuenta pues nada más como lo que cambia con los objetos que ya conocemos Pues es que o los que [Música] conocemos estructuras de datos estos Ob que hemos visto la diferencia Pues es que podemos ejecutar sus métodos este por por Bueno podemos ejecutar los
(10:38) métodos varios hilos no al mismo tiempo cómo lo implementamos eh un objeto lo podemos implementar de muchas formas existen implementaciones de un candado por ejemplo como les había comentado no peterson Bakery este depende no O sea depende A quién se le ocurra Y qué quiera y cómo argumentamos que es correcto esta Va a ser la pregunta que vamos a solucionar Eh bueno que les voy a contar no en este tema es lo lo importante Cómo cómo vamos a argumentar que un objeto es correcto por ejemplo un candado Cómo argumentamos
(11:12) que es correcto Bueno pues que cumple exclusión mutua que es deadlock free o que es starvation free si se dan cuenta es es la argumentación No pero en general Cómo argumentamos no que cualquier objeto es correcto Esa es la pregunta vale [Música] pemos en estea entonces bueno primero vamos a ver un ejemplo de una cola concurrente con candados Vale entonces ustedes Bueno tienen aquí un Quiz Cuáles son las variables compartidas en este en esta cola por ejemplo pues aquí tenemos que las variables el constructor el método enq
(12:00) Cuáles ustedes ven consideran que son items Ajá s si es una variable compartida heil aj s exacto y el candado No aj si todas estas variables compartidas y ya lo que hagan los métodos adentro de lo pues es local no local a los hilos entonces Pero bueno o sea quiere decir que todos los los este los hilos van a poder ver Head Tail yems y tienen compartir un cado Entonces cómo funciona esta implementación pues mir si esas son nuestras variables compartidas luego tenemos el constructor simplemente que se se inicializa con la capacidad ems
(13:01) Pues digamos que es como Pues un arreglito una lista no un arreglo este pues de la capacidad vale dees de la cola luego inalamos en cero y y inicializa nuestro como un Loc reentrante ahorita este este lo reentrante pues es un tipo de lo tiene que tiene Java e y me tienen que creer no que lo que hace es que Eh pues características del Loc reentrante es que eh voy a ponerlo con este soporta que un hilo ejecute es que pienso en inglés no execute ejecute este el
(14:08) el dos o más lock métodos lock o bl o sea como que tienes el candado y no le importa que vuelvas a pedir el mismo candado vale es como lo que me tiene que creer ahorita cómo funciona rear en la sección cuando veamos monitores sa ver cómo crear uno pero bueno mientras este pues es es un tipo de candado que ya tiene Java no que pues lo que nos gusta o sea por lo que se usa es porque eh si alguien ejecuta dos veces o más locosa seguido sin dejar el candado no se bloquea todo bien e entonces bueno eh se inicializa de
(14:50) esta forma luego Existen los dos métodos en q y de que eh Porque pues es una cola no entonces e antes o para digamos que para ejecutar todo lo que está dentro del método enq se toma el candado o sea lock no lock y luego se hace un lock al final Entonces digamos que todo lo que está aquí será una sección crítica vale Y este muy interesante el candado sea se toma cont TR Finally Okay Por qué Porque e digamos que pues se intenta no ejecutar todo lo que está dentro de la sección crítica y si no se logra siempre siempre
(15:37) tienes que dejar el C para que pues no te lo quedes no O sea ya sabemos que en Java Pues luego se avientan este excepciones no O sea lo que sea que pase aquí siempre siempre siempre deja el candado es lo único que dice vale o sea por lo que se pone siempre en TR final entonces así funciona no esta parte de e la los ems se ven como de esta forma dme cuenta que este es el arreglito pues es como una cola así normal no arregl de ems de cero hasta la capacidad no que es que es esta entonces inicialmente Tail y Head
(16:25) apuntan a a este a cero no O sea bueno Están en cero y qué qué se va haciendo si bueno se se Checa No si Tail este y Head No es igual al tamaño O sea la diferencia es igual al tamaño de de los ems O sea a la capacidad máxima pues avientas una excepción no de que está Leno y si no lo que haces es que vas a meter este el siguiente digamos que tu tu x no O sea lo que quieres encolar lo vas a meter justo en Tail módulo el número de items que tiene esta cola Vale y aumentas Tail Entonces por ejemplo cómo va va avanzando como que pues se van moviendo
(17:14) de esta forma por ejemplo aquí puse no O sea e si quieres agregar uno pues simplemente en este caso como la cola está vacía pues es módulo cero no bueno pensemos como que se puede hacer esto ya ven que cero Pues algo módulo cero no se fue pero supongamos no que es como que pues este como es aud cdigo aquí supongamos que entonces se mete donde está ta Entonces es x entonces aquí metes la x y simplemente se aumenta ta entonces va hacia acá la punta aquí no a un se queda ahí y así entonces se va aumentando si se van
(17:58) llenando así Si siguen haciendo en pues simplemente aumenta no y luego por ejemplo para borrar algo pues es el que se mueve por ejemplo aquí igual el método enq funciona también de esta forma tenemos un lock un unlock entonces todo lo que esté aquí pues es la sección crítica CR se ig Entonces si es así pues lanzas una excepción está vacía la cola y si no pues entonces este regresas el ítem el primerito en este caso por ejemplo regresarías x por ejemplo aquí regresarías x y simplemente aumentas O sea no borras el em que está y simplemente como
(18:58) que se va ir so por ejemplo haces esto y ahora consideras que lo que tiene tu cola pues es nada más y y z y ya pues x no lo considera entonces van a ir siempre get va a ir eh siempre Head va a ir antes no que que Tail he siempre va a tener un un este número menor entonces van a ir avanzando no Entonces por ejemplo aquí pues puede ser que G está acá y Tail acá entonces lo que sí no va a pasar es que Head sea mayor a no porque pues tenemos eh tanto la excepción no de que está vacía Entonces no puedes quitar nada O sea no
(19:41) puedes avanzar a no o también no puedes este si está llena no puedes hacer que Tail avance más que vale como que no estamos dando vueltas ahí enem con este módulo así así funciona esta implementación de una cola entonces Bueno si se dan cuenta eh una un ejemplo de cómo de una ejecución de de esta implementación de una cola sería se podría ver de esta forma tenemos por ejemplo los hilos A B y C Vale entonces eh En realidad las líneas eh donde se toma el candado Pues en realidad son todo un pues eh Pues todo un intervalo
(20:27) no entonces qu Va qué va a suceder por ejemplo en este caso casi que empiezan a hacer la este a ejecutar el método al mismo tiempo no pero el que logra terminar primero de ejecutar el método lo en este caso c ya vieron entonces aquí c lo que hace pues es que ejecuta su critical section que en este caso está haciendo un dq no es como una critical section es esta y esta es otra critical section vale entonces va de aquí acá entonces aquí este se ejecuta su sección crítica y deja el candado no entonces mientras estos dos ve estn o
(21:17) sea pues ambos quieren ejecutar algo no O sea dos quier ejecutar Este pero pues el que Gan el candado es el que lo va poder Entonces por ejemplo aquí B es el que termina después de ejecutar el candado y pues aquí no toma otra critical section y hace un nq deb y hasta que no lo deja es que alguien más puede puede realmente tomar el candado Vale entonces por ejemplo aquí pues él lo toma Ah lo toma y pues por fin aquí él puede ejecutarlo y y este y en este caso por ejemplo se quiere volver a a pasar Entonces este ya
(21:58) vieron que enseguida hace un lock no O sea te quiere tomar el candado otra vez y hasta acá lra otra sección crítica entonces lo que nos permite pues utilizar logs es que los formamos Pues como secuencialmente ya vieron Ah dice suriel Por qué se hizo de que primero y no en que Ah o sea bueno porque digamos que este es una situación así como aleatoria no O sea en realidad si te das cuenta pues los hilos pueden eh este ejecutar tanto enq como deq como quieran no entonces pues pudo ejecutar un enq o pudo ejecutar deq no sea lo que
(22:39) lo que él quisiera y en realidad como es una cola concurrente pues no es como a dice Por qué pasó Primero c y no a Ah porque eso depende no Qué tipo de candado tengamos por ejemplo nos acordamos de de dado por ejemplo filter no en filter ya habíamos visto que puede ser que un hilo empiece antes no Y en este caso imagínense No pues aquí empieza antes realmente pero c es más rápido y se nombra víctima este antes que de algún nivel le gana no O sea por ejemplo o sea como que es así no es no es no es como algo rígido no pero
(23:26) entonces items ya tenía objetos cuando empieza eón no en este caso no por ejemplo Si considera no que la cola estaba vacía este bueno es que miren aquí hacen un deq pero pues lo que se regresa es vacío no entonces la cola hay que ponerlo aquí vale para que lo veamos este la cola está vacía Ah sí no hab visto pero entonces Ajá sí sí sí sí es que bueno Yo casi siempre escribo las cosas así No pero en el libro luego les gusta escribirlas como que esto es lo que regreso no pero bueno consideren esto que es lo mismo va o sea como que lo que
(24:31) ejecutas al final regresas que es como lo mismito va Ajá Entonces se ejecuta la col está vacía entonces pues sí tiene sentido no se obtiene luego B en en cola B luego a en cola a y luego c hace otro es otro deq y ahora en cola pues lo primero que es en Colón no que tiene sentido o sea en cola b y es lo que como que quería como que apreciamos no cuando usamos candados hacemos que las cosas o sea que las secciones críticas pues se Ejecutan de forma secuencial entonces eh Como utilizamos un solo candado para encolar y desencolar pues este algoritmo
(25:15) en realidad no O sea funciona como secuencial o sea si analizamos esta línea de cosas que pasaron en la cola nos vamos a dar cuenta que que se pueden formar de forma secuencial no entonces bueno para analizar la corrección si se dan cuenta Bueno es lo que como que quería que viéramos primero que si analizamos la corrección de esta cola como se forman secuencial o sea en el tiempo o sea lo que lo que sucede en la cola como que es fácil de analizar no O sea ustedes Ven aquí o sea solo nos concentramos solamente en esta y decimos
(25:53) Bueno o sea se hace de qm en qb en q y ve al final pues es correcto no se es una cola realmente que cumple con fifo ent Bueno yo aquí les pongo No si o sea hay que analizar Cómo se traslapan las operaciones Pues sí pero aquí como que no se traslapan mucho en la cola no O sea en los lock Pues sí no pero lo que nos permite Pues es que al final este estos intervalos pasen seguiditos no O sea bueno de forma secuencial entonces bueno este cómo se ocurre lograr más concurrencia no O sea aquí tenemos un solo candadito
(26:33) compartido entonces cada vez que tú quieres hacer algo pues lo tomas no es como ponerle sincron Entonces cómo se les ocurre a ustedes que podríamos lograr más concurrencia como no sé o sea ideas Así que se les ocurre como que hay mucha concurrencia no O sea bueno Se forman en la cola no se les ocurre Bueno Este es noo usaron Bueno entonces este qu me van entendiendo verdad ni idea Bueno este un una cosa para lograr más
(27:37) concurrencia bueno Gracias es este es por ejemplo qué podríamos hacer qué tal que en vez de usar un candado usamos dos no cuando unos hacen hacen que y otros de que es que sería como ponerle concurrencia es que cómo sería Ah ya ya ya aquí un hilo cuando se encola ah Ah okay m Ah dice o sea una forma sería cuando unos hacen en que y otros de que Ajá sí O sea como poner dos candados no le ponemos un candado solo a de que y otro en que sí Fernanda por ejemplo ponerle más concurrencia a la cola a lo que me refiero si es que son una extraño
(28:17) no e ponerle más concurrencia sería permitir que se ejecuten por ejemplo en este caso se ejecuta todo de forma secuencial no O sea al final con los candados con un solo candado hacemos que todos se formen entonces si yo quiero que mi algoritmo sea más concurrente O sea que que aprovechemos más este Entonces como dice no permitiría que que este en vez como de poner un lock pues pusiéramos no sea lock uno y hago otro lock dos y entonces hago que el lock un lo tome los en que y el log 2 lo tomen los de que no Entonces al final
(29:04) podríamos permitir que se ejecuten en q y de que justo al mismo tiempo no O sea como si usamos esto podríamos permitir que suceda algo así como a b c y como este está peleando por un candado y est está peleando por otro por ejemplo este es el log un y este es el log dos Pues podría ser que ejecutemos el enq y el deq al mismo tiempo no por ejemplo o sea como y así tendríamos más concurrencia O sea como eso me refiero como permitir que las cosas se traslapen más a es es un problema Exacto hay que ver cómo hacemos esto
(29:49) porque si por ejemplo alguien está encando algo no y alguien justamente está borrando algo qué tal que no lo encola justo al final no O sea lo encola después O lo encola antes y entonces ahí ya no se cumple fifo Ajá o sea como que tiene su chiste no y y la otra sería o sea como pues una pero como por ejemplo cómo cómo propiciamos más concurrencia solución uno usemos más candados aj sí fena raro s es que como tiene es su chiste eh prismos más candados solución dos Bueno pues qué tal que no somamos candados no O como la otra Ajá un
(30:30) candado para los candados Ajá Sí de hecho hay implementaciones así e entonces Bueno definitivamente como dice Fernanda no sea como que ahí está extraño qué pasa con los valores de la cola Pues sí realmente es más difícil uno hacerlo y dos demostrar que es correcto o sea todo se vuelve más complicado no e entonces Bueno una forma eh de cómo funcionan estas propiedades de corrección para demostrar que que es correcto es transformar ejecuciones concurrentes en secuenciales y analizar la ejecución de las secuenciales
(31:11) Ah entonces Bueno ahorita vamos a ello vale Pero bueno es la idea es mucho esta palabra de transformar concurrente a secuencial entonces bueno eh Este es otro ejempl ito de una cola concurrente sin candados em pero solo es para dos hilos no O sea qué chafa Pero bueno o sea la otra es para en hilos no los hilos que sea esta solo es para dos pero que nos permiten utilizar candados entonces eh vamos a ver que solo es para dos hilos y que de hecho solo un hilo puede encolar y que solo otro puedes encolar Vale entonces
(31:56) H es este cómo funciona eh tenemos este variables compartidas otra vez no pues get Tail y ems vale eh Cómo se inicializa simplemente pues otra vez es este circulito de ems vale es la misma como abstracción Entonces se inicializa en el tamaño de la capacidad van cero Entonces ya vienen aquí pues ya no hay candados O sea pues ya se hace lo que lo que este lo mismito en realidad miren solo igual no se compara si hay este espacio Bueno si si hay espo para encolar pues lo hago No pero si no pues lanzo una excepción Entonces ya para encolar pues
(32:45) hacemos lo mismo nos fijamos en En dónde está Tail y metemos nuestra x y aumentamos Tail vale Y eso es para encolar para des encolar otra vez Es lo mismito No si está vacía pues no des encol nada pero si no está vacía pues leemos al que apunta get y aumentamos este el apuntador de G Y regresamos simplemente la x no entonces y bueno es curioso no Esto bueno analizando no ustedes qué creen o sea tenemos por ejemplo dos hilos tenemos un hilo a Y tenemos un hilo B a y b y a vamos a pensar que es el en y es el de Entonces pues por ejemplo pu quiere
(33:53) encolar cosas enb así quiere encolar cosas entonces en qa por ejemplo no en q Pues si va solito no tiene mucha ciencia No pues él simplemente hace cosas ahí y bueno vamos a pensar que él quiere encolar c y se queda ahí como pasmados no y luego B pues quiere aquí este él quiere hacer de K Simplemente no entonces como que aquí como que qué regresaría no es la pregunta de yro de y bueno aquí que regresa no entonces La pregunta es esta este como que ve o sea es como la pregunta es si se congela O sea si ya se queda como aquí
(34:51) dormido no O sea ya no terminó o sea iba a ser el empezó pero no acabó Entonces como la pregunta es ea a b o sea B tiene algún impedimento en seguir desencolado entonces bueno esa es la pregunta dice no lo detiene dice Camil no lo detiene solo B tira la excepción de Tail igual a he Ajá exacto no y ya está entonces dice empty empty y ya está eh Okay entonces Déjenme ver acá Ajá sí hay que dejarlo así entonces bueno aquí en estas vamos a suponer no que pues aquí realmente él des encola a aquí des encola no sé B aquí dicen colas
(35:37) c porque pues ya está o bueno puede ser que realmente no acabó a no que nunca dispuso sé o puede ser que sí no pero vamos a poner vamos a pensar que sí y ya lo ponemos no pasa nada no dice c pues nada más hace un deq y regresa la excepción No importa que ha se quede pasmado por siempre no Entonces sí pues no no pasa nada entonces cuando no usamos candados este el el que se detenga pues no nos molesta no no detiene el progreso de los demás hilos en este caso solo son dos no entonces el que el que ya se detenga no
(36:30) no detiene el progreso de B pero si se dan cuenta en la anterior aquí sí no si algún hilo por ejemplo ha tiene aquí no y y este y pues no deja el candado pues entonces todo se detiene no es distinto cuando usas candados y cuando no Bueno entonces eh esa es una cosa El Progreso no O sea como es progreso aquí se ve no El Progreso de los hilos y luego acá o sea adás hay que hay que analizar tenemos esta misma implementación hay que ver no bueno las operaciones ahora se traslapan y este entonces hay que ver no realmente se
(37:23) sigue manteniendo fifo o sea realmente es correcta esta ejecución con respecto a una cola no O sea si si permitimos que las cosas se traslapen déjen copiar esta o sea como que qué podría pasar no entonces eh Por ejemplo dónde y y aquí como que para analizar si realmente esto correcto as Si no vamos a tener una situación ahí extraña como dice como dice Fernanda no O sea pasa algo con con los valores de la cola no si permitimos que ejecuten en q y deq al mismo tiempo entonces bueno por ejemplo dónde estaría eh Dónde es
(38:12) donde tiene efecto una operación en el método enq no O sea Cuándo realmente los demás sí los perciben que algo se agregó a la cola en este caso cuando el el Deer no percibe que algo se en coló Pues bueno no sería en [Música] la en la en la línea 12 no la línea cu di dice Camilo la línea cu 2 3 cu O sea la lía cu del en no sí sí Ah Sí justo no es línea cu o sea línea 12 Entonces en esta línea justo como dice Camilo No porque si por ejemplo si está aquí haciendo cosas el hilo no y y por ejemplo aquí pues él dice ay voy a
(39:00) ver si está llena no ay no está llena entonces voy a escribir mi ítem y por fin aquí es que dice Ah voy a hacer Tail más más no Y entonces cuando Tail sea diferente este Porque si por ejemplo el hilo de ker va a decir bueno Tail es igual a g o sea son igual a cero Pues no hay nada hasta que vea que Tail cambió es que realmente el hilo de ker va a poder este leer No pero no va a poder leer o sea aunque el hilo en colador ya haya escrito x y no mueva Tail O sea si no mueve Tail é no va a poder leer este último ítem que que ler escribió no
(39:48) Entonces es esta justo esta línea no es justo esa línea entonces a fuerzas eh para que el de que haya regresado a pues quiere decir que a fuerzas eh la línea e 12 no la de Tail má más tuvo que suceder antes que este la línea 15 esta de Tail men Head ig 0 No porque si no quiere decir que están en el mismo no O sea no este entonces Bueno o sea para que se tuvo para que se haya regresado a tuvo que haber pasado esto No porque si no el deq regresó empty no O sea si no si no sucedieron este en este orden entonces Bueno ahí no hay problema
(40:49) o sea como que dice sí tiene sentido no O sea no no van a pasar cosas raras en este caso ese es un ejemplo e Pero bueno Déjenme ver si vemos la corrección de esta No creo que no Entonces Bueno sí Acabo de explicarles esto eh Bueno ese es un ejemplo Déjenme copio esto otra vez perd ahorita ya lo copi bueno que estoy acá Entonces yo lo que les había comentado zuriel es que que es correcto que de qw regrese a pero es muy importante notar que si
(41:54) regreso a quiere decir que la línea 12 en donde el el enq ISO Tail más más No o sea por fin modificó el apuntador de Tail quiere decir que que esto tuvo que suceder antes que la línea 15 en donde el de ker ve si realmente Tail es igual a G No Ahí es donde ve entonces forzosamente Tuvo que pasar Eh pues que línea 12 sucedió antes que línea 15 vale para que voa regresar el de q el de q a otra cosa pues también pudo haber sido no lo puedo copiar pegar Okay entonces eso es una forma la otra cosa pues qué puede haber pasado no
(42:55) en realidad puede ser que regresemos en o puede ser que regresemos en q empty no O sea pues que no lo leímos Por qué Porque la línea 15 eh En este caso podría ser no que sucedió antes que Tail no que la línea 12 del enq vale o sea pod puede ser Entonces no no vio que realmente escribió el encuer Entonces por ejemplo si acá eh este por ejemplo supongamos no que después el deq deb qué podría pasar no otra situación dejen borro esto supongamos que que
(44:01) se que se traslapan no imagínense que se traslap un deq con dos enq vale qué podría pasar Pues bueno aquí como en realidad ya se escribió sea digamos que nuestra cola pues ya tenemos esto no Entonces tenemos imagínense que ahí va y Tail ya está aquí entonces qué podría pasar Bueno pues en realidad independientemente de que de de cuándo pase la línea 12 del método enq Pues en realidad el o sea el deq siempre va a regresar a no O sea no no importa aquí Cómo se traslape no siempre tiene que regresar a por qué Porque
(44:52) Eh pues está en el primer elemento no y de hecho ya Tail es distinto a cero entonces va a ver que pues la cola no está vacía este forzosamente va a pasar a la línea 18 y entonces se va a dar cuenta no que apunta a a Y entonces qué va a hacer pues va va a mover Head no va a mover Head acá no y va a regresar independientemente de cuánto tarde en escribirse b no O sea tarde pues no no le importa o sea no se puede avanzar G dos veces no O sea como para que pasen cosas raras solo solo avanzas de uno entonces este como
(45:40) que funciona en realidad esto porque solo somos dos hilos No pero si fuéramos tres ahí sí habría un problema o sea si alguien te avanza el get doble no ahí sí habría un problema pero en este caso funciona Vale entonces funciona cuando se traslapa un dq con un enq cuando se traslapa un dq con dos enq o cuando se traslap un enq con dos de q también funciona vale porque he solo se aumenta uno no y siempre estás checando que Tail no alcance a get y los dos tienen que siempre ver eso vale entonces por eso funciona pregunta nunca se borra al
(46:17) elemento arreglo no no se borra o sea ahí se queda y se sobreescribe lo que va avanzando sonil vale Ajá sí solo se mueve la cabeza Sí sí sí entonces Bueno ahí voy entonces eso es un ejemplo vale Vimos una cola concurrente paraos pero que es bloqueante O sea que usa candados y Vimos una cola concurrente no obviamente concurrente para dos hilos nada más pero que este no utiliza cantados O sea que es no bloqueante vale o sea son dos dos iones distintas de una cola entonces e vamos a notar que las implementaciones
(47:04) de objetos tienen condiciones de Progreso y también tienen condiciones de corrección las de Progreso tienen que ver con esta propiedad de viveza es decir como que suponen que algo bueno en algún momento pasará Vale entonces por ejemplo deadlock free starvation free son condiciones de Progreso pero entran en el lado de la bloqueantes eh Y y este y ahorita vamos a ver no Qué hay de lado de las no bloqueantes entonces la diferencia entre que sean bloqueantes o no bloqueantes Es que este el el es en el progreso o sea Pues justo
(47:48) no en el retraso si si uno se retrasa la pregunta es bloquea los demás o no las bloquea vale o sea y es la la diferencia en esta implementación si un hilo que está ejecutando el enq se pues se pone lento no O se detiene y no deja el candado o sea realmente dice aquí como Ah Ya voy ya voy no y no deja el candado este pues los los otros hilos este se quedan como en cuello de botella no todos tratando de de hacer el deq o en no O sea Todos quieren hacer progresar pero el hilo que se quedó con el candado medi dormido que va lento pues nos
(48:27) detiene a todos y en este caso acá no no O sea si el hilo encolador o el desencolado se detiene pues no pasa nada el otro hilo simplemente va a decir pues regreso que está lleno O sea ya cuando ya no puedo meter nada pues digo Ah está lleno está lleno y si no ya no hay nada que desencolar pues simplemente regreso está vacío pero no me pasmo ahí no O sea termino y ya está entonces la diferencia y justo como que es lo que veíamos no la el tema anterior que ustedes me comentaban no como bueno Qué tal que ha se detiene Sí pues si ha se detiene Pues
(49:06) nos retrasa a todos porque estamos usando candados no estamos en este lado de los bloqueantes y y este y bueno entonces les digo no existe otro lado en donde no sucede Esto entonces bueno justo no es bloqueante si el retraso inesperado de algún uno de los los retrasa a otros y estos retrasos Eh Pues bueno Cómo va a ser no que alguien se retrase Pues bueno sí sucede no porque pues las máquinas pues no se están resolviendo varias cosas no no es como que controlemos que todos se muevan a una misma velocidad y también depende pues del sistema
(49:47) operativo en realidad pues una cosa es nuestro procesador no y otra cosa es todo lo que está encima Entonces sí O sea hay como Pues así es cierta no me pregunt Por qué se tuvo este candado justamente o sea Perdón por qué se tuvo este hilo está cañón no pero hay que entender no que hay muchas variables o sea en realidad pues un hilo Pues en nuestro caso este nuestras compos tienen los hilos pero sobre ello está nuestro sistema operativo y sobre ello está Eh pues Java no la máquina virtual entonces de allá a ver que por qué se
(50:21) detuvo un hilo pero se detienen no y no corren a la misma velocidad entonces Entonces por ejemplo aquí se ven O sea si si utilizábamos un candado peterson no y dos hilos están aquí tratando de ejecutar este esta cola Pues si este se detiene detiene el otro no y hasta que no dej estee el candado Es que este va a poder hacer su método no O sea no se deq o un enq e entonces bueno deadlock free y starvation free son condiciones de Progreso bloqueantes y y es por eso justo que está como esta palabra de eventualmente no O sea
(51:06) eventualmente no sé cuándo no eh pero eventualmente alguien va a pasar no O eventualmente todos vamos a tener éxito Vale entonces mucho esto como Pues si es que si ya se detiene Pues sí nos atoramos No pero eventualmente va va a despertar no O sea O se va a mover y e una implementación No bloqueante si alguien se atrasa pues no nos detiene a todos Entonces es como en esta no O sea en este en esta implementación si por ejemplo pues yo estoy ejecutando aquí un deq luego un enq este es es el hilo sería el desencolado y este el encolador No ent
(51:51) si este se llega a detener no pasa nada no O sea pues va a regresar en siempre y nada pasa vale ent está bien si alguien se detiene este no me afecta ni me doy cuenta no entonces eh Qué tipos de porque ya vimos no deadlock free Station free son bloqueantes Por qué regresa empt aj Sí es que ya vimos no que esta operación este puede regresar empty o puede regresar eh que es en colo dos no Cuál es la diferencia es que eh Por ejemplo aquí para que este regrese empty tuvo que haber pasado la línea 15 antes de [Música]
(52:43) eh la línea es la línea 12 no la de Tail más más por qué Porque el hilo el desencolado no se va a dar cuenta que hay pues algo no en los candados no hay entonces en los no bloqueantes no hay candados sí Exacto sí O sea si si no ven candado hay que si hay candado es así bloqueante O sea no hay de otra es así Ay Oiga este diseñé un sistema con candados Bueno diseñaste un sistema bloqueante no Y si no hay candados hay que analizar porque seguro es no bloqueante no Sí o sea regularmente son No bloqueantes si es así es casi un hecho
(53:28) no sé O sea no no lo generalizo porque no sé no O sea qué tal que hacen una implementación no tremenda y Se bloqueó no Ajá pero sí vale entonces sí O sea les digo como que pues este ser podría regresar dos o podría regresar m depende el orden en el que se ejecute la línea 15 y la línea 12 pero eso es un ejemplo realmente este es una ejecución ejemplo de esta implementación o seaas corresponde Okay entonces wait free A qué se refiere bueno eh un método es weit free si decimos así si si garantiza que cada llamada a un método termina su ejecución
(54:09) en un número finito de pasos Vale entonces eh si se dan cuenta aquí weit free o sea bueno si no usa candados weit free Pero además te garantiza que que todas no O sea las llamadas es decir todos los entonces este es lo que nos dice no Entonces sí se podría así garantiza que todo que cada hilo progrese que todo hilo progrese Okay entonces eh En este caso esta esta implementación ya vieron hasta la nombraron así en el libro Pues sí es una implementación we free Por qué Porque el retraso de a no interfiere con
(55:13) el progreso de b y b puede terminar su ejecución siempre en un número finito de pasos no O sea no no se queda dando vueltas como en los candados no y este y además esto sucede también para para bueno sucede también para B no para B entonces también el retraso de B no interfiere con el progreso de a o sea como que ambos progresamos no puede ser que solo uno progrese los dos o sea esta implementación es solo para dos siglos y todos progresamos independientemente de que el otro se detenga entonces bueno Esa sí una
(55:49) pregunta como que si me cacharon no me venido entendiendo según yo está fácil este esta implementación es fre sería por ejemplo Cómo la ven dice pues si Camilo es el que lein no O sea también Eduardo si no no es no por qué Porque los candados Exacto W free no usa candados No jamás no usa candados y esta pues es una implementación lock based no basada en candados entonces simplemente por esto decimos que pues ya no es we free Vale qué podríamos analizar de esta implementación Pues de esta sí podríamos pensar no O sea bueno
(56:33) respuesta pues no es eh Pero bueno podríamos analizar si es eh deadlock pre O sea si no hay candado muerto o si no sea no se mueren de hambre no starvation free son dos cosas que sí podríamos analizar sobre esta implementación pero así así de pura vista decimos Ay usa candos no no O sea no puede ser wiit free Vale entonces así este y bueno está lock free Perdón está weit free y está lock free Ah que es distinta de lock free Okay pero bueno creo que no me va a dar tiempo pero nada más les digo ya la siguiente clase Empiezo con
(57:27) eh lock free un método va a ser lock free si garantiza que infinitamente seguido algun ha llamado un método acabará en en un número finito de pasos Cuántos infinitos no pero bueno lo importante de l free es esta palabra no alguna quiere decir que algún proceso termina en un número finito de pasos y esto cada cuánto pasa pues infinitamente seguido ves como lo que dice lock free Entonces si se dan cuenta wiit free es como todos y lock free es alguien alguien acaba en un número finito de pasos entonces bueno Esto se ve así ya
(58:17) nada más para terminar así lo vemos vale tenemos implementaciones no bloqueantes bloqueantes y este la diferencia por ejemplo es que si todos progresan o alguien progresa y ya vieron la wiit free pues es como el análogo a starvation free pero para los no bloqueantes y lock free es el análogo a lo free para los igual no bloqueantes vale entonces así se ve y ya Ah ahí le dejamos Entonces nos vemos el miércoles vale que tengan buen inicio de semana Bye bu
