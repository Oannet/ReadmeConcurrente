(6) 2024 10 10 10 01 56 - YouTube
https://www.youtube.com/watch?v=-pd4-FT4Uog

Transcript:
(00:00) bien cómo lo sintieron sí estaba nada más te la chudo qué tal les va en la vida oyen Cómo van con el tema de consenso mal y los demás más o menos es que si es un tema si es un tema medio medio complicado de entender al inicio Pero ahorita lo vamos a revisar y está bonito bueno es que creo que es el tema favorito de la maestra Entonces lo
(01:03) explica este explica bastantes cosas de ese tema pero si al principio es Es difícil de entender la idea de hoy es revisar los ejercicios e dos ejercicios de de su examen en los que parece que algunos tuvieron duda para que que se relacionan bastante con con los registros regular y con los snapshots no porque acuérdense que el consenso en general está muy relacionado con con los registros regulares y con los snapshots entonces La idea es revisar estos ejercicios luego volver a repasar ya nada más para acabar el tema o bueno para acabarlo por
(01:49) ahorita lo de los snapshots y pasarnos a a la parte de consenso y de construcción universal les parece o no les parece va entonces dejen Les comparto pantalla para empezar sí Yo confío en que todos les parece lo bueno de esto es que ya estamos están más cerca de terminar el semestre yo no sé por qué este semestre este semestre siempre se hace más pesado no que el siguiente de semana santa o soy yo sí no sí Es que creo que este es más largo Bueno por lo de semana santa no hay más vacaciones a mí siempre se me hace más pesado este de
(02:46) acá pero bueno lo bueno es que ya nada más Sí si hay par Sones el de r dejó tres prácticas para el mismo día sí así pasa e sí no peroen lo bueno es que ya casi acaba octubre y de octubre ya están en noviembre y de noviembre ya están en diciembre y ya quedó saben hay que pensar como si fuéramos heurística y todo está bien entonces eh vamos a revisar este de El el peterson pero para árboles binarios y vamos a revisar este de bueno una variación de este para un snapshot weight free y vamos a revisar otra vez lo de los snapshots
(03:44) Entonces vamos eh la idea Bueno estos dos eran este por estos dos se argumentaban se argumentaban por peterson no salía en directo se argumentaban por peterson por la propiedades que cumple peterson entonces Como cada nodo de un árbol tenía un lock peterson claramente es este en general todo este algoritmo de de peterson en un árbol binario yba a cumplir con exclusión mutua y con starvation free sí Entonces lo lo que habíamos demostrado nosotros en la tarea anterior o sea lo que ya tenían era lo que ustedes ya tenían de la tarea
(04:34) anterior por un ejercicio bastante similar era que este de acá pues no era justo no entonces este algoritmo para empezar no es justo Entonces ustedes ya tenían eso y lo único que tenían que este revisar era eh si se cumplía con una Cota eh En el que el número de veces que un hilo puede ser aventajado o sea cumpliera con esa Cota máxima no Por ejemplo si tienen un hilo a y tienen acá su hilo a y tienen acá su hilo B lo que les preguntaba era puede a rebasar máximo re Ay rebasar máximo n veces a b y n ser un un
(05:24) este un número fijo de cierta forma Entonces eso era lo que tenían que ver y cuál era la respuesta ustedes qué pusieron ahí no había un un un número máximo Por qué imagínense que ustedes tienen acá muy bien si no hay imagínense que ustedes Acá tienen su árbol binario no entonces tienen acá su árbol binario acá y acá no Entonces que depende de la cantidad de tiempo que lo que se que muy bien sí depende Eh no depende de el nivel y no depende porque para que existiera una Cota superior fija debería depender de un
(06:27) número o de un n que ustedes supieran entonces para depender de este número o de esta n lo que tendrían que hacer o sea que esa n dependiera de del nivel en el que está entonces ahí les va Uy básicamente no cumple son de cierta forma independientes no Entonces si un hilo está en un nivel en el nivel i o en el nivel j y se duerme están acá los hilos a b c y d no de si este de acá se queda dormido si este de aquí se queda dormido eh d puede rebasar lo un número número arbitrario
(07:30) de veces hasta que despierte Y eso va a pasar imagínense que está este en el nivel cero Esto está pasando en el nivel cero entonces Esto va a pasar si el si este hilo a se duerme eh un un arbitrario un tiempo arbitrario de lo puede pasar un número arbitrario de veces y lo puede pasar en cada nivel Entonces si a se vuelve a dormir en el el siguiente nivel va a pasar lo mismo si de vuelve a ganar todos los logs No pero si se dan cuenta acá es que no pasa y justamente no pasa porque los subárboles son independientes y esta parte de acá
(08:27) eh el el que un hilo el que ve rebase a un hilo a a depende plenamente de el tiempo que ya se duerme entonces básicamente de acá concluían que B lo puedo pasar un número arbitrario de veces sí lo ven si hubiera existido una Cota O sea si si ustedes hubieran podido encontrar una Cota esa Cota acuérdense que tiene que ser sí un número o sea tiene que ser un número fijo al final del día no entonces la única forma de que ustedes hubieran encontrado una Cota eh debía haber sido eh uno por el número de hilos o sea una Cota basada en
(09:32) en el nivel del árbol y si se dan cuenta el nivel del árbol depende de el número de hilos entonces la Cota la debieron haber sacado del número de hilos pero de puede rebasar eh un número arbitrario de veces o sea que por ejemplo acá imagínense que hay eh 2 4 6 8 hilos no bueno es que peterson sí es justo pero cuando ustedes tienen esa es a donde vamos cuando ustedes tienen un árbol o sea cuando ustedes meten a peterson el árbol binario en general no es justo porque les va e no sé por qué siempre muy poco espacio ahí les
(10:33) va básicamente O sea peterson sí es justo no Bueno pero se basa en en que es que la la idea de acá es lo que les digo siempre tienen que hacer un tipo de ingeniería inversa todos lo pusieron así no Ah bueno este Okay tienen que hacer un tipo de de ingeniería inversa porque o sea tienen que encontrar es como bueno por eso a mí me gusta mucho la la contradicción pero básicamente en en problemas así y para diseñar sus algoritmos lo la forma más eficiente de llegar a la solución es encontrar un tipo de ingeniería inversa entonces tienen que empezar de
(11:34) atrás para adelante si hubieran encontrado una Cota significa que esa Cota se basa en el número de hilos Entonces si se basa en el número de hilos e ya tienen que revisar veces e aunque no dependa del número de hilos Entonces si encuentran eso pues ya no encontraron una una Cota me explico porque no hay otro o sea ustedes no tienen otro parámetro eh A pesar de O sea no tienen otro parámetro además de del número de hilos en el que puedan basar su Cota entonces [Música] p la parte que hace que eh peterson en un árbol binario se se vuelve Injusto
(12:30) son estas conexiones de acá son las aristas entre los nodos esa parte hace que peterson en general se vuelva Injusto porque aquí imaginen que tienen los hilos a b y tiene el hilo c Entonces el hilo a eh gana el este lock el hilo c claramente gana Este lock pero aquí hace duerme entonces llega c entra la sección crítica haces un regresa lo vuelve a ganar entra la sección crítica y ya rebasó a a cuando a también quería entrar a ese lock entonces ya no se vuelve justo por este proceso de acá de las aristas estas aristas de acá hacen
(13:14) que el árbol binario en general ya no sea justo pero peterson o sea cada uno de estos es justo pero al momento de conectarlos con con un nodo eh Superior eso ya no es justo porque a se puede quedar dormido y este lo puede rebasar un número arbitrario de veces si lo ven sí los demás va entonces la clave aquí a pensar cuál podría o sea donde dependía de esa Cota y concluir que como los los subárboles eran independientes Eh no dependía de
(14:19) una Cota o del número de hilos sino más bien del tiempo en el que un hilo se se quedara dormido para que el otro lo rebara Entonces por esto podrían concluir que un hilo B puede rebasar un hilo a un número arbitrario de veces si ya se queda dormido un número arbitrario de tiempo va entonces es ese y este de acá ya nada más para terminar el Cómo se llama esta parte de los snapshots vamos a acá les pide que creen una ejecución Ah no no no argumenten si el snapshot seguiría siendo linealiza o no Ah Es está bonito porque
(15:11) básicamente Cuál es la diferencia entre primero tienen que revisar la diferencia entre los registros regulares y los registros atómicos Cuál es la diferencia entre los registros regulares y los registros atómicos regular muy bien Ajá los regulares no tienen lectura atómica los regulares pueden Sí muy bien en los registros regulares solo las escrituras son atómicas las lecturas no son atómicas Ajá muy bien entonces este básicamente si no se traslapa con nadie Entonces sí devuelve los valores que existían enco plantea problemas de de
(16:14) consistencia o de atomicidad o de este no no afecta la linealización linealiza no afecta el ser linealiza no Entonces tenemos tres casos acuérdense cuando un scan va solo o cuando un método va solo eso no afecta cuando dos scans se traslapan o dos updates se traslapan eso tampoco afecta y lo que tienen que revisar es cuando un scan se traslapa con uno o más updates ahí sí Afecta no porque cuando imagínense que ustedes tienen su eh ejecución así tienen esto tien esto y tienen esto no entonces básicamente ahí les
(17:15) va básicamente ejemp y este es a C tienen update B esto en si cuando tienen un caso así eso no afecta nada ni este o sea eso funciona igual que como funciona un un registro atómico no porque í estamos haciendo escrituras y las escrituras son atómicas igual que en los atómicos e porque en los atómicos sus escrituras son atómicas claramente entonces acá cuando tienen esta ejecución así hasta ahí no les afecta nada pero cuando les afecta o sea el único caso en el que les afecta la diferencia entre regulares y atómicos es un tipo de ejecución
(18:14) así por qué Porque BC e porque los registros atómicos que dice un registro regular a lo que dice un registro atómico entonces tienen que revisar si esa diferencia afecta en el hecho de ser linealiza o no va entonces básica imagínense que tenemos este caso no y este scan hace su cocta hace su collect por acá vamos a ponerlo así hace su collect por acá y luego hace su collect por acá No pero collect eh acuérdense que es una operación de
(19:16) lectura sobre la Table no que tiene registros regulares que fue lo que cambiamos Acá está Pero bueno la Table pero acá ya cambiamos el hecho de que esta Table fuera estuviera hecha con registros atómicos y ahora está hecho con registros regulares no entonces puede pasar que tengan algo así si lo ven por qué podría pasar esto por qué podría pasar
(20:30) Ajá un registro ir regular acuérdense que un registro irregular eh cuando una llamada de lectura y escritura se traslapa de lectura puede regresar cualquier valor de entre todos los que se traslapen de entre todos estos cualquier valor No eso les dice un registro ir regular registros regulares Pero como se Está trasl Pando con este otras operaciones de escritura este de acá puede regresar y es acá puede regresar cualquiera de los traslapados entonces en en ese o sea en esa misma línea si puede regresar tanto aquí como acá cualquiera de los
(21:35) traslapados puede pasar que este regrese acá nada más un B O sea regrese acá que no vio nada y luego que vio b y luego que no vio nada y en la New copy puede pasar lo mismo entonces cuando ya tienen que la old copy y que la New copy son iguales lo que regresa el scan es esto es la old copy o la New copy sí lo ven seguros si quieren nos regresamos porque sí es importante que entiendan esta diferencia de los registros para que le sea fácil va esto de consenso entonces básicamente e con un collect Y eso es normal o sea
(22:45) así así viene este algoritmo no así viene esta implementación tiene que hacer un collect acá y un collect acá siempre siempre siempre tiene que hacer un entonces un collect lo que va a hacer es que va a estar leyendo una a Table Pero estas a tables acabamos de cambiar de registros atómicos a registros regulares entonces imagínense que tien acá su Table está así no antes lo que tenían todo esto ustedes estaban seguros que era lo último actualizado Por qué Porque los atómicos les dan la garantía de a registros regulares los registros
(23:54) regulares ya no les dan esta garantía de que sea lo último actualizado eso o sea esta parte de que sea lo último actualizado solo se los dan los registros atómicos los registros regulares Qué tipo de garantía les dan los registros los registros regulares les dan la garantía que lo que están viendo acá e si no se traslapan e lo que están viendo es lo último actualizado tienen un caso si no se traslapan no traslapan lo que están viendo es lo actualizado y si se traslapan actualizado Y si sí se traslapan se traslapan están viendo cualquier valor
(24:46) de los traslapados cualquier cualquier valor Elemento de los traslapados no entonces e qué pasa en este caso de acá ustedes Acá tienen un collect y ese collect lo que va a hacer es leer esta a Table esta de acá de registros regulares entonces esos dos collects lo que van a ver es ahí si se dan cuenta update B Se está traslap con Bueno o sea el scan se está trasladando con varias escrituras entonces la lectura se está trasladando con varias escrituras entonces en qué caso entran en qué caso entrarían si se están
(25:40) trasladando eh ahí el scan con los updates en el dos muy bien entonces entran al caso dos y lo que les dice el caso dos es que puede regresar cualquier valor Elemento de los traslapados en especial puede regresar que acá no regrese nada o sea acá lo que lea sea algo así nada de y nada si lo ven entonces acá puede regresar eso porque puede regresar valores desde acá o sea un un registro regular puede regresar valores desde aquí o sea desde antes hasta todos los traslapados entonces puede regresar que en el hilo a
(26:35) regrese el anterior o sea nada después regrese B que es otro traslapado y después no regrese nada Y eso puede pasar para ambos collects porque si se dan cuenta o sea básicamente acá lo que les va a actualizado en los registros regulares les puede regresar cualquiera de de los que se están e traslap aquí se está traslap de los que se están traslap o antes aquí tienen uno antes es nada entonces puede regresar en estos tres ustedes pueden regresar este este o este este este o este este este o este sí lo ven Entonces
(27:30) sí puede pasar que tengamos algo así sí lo ven hasta casi lo ven sí Okay entonces eh En estos dos collects imagínense que le sale esta parte de acá o sea bueno básicamente imagínense que el escan o sea el resultado del escan es este de acá esto ya no es linealiza porque está pasando que B Eh sí se está viendo pero como b y a no se están traslap O sea a precede a a Bueno qué O sea esta parte precede a b a precede a b Ajá entonces e lo que tendrían que ver sería a b y nada pero están viendo B nada b y
(28:37) nada pero o sea eso ya no se puede eso ya no puede que sea linealiza porque a eh Pasa antes que b y no se están traslap si lo ven acá no se están traslap estos no se están traslapado entonces debía para que sea linealiza debía haber pasado a b y nada pero acá está pasando B nada más todos los demás son nada Entonces ya no es linealiza si lo ven Sí muy bien Ken los demás sí zuriel los de okay Entonces ya nada más para terminar
(29:41) acuérdense Vamos a repasar esta parte de acá nada más por si les quedaron algunas dudas sobre los collects y nos pasamos a la parte de consenso El scan básicamente las updates son están acá su update tienen su update y eh la diferencia de registros no en los que nosotros tenemos son registros atómicos o sea todas las implementaciones que Estuvimos viendo de de los snapshots se utilizan con registros atómicos y cómo funciona el scan el scan básicamente hace esto mismo imagínense que el scan hace una línea acá y hace una línea acá
(30:32) el scan siempre tiene dos líneas porque hace dos collects Entonces el scan el primer collect va a revisar las a tables de acá Entonces el primer collect va a obtener una a Table y el segundo collect va a obtener otra Table Entonces en este caso lo que va a obtener el primer va a ser una a Table donde esté así y algo en el hilo c no y el otro va a estar así algo en el hilo b y algo en el hilo c si lo ven entonces básicamente lo que va a hacer el scan es que los compara los compara y dice si no son iguales vuelvo
(31:25) a hacer otro collect vuelve a hacer otro collect Y eso lo sigue comparando hasta que sean iguales Qué significa que sean iguales que ya no hubo un update en medio de los dos collects Entonces cuando ya tenga las copias iguales si vuelve a hacer un un collect por acá pues las dos copias van a ser esta de aquí y lo que va a regresar el scan es justamente esto sí lo veen no De acá Tienen alguna duda que les haya quedado dudas hasta acá no los demás si tienen alguna duda regresamos
(32:28) de verdad eh Al final estos dos Sí o sea de estas dos comparaciones de estos dos collects quedan igual y acaba el escan y eh es o sea cuando ya las dos comparaciones son iguales el scan regresa esa comparación que quedó igual va los demás todo bien básicamente Qué es consenso eh un consenso eh o sea el problema del consenso casi siempre eh se va a referir
(33:34) a el consenso en general se basa que dos hilos en las blockchains debe haber un consenso para poder o sea para que estén de acuerdo para que estén de acuerdo en una transacción y que esa transacción pueda Ser válida Entonces esta parte de consenso o sea en general se basa en Que varios hilos estén de acuerdo sobre e sobre cierta cómo se lama sobre sobre cierto resultado no a Eh bueno los protocolos de consenso la mayoría de los que vamos a hacer se va a reducir a una parte muy bonita que es decidir O sea que dos hilos o más que
(34:36) los hilos puedan ponerse de acuerdo sobre quién sobre Quién fue el hilo que eh llegó primero sobre Quién fue el hilo que hiz una operación primero una operación primero Entonces cuando ustedes vean consenso acá casi siempre decidir Quién fue el hilo que hizo una operación primero Entonces cuando ustedes piensen en consenso aquí eh casi siempre lo pueden generalizar a e Que varios hilos tengan que decidir quién lo hizo primero no que ustedes puedan hacer un protocolo de consenso donde todos estén de
(35:39) acuerdo sobre Quién fue el que hizo una operación primero entonces e como definición una clase resuelve el consenso y el consenso es este de acá para un número n de hilos si existe un protocolo de consenso acuérdense esta parte protocolo de consenso es lo que nosotros vamos a estar trabajando e el área de trabajo en la que nosotros nos vamos a enfocar es en protocolos de consenso entonces una clase resuelve el consenso para un número n de hilos si existe un protocolo de consenso que utiliza cualquier número de objetos de esta misma clase de esta
(36:20) clase C y cualquier número de registros atómicos va entonces es importante que vean que son ambas no cualquier número de objetos de la clase C y cualquier número de registros atómicos ahorita vamos a ver que Eh bueno el consenso los protocolos de consenso están muy relacionados con e con los registros atómicos pero no se puede resolver el consenso con registros atómicos por eso en esta definición les dice que una cualquier número de objetos de la clase C y cualquier número de registros atómicos Entonces si tenemos o si queremos
(37:12) generar un protocolo de consenso para nilos qué es lo que o sea cuál es Nuestro objetivo cuál es Nuestro objetivo el generar consenso o cuál es Nuestro objetivo siempre que estemos nosotros viendo protocolos de consenso esto que los ni se pongan de acuerdo sobre Quién fue el que hizo una operación primero véanlo así casi siempre que nosotros trabajemos con protocolos de consenso se va a a reducir a que estos nilos o sea tener todo este protocolo de consenso donde estos nilos se pongan de acuerdo sobre quién pasó primero y ya quedó
(37:55) Sí dudas hasta acá ahí les va e podemos resolver el consenso usando registros atómicos se puede o no se puede eh varios hilos y básicamente Por qué no se puede lo que nosotros queremos eh acá lo que estamos diciendo es podemos o se esto es básicamente equivalente a decir podemos saber quién se movió primero quién se movió primero usando
(39:02) registros registros atómicos eso es lo que quiere decir básicamente Entonces cuando nosotros estemos viendo consenso normalmente es es equivalente a decir algo así no podemos saber quién se movió con este protocolo de consenso digo quién se movió primero Y que todos estén de acuerdo en quién se movió primero Entonces como como tenemos este lema que dice que un protocolo de consenso binario que sea weit free lo pueden llevar a de deción crítica no entonces amente un estado crítico ustedes cuando tienen un protocolo sea free ustedes lo pueden
(40:15) llevar a un estado crítico Y entonces qué es un estado crítico un estado crítico Es que para empezar es bivalente Y ustedes tienen imagínense que ustedes tienen acá y eventualmente el hilo a llega a cer0 el hilo B llega a un e acá tienen 0 y un esto es bivalente Y si cualquier H se mueve cero y los dos se vuelven cero Entonces se vuelve un estado otra vez univalente Entonces se cumple que este ya es un estado crítico porque es
(41:18) bivalente Y si cualquiera se mueve se vuelve univalente Si lo ven entonces básicamente estado crítico se ve más o menos así no tiene que ser bivalente y si cualquiera se mueve se vuelve univalente Entonces por qué no podemos resolver el consenso usando solamente registros atómicos y si lo ven de de cierta forma análoga por qué no podemos saber quién se movió primero usando solamente registros atómicos por qué no podemos llegar a este con registros atómicos no tenemos este caso donde a Lee y luego porque acuérdense
(42:13) que el registro un registro tiene operaciones de lectura y escritura solamente entonces podemos tener muchas estas ejecuciones entonces puede ser que a lea y luego B escriba puede ser al revés pero ese mismo es ser la misma ejecución sin pérdida de generalidad podemos tener este caso o los dos escriben pero este es el caso más según yo más eh gráfico para que puedan ver por qué no eh se puede resolver usando e registros atómicos imagínense o sea ustedes tienen acá su protocolo de consenso y tienen acá r0 r1 no
(43:08) Entonces qué puede pasar puede ser que a escriba en r0 puede ser que a sea el primero en escribir r0 Entonces a lo escribe y luego puede pasar que o sea que la ejecución sea así que a escriba r y Lu luego B escribe rer Entonces en este punto lo que va a pasar Es que cuando ustedes lleguen a a este estado de acá lo que ustedes van a tener es que van a tener e hayan empezado si a empezó y luego B empezó Entonces el estado cero Valente Y luego cero Valente Y luego si B empezó y luego a escribió entonces van a tener un estado
(44:08) unov Valente Acá está no cero Valente Y uno Valente que sea cero Valente significa que una ejecución dijo que el primero había sido el hilo cero Y en este caso pues el hilo cero es el hilo a no que sea uno Valente significa que decidieron que el que fue primero fue el uno y en este caso entre 0 y uno a y b b es el el hilo uno entonces en esta ejecución de acá en esta ejecución de por acá se decidió que era cero Valente O sea que el a había empezado el H lo a había empezado de forma correcta No y o sea las segundas escrituras que se
(44:55) hacen A eso va a eso vamos muy bien A eso vamos y para acá si se hace para acá el B que el B escriba primero la idea es que tengan un estado un Valente No eso es lo que nosotros queremos Pero ahí les va cuando ustedes imagínense que a escribe el registro a escribe el registro cero no a r vamos a ponerlo mejor así eh Por ejemplo a y después ve escribe el otro registro Esta es la primera ejecución no la ejecución morada Entonces cuando llegu en este punto de acá cuando lleguen acá a un estado
(46:01) crítico ustedes lo que van a tener es un registro cero igual a a y un registro 1 ig a b Esto es lo único que van a tener en su estado crítico lo único lo único con esta información ustedes pueden determinar Quién fue el que lo hizo primero O sea si a escribió primero o b escribió primero no exacto y y pasa lo mismo en la otra ejecución este se escribe primero tienen que ver se escribe acá arriba sab es el primero que escribe Pero al final tienen el mismo resultado si lo ven tiene es lo único que tienen ya cuando están
(47:02) en su estado crítico de este resultado o sea los dos resultados son iguales Entonces no hay forma de que ustedes sepan Pero al final no hay diferencias en los resultados Entonces ustedes no pueden ver desde acá Quién fue el que lo hizo primero si a o b porque independientemente de que haya sido a o independientemente de que haya sido B van a llegar a lo mismo que es lo que representan acá lo que debió haber regado en la primera ejecución de que a empezara debió haber sido un estado cero Valente un estado cero Valente Y en el
(47:46) caso en el que B empezara debía haber sido un estado uno Valente pero eh cuando ustedes escriben estos registros regulares van a tener el mismo resultado que es este de acá imagínense que es este de acá ustedes tienen esto acá Uy bueno imagínense que tienen este estado de acá y este estado de aquí es justamente este estado de acá Este y este si se dan cuenta las dos ejecuciones llegan a lo mismo qué es lo que nos dice la imagen si a empieza eh la idea es que fuera cero Valente pero llega a la misma conclusión o llega al
(48:31) mismo estado al que llega B Entonces no hay forma de que ustedes sepan si a lo hizo primero o b lo hizo primero eh basado en este resultado no porque los dos van a llegar a lo mismo si a lo hice primero o b lo hice primero los dos van a llegar a lo mismo entonces solamente con registros atómicos ustedes quién se movió Ah a aquí no os estamos tratando de mostrar que no se puede resolver un consenso usando registros atómicos el resultado es pues que no hay un consenso O sea que este no es un protocolo de consenso cuando
(49:10) tienen dos hilos o más Ajá Entonces cuando tienen un hilo Eh sí pero cuando tienen más hilos cuando tienen dos ahorita que estoy tratando de representar que en esta ejecución si solo usan registros atómicos la van a tener van a llegar a lo mismo y si llegan a lo mismo ustedes no van a poder saber si empezó a o empezó B si lo ven Okay este nada más es en uno de los casos diferente al que escribe B Pero tenemos el caso en el que a Lee y este B escribe y pasa Exactamente lo
(50:21) mismo atómicos tenemos que revisar todos los casos este nada más es uno de los casos pero por ejemplo tenemos este caso donde están en su estado y lo primero que hacen o sea tienen esta parte de que a así a le mejor arriba a y luego acá a Lee primero y luego B ejecuta B ejecuta una operación o sea imagínense operación B ejecuta una operación y después ve hace otra operación solo entonces lo que van a tener acá es que en este caso e lo que van a o sea lo que se refiere esta parte de acá es que cuando a se mueve primero esto
(51:27) va a llevar a a un escenario cero Valente Y cuando B se mueve primero cuando B se mueve primero b ejecuta b hace la operación esto lo que debería llevar tendría que ser a un estado unov Valente si lo ven o sea básicamente si B fue el primero tiene que llegar a un estado unov Valente si a fue el primero que el problema es que cuando nosotros estamos revisando o sea cuando nosotros lleguemos acá tenemos lo mismo nada más vamos a tener casos Si a empieza o b empieza los dos van a llevar porque a no se registra no O sea a realmente lo que hace a no
(52:30) afecta en ningún registro nada más los lee pero acá lo que tienen es que lo único que se va a registrar es la operación de B Entonces lo único de lo que van a tener registros es la operación de B pero pudo haber pasado que antes de esta operación eh a haya leído O puede que no pero no lo van a saber si nada más lo único que ustedes van a estar viendo es la operación de B sí lo ven lo que tienen que revisar en en en esta parte de consensos es el resultado si el resultado del resultado ustedes pueden determinar quién lo hizo
(53:11) acá el único resultado que tienen es la operación de B entonces de aquí no pueden determinar si B fue el que empezó haciendo la operación o a fue el que empezó leyendo eh algún registro sí lo ven sí lo ven o quieren que lo repasemos la siguiente semana qué esy jueves o martes Ah sí la siguiente semana sí no B hace una operación Lo importante es que ve hace una operación acá tienes dos formas de ejecuciones que ve hace una operación o que a lee un registro y después ve hace la mismo debería primero Dear un estado
(54:16) cero Valente porque cero Valente significa que ya empezó si B empezó deberían llegar a un estado un Valente entonces pero el resultado que ustedes van a obtener de ambas ejecuciones nada más es la operación de B en ambas ejecuciones lo único que ustedes van a ver es la operación de B si a empezó o b que empezó fue B haciendo la operación o empezó a leyendo y luego B haciendo ación ustedes no lo pueden determinar nada más de esto de acá si yo les no muy bien entonces es lo mismo ustedes le van a dar operación de B al
(55:22) final pueden garantizarles si empeso a o empeso b entonces eh lo que nosotros tenemos es que lo importante de esto lo que quiero que que se lleven a sus casas es el consenso usando solo registros atómicos sí necesitan atómicos pero no lo pueden resolver usando solo registros atómicos sí lo ven Okay muy bien entonces
(56:35) Eh Esto lo lo hicimos o sea nuestros ejemplos de ejecución fueron para dos hilos pero pues ya es un poco más fácil verlo ver la generalización para n yos no entonces ahorita hicimos que un consenso de dos no se puede resolver usando solo registros atómicos Pero eso se puede generalizar y es verdad o sea es es un lema que no se puede resolver el consenso usando e el consenso para nilos usando registros atómicos Okay entonces yo creo que lo dejamos hasta acá nos vemos el siguiente martes para seguir repasando esta parte
(57:25) de consenso y poder empezar a entrar a va Cuídense mucho Bonito fin Bye [Música] bye an
