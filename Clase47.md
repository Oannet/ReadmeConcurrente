(6) 2024 10 08 10 03 07 - YouTube
https://www.youtube.com/watch?v=c-jv57iLBug

Transcript:
(00:07) ex semestre qué tal van con su examen ahí van muy bien Ahorita lo vamos a revisar para que por si tienen dudas snapshot ahorita lo revisamos eh dejen los primeros Cómo van bien va entonces les voy a compartir pantalla eem pero eh En lo que carga mi computadora no puedo ver los comentarios cuando estoy en otra pantalla entonces Hola Uriel entonces alguien me va avisando No si hay comentarios en lo que carga mi pantalla o me los leen o algo
(01:11) entonces les voy a compartir pantalla y lo empezamos a revisar va Enton entonces e el primer ejercicio Realmente está eh Muy similar a a los que están en las primeras en la primera tarea es bastante fácil es de la ley de andal entonces aquí lo único que tienen que hacer es acordarse que el Speed up Según la ley deal era 1 men p+ p sobre n y este ahora Ajá 1 - p + p sobre n y acá lo único que tienen que hacer es eh revisar lo mismo que este revisamos en el último ejercicio de los últimos ejercicios que
(02:18) revisamos eh en su primera tarea entonces acá básicamente lo único que tienen que revisar es que es 84 por paralelizar e y tienen que comparar tienen que hacer dos operaciones no comparar este versus este donde cada procesador ejecuta un millón de operaciones por segundo entonces realmente lo único que tienen que hacer es comparar los dos speedup y poner la comparación o sea como conclusión final nada más poner la la conclusión final de los de de las comparaciones de los dos pero si tienen que hacer las dos operaciones o
(03:05) sea las dos los dos procesos para que puedan ustedes o sea para que podamos nosotras ver el proceso que ustedes siguieron la lógica que ustedes siguieron para llegar al Speed y ya al final nada más es compararlo pero realmente está está relativamente sencillo No sí bu no si no a ver ya ya los admitió todos los que estaban esperando entrar Ok [Música] entonces la parte nada más es comparar dos speeds entonces relativamente fácil esta parte la pueden ver de dos más pueden hacerlo de una forma optimizada o pueden hacerlo de una forma
(04:04) no optimizada al final ustedes saben que todos los prisioneros van a entrar eventualmente al cuarto eh en veces no pero el problema es que ustedes no saben el estado inicial del interruptor entonces antes e cuando cuando los prisioneros aquí la diferencia va la diferencia principal va a estar en que antes en en su tarea lo que ustedes hacían ustedes no diferenciaban a dejen Admito a alguien ustedes no diferenciaban entre cuando ustedes tenían el cuarto ustedes Tenían un proceso que seguir Entonces si un prisionero entraba a un cuarto y veía
(04:48) el interruptor encendido por ejemplo no hacía nada y lo veía apagado Entonces lo encendía y aquí no diferenciaban no todos los prisioneros hacían lo mismo nada más que había uno que que era el contador entonces básicamente acá Este lo que tienen que hacer eh de una forma no óptima y pueden empezar haciendo la forma no óptima para después pasar a optimizarlo pero básicamente lo que tienen que hacer es sí diferenciar eh los Cómo van a estar leyendo el prisionero normal y el prisionero contador para que si ustedes
(05:30) mantienen con esto y ustedes lo demuestran por inducción van a ver que al final no O sea eh si se quedan con ejecución esta ejecución no va a ser correcta para cualquier número de prisioneros para adaptar estea ejecución o para adaptar esta esta estrategia para cualquier número de prisioneros lo que tienen que hacer es diferenciar entre el prisionero normal y el prisionero contador primero van ustedes igual que en el anterior van a definir una ya sea on u off van a definir Cuál es la que va a representar que un prisionero acaba de pasar
(06:09) entonces imagínense que definimos que on significa que acaba de pasar un prisionero que no ha sido contado Entonces cuando entre el prisionero contador va a ha on va a contar más uno y lo va a pasar a off no bastante similar a lo que hacíamos anteriormente pero para que se cumpla la rectitud de este algoritmo lo que tienen que hacer es que este primero ustedes no saben si el interruptor está en on o está en off entonces ahí ya tenemos dos casos Si está en on ustedes no van a hacer nada porque un prisionero para
(06:49) empezar si lo veen on no hace nada porque significa que alguien más ya pasó Entonces no hace nada y luego si lo ve en off Se supone que lo tiene que prender a no entonces este caso demostrar pueden demostrar la igual tien que verif la primera vez para que se mantenga la contador entre dejen Admito alguien la primera vez que el prisionero e contador entre al cuarto lo que tiene que hacer antes se contaba a él mismo o sea contaba a él mismo y contaba a uno para que se mantenga la correctitud cuando no saben el estado
(07:46) inicial del interruptor lo que tienen que hacer es que la primera vez que el prisionero entra un cuarto nada más va a contar más uno por qué Por qué va a contar más uno nada más quién me dice porque va a contar más uno puedo repetir si ahí voy a ver Déjenme cambio a mi computadora para ya no tener que estar Cambiándome cuando Admito Denme un minuto va ahí voy Okay ya quedó Entonces vamos a repetir esta parte cuando ustedes o sea en en la parte anterior en la en su tarea lo que ustedes tenían era
(08:54) bueno pudieron haberlo hecho de varias formas Pero básicamente lo que ustedes tenían era que este tenían el prisionero y Tenían un cuarto Entonces ustedes definían eh si este cuarto este cuarto tenía un interruptor no Entonces ustedes definían que si el el interruptor por ejemplo estaba en off lo que iba a hacer era que este el prisionero lo prendía no entonces cada prisionero debe visitar el cuarto n veces o cada uno de los n al menos una vez Bueno ahí Ahí les va ahí ustedes no tienen ustedes no pueden determinar en su algoritmo eh Cuántas
(09:51) veces pasa ahí ya se lo dan se los dan en el problema eventualmente cada prisionero va a visitar el cuarto n veces esto le sirve principalmente para optimizarlo y para saber que eventualmente todos van a entrar no Entonces ustedes ahí tienen la garantía de que eventualmente todos van a entrar pero eh lo que ustedes van a hacer es que antes un prisionero entraba al cuarto no un prisionero normal y si lo veían no hacía nada nada y si lo veía en off lo prendía para determinar que había pasado alguien el ya hemos pasado todos es de haber
(10:33) pasado al menos una vez sí de haber pasado al menos una vez Entonces para mantener la correctitud lo único que tienen que hacer es y y entraba El prisionero contador y cuando lo veía en on contaba uno y si lo veí y lo pasaba off Entonces lo único que tienen que hacer para mantener la correctitud es determinar el caso o sea igual van a determinar que on es para uno ya pasó uno ya pasó Entonces el caso lo van a hacer por casos su demostración la van a hacer por casos Entonces el caso en la que el el interruptor haya estado en off
(11:23) pues va a mantener el mismo algoritmo va a pasar un prisionero lo va a prender eventualmente va a pasar el prisionero contador y va a determinar que uno ya pasó de forma correcta y lo hacen por inducción Si estuvo en on eh todos van a creer o sea nadie va a hacer cambios a al interruptor entonces para mantener la correctitud Y esto es muy importante tienen que hacer que el prisionero contador la primera vez que pase la primera vez solo cuente más un Porque si se dan cuenta eh el contador cuenta uno de más cuando es son Exacto el contador cuenta
(12:07) uno de más cuando es son entonces para esto la primera vez que el que el prisionero contador pase solo tiene que contar uno más O sea el mismo sí antes eh si ustedes no ponen esto significa que el prisionero contador va a estar contando dos va a estar contando a él mismo y va a estar contando a este a otro contador que no existe no porque el interruptor estaba en on entonces acá tienen que ver o sea tienen que tener tienen que agregarle una variable el prisionero contador para que sea el número de veces si pasó o sea si ya pasó
(12:51) una vez si no ha pasado entonces solo va a contar uno si ve el interruptor en on Y si ya pasó entonces significa que este ya puso ese interruptor en On A off y ya le dio este chance a los demás para poder actualizarlo Entonces si ya pasó y vuelve a ver que on es uno entonces ya va a seguir el proceso normal el proceso normal sí lo ven a ver creo que se trabó Sí sí estaba escribiendo dejen les vuelvo a compartir voy voy voy dejen les vuelvo a compartir a ver espérame un tantito mm
(14:03) pero hasta que sí lo van viendo o sea la única diferencia e que que tienen que considerar Es la primera vez que entra el prisionero contador y de ahí ya la demostración por inducción es básicamente la misma pero ahorita les vuelvo a compartir la pantalla ahí voy Sí ahorita lo vuelvo explicar También estaría bien Si en el caso de l si fueran dos prisioneros al llegar cuando el otro prisionero modifique el interruptor dos veces el contador sabe que ya se cumplió que el otro prisionero hizo sus dos modificaciones entonces
(14:52) Solo queda él y Por ende él también ya pasó no eh Sí pero lo que tú estás o sea creo que lo que lo estás viendo para cuando es que se bañó Y comió no y según yo nada más es para a ver dejen reviso Entonces sí O sea creo que no Para pasar Okay a ver bu ahorita Entonces estaría bien Ah sí En el caso de que sean dos prisioneros sí lo que y porende también ya pasó no paraos Y eso sería una optimización de
(15:57) de que tienen en o sea de la parte de solamente contarlo nada más sería una optimización esa parte ah voy espérenme es que no carga ya entonces entonces quieren que lo vuelva a explicar o ya más o menos rápido Okay entonces lo único que tienen que hacer es e O sea la diferencia es que va van a hacer exactamente lo mismo pero
(17:02) si est en off no pasa nada no pasa nada y lo pueden demostrar por Bueno de hecho lo tienen que demostrar por inducción si cumle que la cua dos en men1 Exacto Ajá Entonces qué pasó Se trabó Ah pues sí sí lo tienen que demostrar por inducción pero es rápido No se preocupen por inducción o sea rápido o sea nada más tienen que demostrar todo el algoritmo por inducción y ya quedó es rápido Entonces si es off no pasa nada no entonces el el sí sencillo no a ver sí demuéstrenlo bien pero si es off básicamente se mantiene la correctitud si es on Y
(18:02) entonces el prisionero el prisionero contador va a contar uno más no porque va a llegar y va a ver que alguien ya pasó pero alguien no ha pasado Así estaba desde el inicio no Entonces si nadie ha pasado y el prisionero llega y cuenta que alguien ya pasó va a erróneamente contar uno más entonces ahí ya no se cumple lo que pues lo que tenían que o sea el algoritmo no que que todos pasen de forma correcta Entonces cuando sea on lo que tienen que hacer es que el prisionero contador tiene que tener una variable extra que es el
(18:39) número de veces que ya pasó entonces o o un bulano no si no ha pasado entonces este nada más va a contar uno más que es el mismo o sea nada más va a considerar que él sí pasó no va a considerar que él y otro pasó y y si es número de veces si ya pasó lo va a contar normal la generalización de n mayor a 2 y los casos bases son cuando n = 1 y cuando n = 2 Sí bueno cuando n = 1 no Pero porque ya tienen o sea tienen esta parte de acá si nada más hay un prisionero entonces va a entrar el prisionero contador él no ha pasado entonces va a contar uno más Y
(19:24) va a estar correcto no Exacto es trivial entonces háganlo para cuando tiene tienen este dos prisioneros y ya quedó lo único que tienen que hacer es modificar o sea agregarle una variable con una variable al contador eh que sea un bulano del número o sea de si ya pasó si ya pasó eh lo va a ejecutar normal como lo tenían en su tarea si no ha pasado van a nada más va a contar a uno más no se va a contar a él y a otro nada más se va a contar a él va lo demuestran por inducción y ya quedó sí pero normalmente siempre cuenta + do no
(20:09) O sea bueno lo tienen que modificar para que nada más cuente uno más O sea Acuérdate que en el anterior contaba + do la primera vez que entraba pero o o lo hacían para que contara e n - 1 no O sea que cuando sea n -1 cuando el prisionero contara n - 1 eh dijera que ya estaban todos pero acá sí tienen que llegar a n el prisionero tiene que llegar a n el prisionero contador tiene que llegar a n y este cuando él pasó una vez nada más tiene que contar a uno que es el mismo o sea él nada más se cuenta a él mismo la
(20:47) primera vez y por eso eh la llamada de que ya están todos es cuando su contador es igual a n porque si lo mantienen en n-1 va a contar dos me explico va entonces eh considera la siguiente implementación de un candado para dos hilos F peterson eh cumple con exclusión mutua sí o no no no muy bien Por qué no porque los dos el caso que empiezan al mismo tiempo los muy bien sí Entonces ese ya lo tienen básicamente este no tiene la garantía tienen dos hilos a b Entonces si los dos empiezan al mismo tiempo los dos van a
(21:48) ver false entonces los dos van a ver false acá los dos van a sobreescribir la bandera los dos van a ver F acá los dos van a sobreescribir victim y van a entrar los dos alguien levantó la mano Exacto los dos pueden leer fals al mismo tiempo entonces ese ya lo tienen nada más muestran esa ejecución O sea la la explican esa ejecución y no cumple con exclusión mutua argumenten si cumple con deadlock free cumple con deadlock free Sí muy bien que no cumple con exclusión mutua no implica que este no cumpla con deadlock
(22:35) free Porque si se dan cuenta deadlock free lo que les dice es que un hilo bloquea a otro y acá un hilo no va a bloquear a otro porque no hay forma de que un hilo se quede infinitamente en un ciclo o imagínense que a está viendo que la bandera es true y b está por acá no O está por acá entonces B eventualmente tiene que seguir O sea no hay nada que lo impida porque a sigue en que la bandera es true Entonces el único que puede actualizar a la víctima a true es él Entonces él va a ver que la víctima es false va a pasar a true va a pasar al
(23:16) o sea va a obtener el candado va a pasar a unlock Y eso eventualmente va a hacer que a se se salga de ese ciclo Entonces igual lo demuestran por contradicción y ya quedó va sí okay muy bien entonces el siguiente otra generalización del algoritmo peterson además de filter consiste en asignar un candado peterson en cada noo de un árbol binario supon que n es una Potencia de dos n corresponde Ah este Está muy bonito n corresponde al número de hilos dos hilos se asignan en una hoja del árbol cada candado trata un hilo como hilo cero e
(24:04) hilo uno en el método de adquirir lock del árbol el hilo debe adquirir todos los candados desde la hoja hasta la raíz cuando deje el candado en lock debe dejar cada candado desde la raíz hasta las hojas consideren que en cualquier momento un hilo puede detenerse por un periodo finito de tiempo Okay este eh Está muy similar al que hicimos en su tarea eh lo representábamos en su tarea como un árbol binario de de altura uno pero aquí lo van a representar como o sea básicamente es una extensión entonces tienen un árbol
(24:46) así imagínense Y entonces par este cumple o no cumple con exclusión mutua y starvation free Sí por qué Por extensión de peterson Muy bien Entonces esto se cumple por extensión de peterson estos dos se cumplen por extensión de peterson y si se acuerdan de lo que hicimos en la tarea e el Double peterson creo que se llamaba no era justo entonces acá su inciso c les dice existe una Cota superior en el número de veces que un hilo puede ser aventajado argumenten Por qué existe Y esa extensión de peterson podemos solo
(25:45) explicarla a qu Okay entonces la extensión Sí sí la pueden explicar entonces que realmente qué ser aventajado o sea que que sí es justo o sea el hilo que un hilo a eh entre a la que un hilo a y un hilo B quieran entrar al lock al mismo tiempo y que un hilo a entre por ejemplo tres veces a la sección crítica antes que el hilo B exacto no es justo entonces eh que o sea la parte de ser aventajado está muy relacionado en en la justicia Porque si se dan cuenta cuando un algoritmo cuando un un lock es este justo significa que un hilo no puede ser
(26:35) aventajado por otro saben se mantiene la fila de cómo llegaron o como pidieron el lock si un hilo a ventaja a otro hilo significa que llegó después pero entró antes a la sección crítica Y eso significa que no es justo entonces aquí les están diciendo Bueno aquí ya están primero tienen que decir eh tienen que explicar por qué no es justo y se pueden basar en la tarea es bastante similar a como lo hicimos en la tarea porque su tarea del Double peterson era muy similar Bueno lo representamos y lo analizamos muy similar a un árbol binario de altura uno
(27:17) entonces acá eh básicamente tienen a los hilos y este acá eh van a tener al hilo a van a tener el hilo b y en todo entonces solo se cumple justicia entre dos hilos pero no se cumple justicia Global en todo el árbol Exacto Por qué es igual que como lo hicimos en la tarea anterior en su tarea no no me acuerdo qué tarea era pero es igual como lo hicimos en esa tarea del Double peterson e básicamente la O sea tienen que dar un un ejemplo de Por qué no se cumple que sea justo para que ustedes puedan decir que no es justo
(27:57) entonces imagínense que está así O sea nosotros lo hicimos así Creo Entonces está acá el hilo a el hilo B el hilo c el hilo d y acá en cada nodo hay Sí porque en los intermedios entre los salos de un candado al otro puede ser que se duerma y otro más los rebas Exacto Entonces Acá hay un lock muy bien Luis Acá hay otro lock entonces imagínense que o se era el doble peterson era como la raíz y los tres candados Exacto sí acuérdense que lo vimos como un tipo de árbol binario Entonces si lo ven eh estaban acá entonces imagínense que
(28:46) aquí ganaba b y que aquí ganaba d porque c no quería entrar entonces de aquí imagínense que ganaba d y b se quedaba y luego eh o se quedaba dormido en este lapso entonces d volví a hacer el unlock entraba c d volví a ganar este lock entraba acá b despertaba y ganaba de lock Entonces es lo mismo que tienen que hacer pero extendido para justificar que no es justo justificar que no es justo pero bueno entonces acá es lo mismo tienen que o sea una extensión de tien que ha una extensión de esto para justificar que no es Ajá para explicar
(29:34) que no es justo y considerando esto lo pueden hacer porque les dicen esto entonces tienen que argumentar que eh se puede cumplir e este tipo de ejecuciones porque el problema nos pide que consideremos que en cualquier momento un hilo puede detenerse por un periodo finito de tiempo sí Entonces es esto mismo es esto mismo de acá de cuando V se queda dormido Entonces si lo ven esto nada más lo tienen que argumentar para este para una generalización Y eso es lo primero que tienen que hacer para este inciso para el inciso c primero es
(30:16) argumentar porque no es justo porque no es justo Y eso implica que eh un hilo puede ser aventajado un hilo puede ser aventajado hasta ahí ya tienen eh ganancia No ya tienen un poco más de la mitad de lo que les pide ese inciso y ahora les está diciendo que si existe una Cota superior en el número de veces que un hilo puede ser aventajado e nada más tienen que o sea véanlo si existe una Cota superior aquí y de existir lo que tienen que hacer es generalizar de no existir También tienen que ser o sea generalizar aquí
(31:11) eh ver si existe o no la Cota superior entienden más o menos esta parte básicamente es imag Oye podemos ver nuevamente rápido el uno por los 10 cores que tiene el multiprocesador o solo consideramos el Speed por un solo Core del multiprocesador Okay sí vamos para allá Nada más terminamos esto y vamos para allá e este entonces Ah sí Entonces si les queda bien Esto de la Cota superior a la Cota superior se refiere que si existe Pues sí una Cota imagínense que tienen a y b No mucho okay imagínense que tienen acá por ejemplo en este vamos a verlo
(32:05) acá cada nodo acuérdense que tiene un lock vamos a poner así para que no ocupe tanto espacio entonces están compitiendo a y d entonces imagínense que a gana el lock y se pero se queda dormido sí se queda dormido entre que ganó el lock no hay Cota puede ser aventajado Sí pero lo tienen que o sea bueno de ahí ya a ver vamos a verlo en este ejemplo tienen que o sea tienen d y imagínense que d también ganó entonces d entra al lock pero a se queda dormido antes de entrar al lock entonces de gana el lock regresa se lo vuelve a
(32:57) ganar o sea vuelve a ganar este lock vuelve a pasar para acá y entonces regresa saben Entonces hasta aquí ya lo aventajo dos veces ahí voy entonces lo que tienen que revisar es si existe un número máximo donde un hilo a pueda O sea que un hilo a pueda rebasar máximo n veces a un hilo B eso es lo que tienen que ver va lo lo véanlo aquí es más fácil verlo en un árbol así y de ahí ya está muy fácil generalizar y en el punto dos que era lo que que generalizar starvation free Ah pues eso no que un hilo o sea que todos
(33:44) los hilos eventualmente van a poder entrar a la sección crítica que está por acá entonces Y si te das cuenta eso también es o sea viene directo de peterson porque cada nodo tiene peterson y como peterson les asegura que es starvation free y eso ya lo demostraron ustedes ya pueden suponer que peterson es estation free entonces en cada nodo eventualmente todos los hilos que pidan un un candado de un nodo van a poder obtenerlo Entonces si lo hacen para arriba o sea sin pérdida de generalidad eso para arriba Ah al dos del C Ah okay
(34:28) si existe o no la Cota superior eh si existe un número máximo de veces que un hilo a pueda rebasar un hilo B O sea por ejemplo acá d rebasado dos veces a a existe un número máximo de veces ponle no sé 100 o sea que un hilo a no pueda rebasar más de 100 veces a un hilo B entonces tienen que ver si existe un número n donde un hilo a puede rasar máximo n veces a un hilo B tienen que ver si existe o si no existe pues o sea Sí de hecho no no no tienen una una Cota superior per sé porque no saben cuánto tiempo o sea depende de del
(35:26) tiempo que a se va a quedar dormido porque cuando a despierte a va a estar en competencia con otro en este caso con d y cuando D lo gane ya se le van a acabar las veces que lo va a aventajar porque a va a ser el siguiente que lo gane Entonces sí no existe porque depende pero tienen que argumentar que depende justamente de O sea no depende del de la altura de su árbol binario más bien depende de este de cuánto tiempo se quede dormido el hilo a o el hilo que quiera entonces el uno Cuál era la pregunta el Speed se multiplica por los
(36:13) 10 cores que tiene el multiprocesador o solo consideramos el Speed por un solo call del multiprocesador okay Entonces compraron vamos a ponerlo en diferente color tienen un unipres que ejecut de 5 millones de instrucciones por segundo o un multiprocesador de 10 calles en donde cada procesador ejecuta un millón de operaciones por segundo entonces la pregunta viene en esta parte no si multiplicamos Ah de 10 sces es num op por Speed up Ah okay Entonces acá básicamente lo que no es número de operaciones por speedup no sí sí es número de operadores
(37:08) por Speed Ajá entonces son 10 sces por un millón de operaciones por segundo Sí sí básicamente pero si tienen que multiplicar los 10 por un millón de operaciones o sea son 10 millones de operaciones por por segundoo sí y nada más O sea consideren esta parte de de ser paralelizado para acá pero si es número de operadores por las 10 millones de operaciones en el caso del multiprocesador Más bien nada más consideren eh de cada Core ejecuta es uno voy a subir las notas por un No sí Según yo lo que tienen que hacer
(38:16) es o sea del uniproceso no tienen que hacer nada ya tienen los 5 millones de operaciones por segundo y de acá pues es que cada procesador ejecuta un millón de operaciones por segundo no entonces el Speed considera todos los hilos sí un millón de opciones No pues sí sí es cierto básica sí es cierto Entonces nada más tienen que comparar esto por con esto sí sí es un millón por Speed s es un millón por spe s s cierto Entonces entonces es mejor el nada más tiene que que revisar esa parte s y Ah bueno está fácil no el C
(39:28) este lo vemos o no lo vemos no está fácil siguiente y creo una ejecución de un registro que sea regular que no sea linealiza y que no sea consistente en la actividad es solo poner el orden Total no En cuál En el anterior pues es dar una linealización nada más considerar que este se empalma con este que se empalma con este y tienen que dar la O sea su historia y su historia completa para completar este de acá y ya quedó Qué es que no sea consistente en en la actividad en la inactividad creo que se refería O sea que no sea consistente en
(40:16) la inactividad y que no sea linealiza ahí nada más hagan lo de atrás para adelante o sea hagan la linealización de atrás para adelante bueno la no linealiza O sea la ejecución de de su de su historia Eh así de atrás para adelante y ya quedó estos están fáciles no Ah si al final de la ejecución a continuación el arreglo a Table es el siguiente la ejecución corresponde a la implementación del snapshot weit free entonces tienen a Table a Table B a Table C de Okay entonces Este es de este este es de este y este es de
(41:03) este Entonces por A qué se refiere en la inactividad que no sea consistente en la inactividad O sea tienen su historia así Ah o sea por ejemplo en esta el periodo de inactividad bueno imagínense que el periodo de inactividad sea este de acá que no sea consistente en la inactividad significa que eh para que tenga sentido estos de acá tienen que violar la inactividad O sea para que haga sentido imagínense que este Vamos a ponerle este tenga que estar hasta acá cuando viola el periodo de inactividad significa que no es
(41:45) consistente en la inactividad Entonces nada más lo tienen que hacer de atrás para adelante y ya quedó o sea Ajá segú Según yo es inactividad porque le voy a preguntar a la maestra y les aviseo va si es actividad No creo que se actividad pero si no O sea le pregunto a la maestra y si no le subo una unos ejemplos de esto para que de ahí se puedan basar va pero yo digo que es in actividad y esta parte del snapshot entonces la ejecución corresponde a la implementación del snapshot fre esos snaps A qué momentos corresponden a
(42:48) cuando se hacen los updates al final de al final de la ejecución o sea hasta acá aquí cuando terminen de hacer todos los scan y todos los updates Entonces al final este tiene que ser a Lu tiene que ser a b Ah bueno pues este los es no hacen nada en no no hacen nada nada más lo van actualizando Pues básicamente nada más tienen que revisar los momentos acuérdense que es linealiza no el snapshot Entonces lo único que tienen que hacer es revisar estos porque esto S como dice Eduardo y lo único que hacen es o sea los sc no
(43:47) le hacen nada a la Table nada más la obtienen entonces lo que hacen o sea lo que modifica la es el update cuenta como update o sea weit free en general es linealiza y en específico eh los updates e o sea estos van a ser linealiza bles Entonces lo único que tienen que hacer para la Table es revisar o sea revisar la linealización saben Entonces por ejemplo este entró primero que este pero están están empalmados Entonces si ustedes ponen que el update B se realizó antes que el update a para que la a Table fuera así realmente este
(44:39) lo pueden hacer por la linealiza iliza entonces lo que tienen que argumentar para esta parte de acá Todo todo su argumento se tiene que basar en la lía alisaba eh Y por ejemplo en este para que el su atbo sea así significa que el update de B fue antes que el update de a sí se puede salir así básicamente pero lo tienen que argumentar todo por la linealización e porque el update B acuérdense O sea que el update para que este Snap o sea para que esta atable sea como viene en en su ejercicio tiene que pasar que el
(45:24) update B haya sido que el update a entonces tienen que revisar sin nada más componer los puntos de linealización Ajá sí argumenten esa parte de los puntos de linealización y ya quedó entonces y este está así entonces nada más tienen que revisar que sí haga sentido al ser linealiza y ya quedó realmente es es una argumento sencillo no pero sí se tienen que basar bastante en la lineal estabilización va tienen dudas hasta [Música] acá no seguros Okay de todo el examen ya acabó Ah no
(46:32) falta en la implementación no si la arreglo de registros siendo linealiza o no Ah bueno aquí si lo tienen que aquí si lo tienen que pensar un poquito más porque tienen que cambiar o sea tiene que ver en qué partes afecta que los registros sean regulares y no atómicos porque acuérdense que la diferencia entre o sea los atómicos son bastante más seguros que los regulares no entonces aquí nada más tienen que revisar En qué afecta o sea en qué líneas afecta y este de ahí sí puede ser linealiza o no Acuérdense que los
(47:14) registros regulares bueno Acuérdense que los registros regulares pueden dar e todos los valores concurrentes no y el registro atómico en los do según yo Ajá pero bueno seas se tienen que basar bastante en que los registros regulares pueden dar cualquier valor entre todos los valores concurrentes y los registros atómicos nada más dan el último actualizado entonces tienen que ver en qué afecta que se O sea que regresen cualquiera de los valores concurrentes en vez de que regrese el el útimo valor actualizado Y
(47:58) si eso afecta la laliz abila y el el argumento para ver si afecta la linealización o no e es en qué partes del código le pega y este que los registros regulares O sea la definición de registros regulares por o sea por sus salidas concurrentes no que nada más cuando cuando hay escrituras concurrentes es cuando pasa que que es menos seguro que los atómicos entonces de aquí o sea de esas dos partes argumentan si sigue siendo linealiza o no y ya quedó va Sí más o menos Sí este se o sea para argumentar si sigue siendo linealiza o no tienen que basarse
(49:00) en la definición de registros regulares y eh basado en la definición de registros regulares ver en qué líneas del código eh afecta esto o el cambio de registros atómicos a registros regulares porque acuérdense que los registros regulares eh lo que hacen O sea la diferencia entre los registros regulares y los atómicos la diferencia fuerte se da la diferencia fuerte referencia más grande se da con se da en las escrituras concurrentes Entonces si se da en las escrituras concurrentes eh o sea cuando cuando ustedes están
(49:50) teniendo escrituras concurrentes con registros regulares los registros regulares les pueden regresar cuál quiera cualquier valor de esas escrituras concurrentes Y este los atómicos les dan el último actualizado entonces basado en que la diferencia está en las escrituras concurrentes e el Snap es el que se afecta porque lo que ve en el código es que lo que se guarda el Snap sí Exacto el Snap es el que usa atómicos muy bien entonces e Sí y la diferencia de de los o sea lo que va a afectar justamente es Snap porque cuando ustedes
(50:35) tienen o sea en la en Normal tienen que van a tener el último actualizado todos estos son sus últimos actualizados últimos actualizados pero cuando ustedes o sea cambiándolo a registros regulares lo que tienen es que son quiera de las escrituras concurrentes o de los updates concurrentes pero acá lo importante es que es concurrente entonces Eh sí afecta los Snap y afecta en las escrituras concurrentes entonces basado en esas dos cosas es o sea ustedes ya pueden ver si es linealiza si se mantiene que sea linealiza o que
(51:30) no sea linealiza y ya nada más con estos dos acá no lo tienen que demostrar tan formalmente pero con estos dos ya pueden argumentar si se mantiene o no se mantiene y ya con estos dos el regular puede ver anterior a los concurrentes si el regular puede ver e de de todos los que tienen de i o sea tienen varios registros puede ver desde I hasta acá pero I empieza en cero hasta acá es la última concurrente Entonces sí puede ver uno anterior a los concurrentes o sea tienen sus eh sus escrituras concurrentes puede ver
(52:12) el anterior a todas esas escrituras concurrentes Entonces sí tomarlo en cuenta nada más esto O sea los argumentos son estos dos y ya con eso les queda o sea le sale automático si sigue siendo linealiza o no va tienen dudas hasta acá dudas hasta acá Eduardo ya más o menos sí va todos bien okay Entonces ya ya les queda bonito su examen
(53:22) no sí sí Yo digo que sí va si tiene Cualquier duda me mandan mensaje les parece o no les parece sí va pues mucha suerte eh argumenten bonito examen les va a ir muy bien y cuídense mucho va Cualquier duda me avisan va cuídense mucho Bye an [Música]
