(6) Clase 53 2024 10 11 - YouTube
https://www.youtube.com/watch?v=0H6Jc43hZ30

Transcript:
(00:01) para que él pueda actualizar un valor todo lo que tiene que recorrer no y luego este otro y así no O sea entonces este depende un montón de cada este de cada arquitectura no O sea cada arquitectura peculiar arquitectura primero cómo está esto puesto no O sea por ejemplo seb tiene 24 ahora sí que quién sabe Cuántos procesadores tenga y cuántos scs en cada procesador no este y por ejemplo e Ah bueno es eso y ya luego El fabricante debe El fabricante es el que decide no fabricante decide los algoritmos los cuales un por ejemplo un gide
(01:05) eh del Core un viaja no a la ram por ejemplo es todo un algoritmo no y el coro otro y así O sea este bueno sea algoritmos de Cómo viajar en la ram y luego este no sé de Cómo escribir en sus cachés o sea es todo un una máquina o sea imagínense todo lo que hay acá no este y bueno lo que se suele usar acá es este consistencia secuencial o otra que se llama total otra consistencia que se llama tso que es total order una cosa así total order algo así total order Pero bueno son más débiles que la analiz habilidad no entonces depende un
(01:56) montón aquí porque por ejemplo en en nuestro por en los en el MS mcs qué hacemos pues estamos dando vueltas en nuestro propio memoria no O sea Todo bien todo bien pero este yo me imagino que estamos dando vueltas en la propia memoria de thad local porque al final esa memoria es visible para los demás no no es como que estemos este en el cachaca sino que estamos en la llava virtual Machine dando vueltas en trl o sea cada uno tiene su TR local aquí no entonces todo el mundo está dando vueltas aquí y entonces La idea es que en el en
(02:39) el mss un hilo este escribe en el TR local del otro Y entonces ese ese esa actualización debe viajar no hasta el Core Entonces yo creo que ahí lo que pasa es que se sobresatura o sea como todo todo el tiempo los hilos es están leyendo de la Java virtual Machine o sea cada uno en su memoria tres local no pero pues al final están leyendo aquí al momento de que se actualiza este de acá ya no les llega Por qué Porque hay mucha contención ya aquí en el bus no O sea ya no pasa nada es como una red No ya todos en el Foro Sol este en la
(03:22) misma en la misma antena pues ya valimos no demasiada contención pero sí depende de la arquitectura O sea hay arquitecturas que están diseñadas y no sé tal vez ryen este es que es la diferencia no O sea a veces uno compra compus pues Ah no pues entre más tenga mejor pero pues sí a veces también depende del fabricante de cómo de los algoritmos que utiliz para acoplar todo el sistema no O sea no es tan fácil como ponerle simplemente otro otro este otro cor no Entonces sí yo creo que de ahí de ahí viene la O sea el
(03:57) problema pero o sea pues nada más está ahí no si yo viendo imaginándome pero bueno ustedes también repórtenlo no si no ojalá este lo reportan y pues este argumentan Por qué no yo creo que les digo está en una situación de contención O sea ya no se actualiza porque se supone que estos están totalmente así probados O sea hasta hay una comparación no los prueban que para 1 lilos y o sea pero hacen cl para probarlos y este Vale entonces bueno no nosotros no andamos en esta parte de de cachés y bueno yo ni siquiera ya ya me vi yo ando
(04:40) más bien este y en las pruebas usan slips eh No pero este por ejemplo ponen a correr este Bueno todavía no las vemos Pero bueno ubican en Java en Java tenemos toda la la Ajá en Java tenemos toda la la paquetería concurrente no la útil concurrente Entonces ven que tenemos listas concurrentes cuas concurrentes este Hash Hash Maps concurrentes pues hagan de cuenta que en las pruebas utilizan estos objetos Porque estos objetos que están implementados en Java son algoritmos famosos o sea que ya se implementaron entonces utilizan estos sal como Ah pues
(05:28) vamos a hacer y la actualización es de una lista Este y pues un algoritmo famoso concurrente y eso es lo que hac pero yo quería como este como que no meternos tanto en eso o sea como usar otras implementaciones y ver o sea como yo pensé como para estandarizar los slips pero si los prueban con nada más ejecutando las listas o colas pero pues les digo algoritmos famosos que ya se probaron y este y Bueno es es el que yo he visto pero sí yo creo que o sea debería funcionar con tareas más largas por eso yro dije ah puis segundos no debería
(06:12) estar mal pero eso es demasiado entonces bueno vi que varios no le salió hubo al algunos además de Melisa le salió también a Víctor creo este y también se tardó bastante pero sí terminó pero sí depende nuestros de nuestras compus okay Bueno nos habíamos quedado en Ah sí yo les había comentado bueno que habíamos visto la clase anterior este habíamos visto todo esto [Música] bueno hemos concluido no que Este Ay se ve mucho no todo los que se escribe pero buenoa teorema no habíamos dicho que era imposible que una implementación we free
(07:12) de un objeto de nn asignación para a partir de registros atómicos Por qué Porque mostramos un protocolo de consenso que sí resuelve aquí no el protocolo de consenso que resuelve el consenso para dos hilos utilizando este objeto Este y pues sí O sea como que la pregunta sería Oye podemos construir un objeto una bloqueante este aign no y o sea solamente utilizando volátil los registros atómicos y la respuesta era no porque sí existe un protocolo de consenso para dos hilos no O sea de ahí va así como que así es la
(07:47) computabilidad en este mundo de memoria compartida y entonces habíamos visto que pues bueno sí podemos implementar un Snapchat atómico que son lecturas atómicas pero no podemos implementar un objeto de asignación múltiple que son escrituras atómicas eso habíamos visto y que eso implicaba que teníamos más poder o sea que pues escribir requería más poder que leer no Y pues sí es en el mundo como que es lógico no este Bueno o sea como que siento no que es Es lógico Eso sí es está en el mundo no concurrente sí siempre escribir
(08:25) requiere más Eh entonces bueno ya en conclusión Pues yo les había comentado que no todo pues no podemos resolver todo con volatil no a veces ocupamos más poder y que pues por eso ocupamos la la paquetería atomic que son todo este grupo de operaciones las primitivas y bueno habíamos visto una forma de caracterizarlas simplemente haciendo que todas fueran objetos de ritmo modifi Eh entonces es como así no es este read modify y write no es así los tres pasos y todas se podían caracterizar de esa forma todas leen un valor viejo bueno
(09:12) excepto Conan set No sí vamos a revisarla parte uno de la tarea Ah yo creo que 20 minutos antes Ahorita que acabé Este bueno ahorita voy Ajá sí sí O sea no sí voy a s me va a dar tiempo este Entonces todos los objetos todos tenían un valor Entonces yo les había comentado que en Java es un atomic atomic integer atomic son así un valor que va a ser modificado por inserte la primitiva no hacías lees el valor viejo le haces algo es el valor y regresas al valor viejo todas tratan de eso y aquí teníamos este podemos caracterizarlas con
(10:08) funciones les había comentado que hasa Rito podía ser caracterizada de esa forma simplemente pues re escribes que es lo mismo no escribes nada nuevo y quiere decir que que este que pues es una función identidad porque se rescribe lo mismo este que se leyó entonces todas las demás eran funciones distintas a la identidad por ejemplo get pues era una función constante simplemente entras queriendo escribir un valor nuevo lees el valor viejo regresas el valor Viejo pero mientras ya Escribiste el nuevo así funciona y también
(10:47) get este est pues cambiaba el valor por más un y bueno Muchos ya la usaron en cont luego este de acá Este el valor más a ya así O sea ent la función se caracterizaba por esta fmaa y habíamos visto Ah y esta última comper no que es la que sí cambia o sea como que ya s se ve distinta es un valor esperado el valor actualizar entonces este La idea es que tú vas a cambiarlo o sea se va a quedar igual no x va x pero solamente si este x es distinto Ah y si no va a ser u no este se bueno va a valer 1 x entonces este habíamos visto que todos los
(11:43) registros Bueno cualquier registro que implemente alguna de estas primitivas este y que sea no trivial tener el número de consenso de al menos dos cualquiera y bueno habíamos visto que para que seas eh No trivial no este no deberías este tener una función identidad en él o sea que r Pues que tiene una función identidad pues no no ese no tiene un número de consenso igual a dos pero todos los demás sí no eh getan set getan increment getan todos las funciones son distintas no a la identidad y bueno Cómo probamos esto Ahí
(12:25) está tu protocolo de concepa para dos hilos no o sea es la prueba para probar que al menos dos eso eso habíamos puesto este y Y cómo funcionaba simplemente era este tienes el valor actual no sea el valor inicial entonces tú modificas haces un no sé tananan increment en este caso yo había tomado un get Y pues el valor inicial era false el valor inicial era false yo lo cambiaba true Y entonces si el valor anterior es false quiere decir que yo fui el primero en modificarlo pero si es true quiere decir que alguien ya me ganó
(13:11) y así o sea es como es como en la cola no quien lo haga primero gana y tú sabes que ganas porque pues ya este el valor cambió no O sea sabes que ganas porque pues en la cola no obtuviste luz no pues ya ni modo sabes que ganas y sabes que ganó el otro Y en este caso aquí también sabes que ganas porque ya el valor es es este o sea el valor sabes que leíste el valor viejo inicial no y este y también sabes que pierdes porque pues ya no lo leíste no se No leíste fal sin no true y y te consta que si no ganas Gan el otro para
(13:50) dos hilos y yo les había comentado que este que de hecho todas las que tengan características en las que se conmuta o se sobreescribe todas tienen un número de consenso de Exactamente igual a dos al menos dos aún más este duro no O sea igual a dos justo Entonces yo les había comentado que por ejemplo get lo que hace pues sobreescribe no O sea este por ejemplo no si si hacemos primero un get de un valor no y luego hacemos un getan otro valor enseguida y y las dos La idea es cambiarlo a false No pues al final va quedar false pero
(14:39) también va a ser lo mismo si lo haces al revés no y va a ser lo mismo si lo haces nada más así va a ser lo mismo si nada más haces como esto no al final va a quedar false escrito no Esa esa es lo sobre escritura y conmutar por ejemplo Quién conota creo que increment no Ajá sí sí sí que vale lo mismo siempre y cuando s le pase conmutar no getan increment con muta an increment no get an increment se se ejecuta simplemente así entonces este si por ejemplo el valor inicialmente es cero no da lo mismo Sí se hace Bueno voy a ponerlo
(15:47) así si se hace por ejemplo un getan increment no este y otro get increment a no o si se hace al revés no da lo mismo al final si es cero es la idea de estas Vale entonces por ejemplo en este punto en este punto ya cuando se ejecutaron los dos este punto vale lo mismo no ay no escribí lo mismo Disculpa quería poner as no se así así no en ese punto vale lo mismo o sea no importa si se ejecuta primero a o b en ese punto todo va a valer igual
(16:52) entonces quiere decir que conmutan o sea si ambas este funciones es si dos hilos o n hilos o lo que sea hacen 10 no hacen 10 getan incremento en total pues al final siempre vamos a tener 10 no no no va a haber como ahy no este qué habrá pasado no O sea algo cambió no por el orden en el que se ejecuta No cambia nada No por qué componer la función con b igual a true F la función Por qué componer la función con v cuál Ah ya ya Ah o sea que inicialmente inicialmente V vale false No Ah pero V vale true Vale entonces este entonces inicialmente O sea a lo
(17:53) que se refiere Esto bueno es que inicialmente pues Vale true no Y si f1 y FJ son dos funciones que quieren cambiar el valor a false no digamos que lo que va a quedar o sea lo que lo que queda escrito en v es es esto no O sea no lo que regresan sino lo que queda escrito en v o si era eso sí o bueno has de cuenta que si inicialmente tenemos un estas líneas son las que no entiendo esas líneas las que puse escrito en v
(19:03) las dificultades no estar en Bueno haz de cuenta que V es inicialmente un buano no es un atomic bu F Ah sí digamos que aquí como vimos que todas las o sea podemos expresar todas las primitivas en funciones Vale entonces en realidad pues lo que tenemos es un conjunto de funciones y podemos caracterizarlas a todas por ejemplo eh la función de getan set no este podía ser caracterizada como una función este de X a algo constante no bueno a una constante voy a ponerlo así a Ajá entonces La idea es que y bueno como por ejemplo acá no todas pueden ser
(20:04) caracterizadas de esta forma Entonces ya en el análisis lo que dicen es miren tenemos un conjunto de funciones y si estas funciones no este e tienen la propiedad de que si este o sea ahora sí que como funci es que esto dicho como de forma concurrente se puede expresar de esta forma o sea por ejemplo en este caso si decimos que esta es una función y no Y esta es una función J entonces en el mundo de las funciones esto quedaría expresado de esta forma no como que f i FJ modificaron el valor V no así se expresa Vale entonces Pero bueno o sea
(20:55) para no hacerlos bolas este Bueno o sea para para como que dejar así un poquito claro esto el el o sea el que en el o sea te hablen de funciones y te escriban esto no Pues sí pues estamos hablando de funciones no como que pues el valor lo modificó la función FJ y ya ese valor modificado lo modificó la función fi no y pues si se dan cuenta es lo mismo decir que inicialmente tenemos el valor del del registro por ejemplo en v no Y entonces si se le aplica un get un registro atomic boolean no atomic boolean y se se le aplica la función
(21:38) primera no que es la de a se le aplica no sé un get an increment pues va a quedar de una forma no Y entonces en este punto pues va a quedar de una forma y luego a este punto va a llegar la función de del hilo B no que es FJ y lo va a aplicar vale o sea como que eso representa entonces este cuando nos dicen que una función conmuta no es que lo que nos están diciendo es que da igual si primero la función FJ modifica v y después fi o si F modifica f o si fi modifica v y luego FJ o sea como que es lo que nos dic no que va a dar lo mismo
(22:19) siempre vamos a obtener lo mismo no Y sobreescribe también nos dicen algo así nos dicen al final el valor si a ejecuta primero no s haciendo FJ y luego B ejecuta después haciendo fi no va a dar lo mismo que si solo a se hubiera movido o si solo B se hubiera movido Entonces es como que o sea está fea la matemática lo sé pero es como una forma de para poder meterlas a todas no en esta bolsa y este y entonces ya ustedes se encuentran en Java no y dicen esto Qué significa esta función no es es no sé una nueva que que vean Ay mira
(22:58) incrementa no esotra Y ustedes van a ver Bueno qué es lo que hace y ya se van a dar cuenta Ah pues sobreescribe no este bueno perdón esa sería conmuta est está conmuta no se van a dar cuenta van a decir Ah mira quiere decir que es poderosa sí es más poderosa que un registro atómico Sí pero solamente puede resolver el consenso para dos hilos porque conmuta vale o sea Pero bueno o sea más o menos y Ajá que puso No entendí que da lo mismo el valor aplicarlo solo a fi Ajá sí por ejemplo si si nosotros hacemos este copia mejor está escribir
(24:06) Ah por ejemplo no este este caso Cómo se vería este sería así no Y tenemos al hilo a y al hilo B Entonces nosotros vamos a decir que que a a le gusta ser fi y a FJ no Entonces en este caso si vamos hacer un get set no este este sería aquí qui se mu primero primero B FJ que es un get de fse vale eso es eso es FJ y luego se mueve con su fi y es también de Entonces el valor al final no V va a valer aquí false no era true inicialmente y va a valer false luego este otro si analizamos este otro de acá Bueno este de
(25:11) acá sería lo mismo no Nada más que pues esta este antes y esta después no Entonces teníamos a y b no este sería igual solo que pues ahora a se ejecuta primero con su fi y ahora FJ después no y el valor al final va a ser igual V va a valer false ya vieron y luego este sería solo a solito no a solito Qué va a ser pues a solito nada más va a decir un fi no fi que es un getan set este va va a valer false no Y si se dan cuenta si analizamos aquí le hacemos un get a Pues resulta que también vale false no Entonces es lo que lo que nos
(26:03) quieren decir que en la sobreescritura pues va a dar igual No de hecho este si si se mueve primero FJ y luego fi va a ser lo mismo que si solo se hubiera movido F no Por qué Porque solo se sobreescribe O sea ya lo que está escrito pues ya en en v pues ya ya quedó no y Solamente vamos a ver lo último que se escribió en este caso F y que solo lo hizo a no que es un getan Z vale Ah dice Ah yo creí que cambiaba el valor pero como los dos quieren cambiar false Ajá Exacto Pues sí O sea al final qued fs no Ajá tenemos la misma función en
(26:54) ambas en ambas En cuáles en ambas ejecución Ah bueno sea como que Ah bueno Sí en a y en B No si ambos quieren hacer un get false no Aunque si se dan cuenta aquí lo que nos dicen es que si O sea que que independientemente de lo que valga cada uno no si siempre al final se mueve a va a ser indistinguible o sea bueno va a ser Va a tener el mismo valor si al final se mueve a no no importa lo que se haya movido antes como getan set lo que hace es que sobreescribe no O sea pues va a escribir en el registro Pues siempre el valor no que del parámetro
(27:35) entonces aquí nos dicen es que no importa si lo que valga B si al final se mueve a O sea si F se mueve al final entonces va a ser igual a que pues si nada más se haya movido no O sea si si por ejemplo como aquí tenemos mismas funciones Pero qué tal si en vez de que valga true Bueno Este vale true no en vez de que valga false vale true si se dan cuenta aquí nos dicen no que quién va a ser igual F fi no Entonces nos va a decir que estas dos son iguales no pensando que este ahora modifica true no Y si analizamos estas dos Pues
(28:19) sí O sea al final va a valer false siempre no porque se movió al final Vale entonces lo que nos dicen se es como la matemática no creen pero Ajá sí pero sí es como que la matemática está así como de qué o sea estamos viendo ejecuciones y luego me pones funciones no bueno Sí ajá el chistes que hace el último no sobre sobreescribe pues ha es el último y con muta este pues no importa no con muta es así como acá no este eh si si tenemos 10 hilos y todos hacen un getan increment este se cumple la propiedad de conmutar
(29:06) Porque si hacen los 10 un getan increment pues nada más el contador va a valer 10 no pero siempre el valor de B va a ser el mismo por eso conmutan vale entonces es es la idea de las dos entonces lo que nos dicen es todas las que pertenezcan a esta clase este valen exactamente uno Perdón valen exactamente dos no O sea solamente un protocolo de consenso para dos y no más y entonces pues ya como se imaginan no este como ya lo vimos en los registros Y tenemos este árbol no que inicialmente este pues vale tiene un estado bivalente
(29:43) crítico no Entonces si suponemos que inicialmente V vale true por ejemplo no y de este lado a se mueve y de este lado B se mueve no entonces en esta ejecución si ya se mueve primero y hace un un getan set de false y luego B se mueve y hace un getan set este con false pues al final el valor va a ser false no en v no va a haber de otra No va a ser lo último que se escribió y de este lado también si solo se mueve b y b hace un quean set de false No pues al final va a valer false y luego si llega un hilo c este c no en las dos casos pues se va a
(30:25) ver que al final se decidió lo mismo no O se va a decir Bueno y este Yo solo veo que vale false pero yo qué hago No yo como sé o sea yo tal vez no s se va a decir pues yo sé que perdí No pero quién ganó este no O sea Cómo sé si hace movió antes que b o si solamente se movió b y b ganó Vale entonces c dice no pues para mí estos dos estados pues no les no encuentro yo información para distinguirlos no O sea para mí son indistinguibles y se queda con esta pregunta no O sea se movió antes a o B Se movió solito entonces es la idea cuando se
(31:10) sobreescribe pero si se dan cuenta también cuando conmuta no este sucede Tenemos el mismo problema porque si por ejemplo tú hacen 10 y losan increment al final el el valor no de cer pasa a 10 y el siguiente ahí lo va a decir bueno sí es 10 pero quién se movió primero no O se es como este o sea la matemática no para demostrar esto pero pues se puede este platicar no O sea pero si se dan cuenta este cuando sobre escribimos o cuando este cuando mamos es indistinguible para el siguiente hilo o sea el que o sea Pues digamos que el
(31:53) hilo el que gana Pues sabe que ganó pero eh los siguientes Cómo sabemos Quién ganó no quién de todos los anteriores si el valor ya se sobreescribi o si al final este si ya se movieron tres pues sabemos que se movieron tres pero chingan no no sé este entonces comper Anet es un Este es un bueno comper es la única que no tiene las propiedades Ajá sí Camilo con eso basta con eso basta sí no no O sea bueno por ejemplo pues nada más Yo te mostraría esta no y este y pues para o sea digamos que la esta Pues sería que no se
(32:36) sobreescribe pero tampoco conmuta no O sea pues el ejemplo cuando conmuta y ya pues eso sería la demostración pero si no hay más casos o sea esto esto representa todo Sí porque pues como es binario solamente tenemos dos hilos no y los dos hilos que pueden hacer pues simplemente hacer un una función que que sobre escriba como get set y pues hasta les puedes poner valores distintos no que uno escriba getan set true y otro escriba get set de false no y ya sí pero si no se necesita más para demostrar que no existe un protocolo para tres o sea
(33:16) digamos que tenemos al hilo a al hilo b y al hilo c no y C pues no no lo va a lograr no no vas a ver si ganó a o si ganó b y ya con eso demostramos no que no existe un protocolo de consenso para tres hilos Claro que si quieres demostrar que si existe un protocolo de consenso para no s dos hilos pues entonces pones tu protocolo de consenso es la prueba aquí está un ejemplo no Vale entonces este get set si y bueno un registro que que provea get Perdón comp y get tiene número de consenso infinito no O sea que resuelve el consenso para
(34:01) los hilos que sea y bueno Cómo no Pues resulta que este protocolo funciona de esta forma tenemos el valor de tenemos un este un atómico entero vale o sea value Pues digamos que al inicio pues es First no Entonces estamos aquí First bueno que es igual a -1 vale Y entonces para decidir Tenemos también nuestro arreglo propose claro y ahora pues tenemos un montón de hilos no ya no solamente dos ahora tenemos este el hilo cero el hilo un el hilo dos hilos y hasta no sé n no n hilos Tenemos muchos este Sí entonces eh en el en la línea seis tomas el ID no
(35:04) por ejemplo suponiendo que todos tienen ids de de cer a n vale todos tenemos ID de cer0 a n entonces en la línea si lo que haces es un comparan set sabes que el valor inicial es First no y lo quieres cambiar por tu ID entonces este suponiendo no que tenemos un montón de hilos aquí así No pues ahora sí tenemos un montón No solo dos no Entonces tenemos a b c Z Y entonces todos Ejecutan de Sid así imagínense más o menos por ahí no de y bueno entonces es este no sé a quisiera que se decidiera a no B quiere b y este quiere c y este quiere Z no
(35:58) entonces bueno Todos aquí están luchando por por decidir Pero quién va a ganar pues el que haga el comper set primero todos saben que vale First O sea que es menos uno pero suponiendo no que Ah pues tiene el ID tiene ID no es cero este el uno este el el dos y este no sé el en no entonces La idea es que pues quién haga primero el comparan set compare and set con sabe que el valor inicial es First y lo va a cambiar a miid en este caso cero no entonces quien haga primero ese ese comper set lo va a lograr entonces hay que notar que este
(36:45) Conference set solo va a regresar true si Eh pues este el valor no Bueno cómo pongo bueno sí Si el registro vale First no O sea si realmente es First Pues sí yo gané no y qué quiere decir que yo fui el primero pero por ejemplo si acá Este el iloc no hace un comper set é está escribiendo First Pero él va a poner su ID dos y él obtiene false Pues porque pues ya lo cambiaron no se el valor de First ahora ya no vale Este menos un No ahora va a valer este cer no porque ya ganó bueno supongamos que este hizo el comp acá y
(37:38) este acá pero puesan entonces este va a regresar false y pues quiere decir que no modificó no modifica el registro no O sea quiere decir comp solo modificas y regresa a true Ajá sí O sea solamente Entonces si esta si esta línea de aquí es que no sabe si esta línea de aquí es true quiere decir que ganaste y quiere decir que lo pudiste modificar no entonces casi que les dejaste la huella no así tomen o sea yo como de yo lo modifiqué y dejé mi ID no Entonces si es así pues yo gané y yo regreso lo que yo propuse y si no voy a regresar lo que
(38:27) propuso pues el que ganó simplemente Leo el registro no y ahí está o sea literal solamente se va a quedar en el registro el que ganó Vale entonces por eso se resuelve el consenso para un número infinito este porque solamente el que hace primero el comper set es el que puede modificar el registro todos los demás no lo van a lograr Porque todos este esperan que el valor o el valor esperado que tienen es que pues es First no entonces ya pues saben que perd per dieron y y además saben que perdieron Pero saben quién es quién ganó el que
(39:02) puso su ID en el registro El que realmente pudo modificar este r no en este caso el registro r Vale entonces como Bueno ya vieron Qué tal o sea como compan está bonito no bueno y ahora vamos ya al a la tarea que les digo siento que bueno esta parte de la tarea es la como más pesada ya lo que viene este no no me parece que esté tan pesado pero bueno está Sí este tiene su tiene su truco no pero les toca revisar este les toca revisar a detalle Dónde está aquí
(40:06) está si les toca revisar a detalle lo que hemos visto para rec contestarlo O sea no es algo como que sea pues siento que muy nuevo no pero este en este primer ejercicio dice supon que tenemos una implementación de una cola fifo pero muy importante modificada vale Cómo modificada Pues bueno ahora tenemos los métodos en que de siempre pero tenemos un método que se llama pic Vale y pic Aquí está aquí se los puse Entonces vamos a tenemos nuestra Cola modificada y esta Cola en cada ndo vamos a encapsular el valor del elemento que va
(40:45) a ser pues un entero un bolean así pues un elemento no se es lo que vale la cola pero Además vamos a encapsular un ID que inicialmente vamos a ver que es es este menos un Vale inicialmente pues el es men1 Y entonces todos los hilos Bueno ahí me faltó especificar más todos los hilos tienen Y pues de cero al número de hilos no este los hilos tienen sus ID de c a n no sea el número n hilos Entonces el método p en qué consiste Pues el método p va a devolver el primer elemento de la cola o sea va a ser un un Head este Head get no es lo
(41:37) que va a devolver va a leer Así lo que a lo que apunta Head va a devolver el primer elemento de la cola sin embargo lo a diferencia deq lo que va a hacer este p es que no lo elimina solamente lo lee y ya entonces no existe o sea supongamos que en esta cola no existen deq Vale entonces este método pic además solamente este va va a leer el primer este elemento no de get si muy importante si este el ID si el ID es igual a -1 Y qué va a ser Va a ser un comper Anet y va a cambiar el ID de men1 O sea si es así no por su
(42:28) ID entonces este si se dan cuenta solo va a regresar este true no O sea Solamente vamos a obtener este Head solamente si pudimos Modificar el ID de Pues de de la cola Noa el primer elemento y este y si no pues vamos a regresar nul no O sea si no lo logramos pues regresamos nul en comparet no se modifica el valor No nada más digamos que lo leses no este o sea bueno se modifica solamente el ID Vale pero no el valor solamente es el id Vale entonces este este sería no modifica el ID no este muy importante fse entonces quiere decir que no lo
(43:26) modificó no y este y pues quiere decir que que alguien más ya lo hizo no Y si es true Pues sí yo lo modifiqué no O sea el hilo este que hizo el comparet y va a regresar Vale entonces as así funciona este método p no hay deq sol solo hay p entonces este pic simplemente lo que hace es que lee el primer elemento de la cola pero solo lo lee si puedo modificar el ID si no nada más dice nul Vale entonces este eh este la idea no es Mostrar que esta cola modificada tiene un número de consenso infinito si se dan cuenta la
(44:22) razón de que tenga un número de consenso infinito pues es porque en realidad izamos conferen no porque conferen tiene un número de consenso infinito No porque las colas Ya vimos que pues no pero pues aquí está como que tiene truco este pues sí porque pues p tiene comper set entonces para mostrar que esta cola tiene un número de consenso infinito Pues solo deben crear un protocolo de consenso utilizando esta cola para un número infinito de hilos utilizando esta cola modificada este considerando e Bueno o sea y escríbanla como
(44:59) pseudocódigo o como quieran vale o sea o como por ejemplo este pseudocódigo no e entonces pues sí O sea como que en realidad tendrían que ver no O sea tomen tomen en cuenta el protocolo de consenso de una cola que vimos en clase y pues qué sucede si en vez de un dq Pues ahora ponemos un pic no y este y consideren que pueden leer el inicio también de la cola no O sea este o sea que podemos leer el ID pero bueno eso se lo se los escribo porque sí me faltó escribir eso o sea además de la cola podemos leer el ID de al que
(45:48) apunta no con eh Head Eh bueno supongamos que así no id. get Vale entonces es es eso cómo lo ven más o menos se se toman toman el protocolo de la cola dicen miren Ajá sí truculento sí O sea toman toman el protocolo sí similar no no cam Pero si te das cuenta aquí pues ya como que pues está cómo est la modificación no sea nada más tienen que trabajar como de si p regresa este el elemento no Head punto o sea pues un elemento no se también dice no pues el valor inicial de la cola es este es un buano es este Win No si Si
(46:47) regresa este Win pues quiere decir que yo fui el primero pero si regresa nul pues ya perdí Y entonces este eh Como acá no en el protocolo de consenso entonces dices No pues voy a leer RG No pero en este caso leíamos un get no el get punto id. get Y entonces regresas el valor propuesto no pero pues del lo que ganó y si no regresas O sea si si si perdiste no y si no regresas tu propio valor Ajá a ver si hg es que depende la primitiva pero sí considera que sí si es que este si Lu me falta especificar más
(47:53) no los los pras entonces he sí consideremos no que regresa todo el nodo no que es el valor y el ID vale se los escribo ahí en el se Lo agrego vale como instrucción Ah ahí para que no si tienes razón para especificar esto no porque si no pues sí podría ser que ya no ocupes get No simplemente le es el valor ID de ya lo que regresaste no este Bueno pero no Bueno sí considera así vale o sea digamos que si obtienes un nodo pues ya ganaste no Pero si tuviste noo No ganaste y acá si es así pues al final s vas a ocupar esto
(48:48) no get pun get no y ya de ahí no más pues tomas el ID vale Pero bueno o sea no lo vamos no lo estamos implementando así porque cuando utilizamos hay atómicas que encapsulan valores y referencias entonces este Pero bueno eso lo vamos a ver después pero sí por el momento solo dej en lo expresado vale Si no pues como seudocódigo así como de Bueno pues aquí estoy leyendo el ID no porque pues no lo estamos programando así tal cual vale Bueno eso es el primer ejercicio y el segundo este es demostrar que una pila eh tiene un número de consenso de
(49:35) Exactamente igual a dos y la típica pila no tiene un método Push y tiene un método Pop el Push pues añade x al inicio y el pop elimina el primer elemento no de este de la de la pila en este caso entonces pues bueno ya sabemos que la pila está con con una q no pues en el mismo nivel los dos ti el número de consenso igual a dos pero pues digamos que tienen que pues escribirlo no O sea casi que pues es revisar lo que sucedió con la cola pero para hacerlo con la pila Entonces este pues hay que revisar Cómo cómo cómo
(50:13) probamos esto para la cola pues primero para probar que tiene un número de al menos dos deb debemos demostrar no que existe un protocolo de consenso para dos hilos Pues tiene un protocolo de este Perdón un un número de consenso de al menos dos no Y además después decir exactamente dos por qué porque porque no es posible que existe un protocolo para tres hilos no y ya de ahí eran los estos estados No ese y nos movemos a este estado y este otro estado no Entonces es esa es la idea Este otro es muy para que revisen las notas no y el libro también
(50:51) si quieren este que les acomode más y y este entonces cómo lo ven esa es la tarea este la primera parte No la segunda Pues es lo que nos falta ver pero pues por el paro no me dio tiempo ya está las notas en el classroom Ajá Sí este ya le subí la presentación pero le subo las notas vale pero alguna duda alguna duda H ahorita sí si s hoy la sub Vale pues bueno no hay más dudas nos vemos Que tengan un bonito fin Ah bueno y yo no voy a estar la siguiente semana este que que les vaya bien pero buenoa cualquier cosa me
(51:44) escriben no también dudas Sí gracias
