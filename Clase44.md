(6) 2024 10 03 14 02 18 - YouTube
https://www.youtube.com/watch?v=hWVIv64BfJY

Transcript:
(00:00) al Hola hola Cómo están qué tal Qué tal el paro Bueno digo cómo les F descansaron estuvieron yendo o haciendo tareas Bien bien y t este
(01:14) Sebastián Cómo les fue en el paro si pudieron descansar o estuvieron allá activamente si Estuvo largo no bueno s lo sentí sí no y ya las tareas que habían se quedaron s Yo también este puede descansar dejen comparto pantalla H
(02:20) [Música] este primero vamos a ver bueno esta práctica Este siento que es la realidad siento es la más sencilla Esa es la primera eh H es la más sencilla e que no tienen que hacer Pues en realidad nada O sea no tienen que implementar nada solo Vamos a probar Cómo funcionan ciertos algoritmos en la práctica Eh entonces este Déjenme abro de una vez esperen Déjenme mando
(03:29) la la práctica Aquí está miren digo no que esta esta siento que está pues sencillo en el el sentido que no pues o sea por ejemplo la otra no eh les mando a implementar algo o a que este pues así fueron la dos y la tres no la idea es que ustedes crearan algo aquí no hay que crear nada porque pues en realidad ya es difícil este o sea si ustedes crearan un spinlock nuevo este literal esce su tesis no Y y hasta sería publicable pues ya tendrían que demostrar que funciona y así O sea pues son así difíciles no este de de de crear entonces por eso
(04:32) nada más nosotros vemos otras implementaciones ya hechas este entonces de eso consiste esta práctica entonces este contexto No hasta ahorita habíamos visto candados exclusión m la práctica un este pues fue intro la dos vimos usar candados como synchronized este el O sea ya candados que ya trae hechos Java literal nosotros usamos las herramientas y ya está la práctica tres este ustedes crear un algoritmo para cuatro hilos no el Double peterson y vieron Cómo funcionaba el bery pero pues también tiene su chiste implementarlo
(05:24) entonces este lo pusieron en la práctica y eso quiere decir que en la práctica dos ustedes crearon sus propios candados O sea si ya no los tuviera implementados no importa ustedes crean sus propios candados y este garantizan exclusión mutua e entonces en el mundo de los candados ya en la parte práctica vamos a ver que en realidad pues hay dos tipos que dos opciones grandes en candados la primera es este similar a los que hemos visto La idea es esperar activ mi lapicito aquí está la idea es esperar activamente entonces qué sucede si no
(06:10) pudimos obtener el candado no O sea ponemos a correr 64 hilos por ejemplo no y si no pudimos obtener el candado no importa hay que esperar este dónde en un ciclo Wild no en todos damos damos vueltas en este ciclo eso sucedía con peterson bery y con filter todos esperábamos en un eh Y la otra opción es pedirle al sistema operativo que agende otro hilo que te avisen es más que te agende otro y tú te vas a hacer otras cosas y mientras que te avisen cuándo es que voy a poder obtener el candado y este y a este tipo de algoritmos de candados les
(06:51) conocemos como monitores este los monitores los vamos a ver ya en la última práctica junto con el consenso Pero bueno en realidad es son los monitores e o sea bueno la idea de esa práctica va a ser que implementen un monitor pero este y vamos a utilizar el consenso ahí para hacer algo algo bonito pero bueno entonces vamos a ver después pero la idea de un monitor simplemente es eso no lo pude obtener Pues bueno voy meto una weight así se llama no le digo al sistema operativo este que me avise me avise hasta que se cumpla
(07:30) una condición es decir que me avise por ejemplo hasta que Eh pues ya salga el hil lo que estaba ocupando la sección crítica Y entonces lo vuelvo a intentar y si no lo vuelvo a obtener Ay pues que me vuelva a avisar y yo mientras me voy a hacer otra cosa es muy muy útil No cuando este pues no sé en un sistema operativo imagínense no ni modo que que todos nuestros hilos estén ahí dándole vueltas no sé en en un en no s en el adop illustrator no o en el adop así O sea o en su juego no no importa no si esos no se ocupan en
(08:05) ese momento se van y regresan y así entonces tipos de de monitores el candado reentrante de hecho es un monitor ya el que está implementado en Java e y de hecho en el libro viene una forma de cómo hacer tu propio candado reentrante pero bueno eso lo vamos a ver de hecho después del tema de consenso lo vamos a ver en la teoría y Ya lo vamos a implementar en la práctica este también el objeto count down count down slch este de aquí que alguien ya lo utilizó en su práctica y lo utilizó para este que que le avisaran cuá todos los
(08:47) hilos habían terminado de hacer las tareas o sea por ejemplo lo utilizaron en vez de utilizar los futures o en vez este de darle tiempo usaron un cont launch que pues este les permitió e este saber cuándo habían terminado todos los hilos entonces para eso es este hilo es este algoritmo y también los semáforos son monitores es un tipo de monitor porque este Bueno sí O sea tienes que esperar a que se cumpla una condición qué condición que alguno de los tres hilos Por ejemplo si el semáforo es de tres no que alguno de los
(09:27) tres hilos salga Y entonces vuelves a int Pues también los semáforos son de este estilo este Pero bueno en esta práctica nos vamos a enfocar en los primeritos en estos de aquí eh Entonces estos candados les vamos a conocer como los Spin locks muy mucho así de o sea literal se llaman Spin no de spinear de que están dando vueltas activamente en algún punto entonces quiere decir que eh estamos poniendo nuestros hilos a que estén gastando ciclos del procesador hasta que logren entonces Pues digamos que ahí todos están
(10:07) calentando a nuestra conu no porque están todos tratando tratando de de entrar no O sea ahora sí que como todos peleándose por un boletón en Ticket Master no O sea todos dando dando vueltas dando vueltas no ahí tratando de entrar Entonces qué sucede cuando cuando tenemos varios hilos que están dando vueltas sobre una tratando de entrar Pues bueno tenemos eh se hace se hace contención no O sea tenemos un problema de contención entonces eh Déjenme ver acá es que yo tenía también la presentación Ah sí pero nos la tengo
(10:44) hasta aquí sigo acá Okay entonces qué sucede cuando Tenemos muchos hilos esperando activamente surge un problema de contención entonces eh esta contención consiste en que bueno ocurre cuando múltiples siglos intentan acceder a un candado al mismo tiempo entonces eh Hablamos de una contención alta o sea Tenemos muchos muchos hilos y una contención Baja pues solo algunos no O se cuatro hilitos tratan de obtener el camb pues es una contención baja cuatro hilos no son muchos pero qué tal que es Ticket Master y somos un millón de
(11:21) personas ahí es un problema no Entonces por qué es un problema porque todos estamos ocupando ciclos de procesador y estamos Este y ese programa no O sea por ejemplo la variable While en el que perdón el la línea While y la variable en la que estamos por ejemplo una bandera no todos estamos dando vueltas sobre esa misma bandera imagínense el bus de comunicación abajo o sea este porque pues al final abajo tenemos una arquitectura de computadora entonces imagínense Cómo la cantidad de mensajes que hay ahí no O sea esta cañón Entonces
(11:55) ya en la práctica eh en la en la teoría este pues vimos algoritmos muy bonitos no peterson backery filter así no muy bonitos pero en la práctica hay que lidiar con esta contención si se dan cuenta hasta ahorita no hemos pensado en eso en la contención solamente nos hemos enfocado en que hoy se cumple exón mutua sí se cumple Dead look free sí no se cumple starvation free justicia solo eso pero en la práctica este pues no sé Ticket Master no va a poner un candado horrendo como como no sé el de El el que hicimos el Double peterson por ejemplo
(12:32) no nos dice Ah Pues quiero un millón de hilos Pues nos va a tener que tocar hacer este eh poner poner un millón este un millón de de candaditos no de peterson no imagínense Qué locura entonces La idea es que ya en aplicaciones donde te importa la escalabilidad Pues necesitas lidiar con contención es por eso que ya en la práctica Pues sí cambia un poquito entonces otra situación es que lo vamos a ver después en la práctica Perdón en la teoría con Bueno nos atrasamos un poquito no este en la teoría pero es justo lo que estamos viendo las
(13:13) primitivas la jerarquía pero bueno o sea les adelanto es imposible crear candados eficientes para que funcionen para para cualquier número de hilos o sea un número infinito de hilos sin operaciones primitivas más poderosas que que que los registros atómicos entonces las primitivas como ustedes este estudiaron en su el final de la práctica tres ustedes revisaron de En qué consistía comper set y En qué consistía get no este y vieron que estas operaciones lo que hacen es que hacen un conjunto de operaciones en un solo punto
(13:51) y están en el hardware no entonces este estas operaciones son indivisibles y e Hasta ahorita los algoritmos que que tenemos que son piterson filter y Bakery Pues si se dan cuenta no utilizan estas operaciones primitivas o sea solo solo utilizan volátil no solo ocupan registros atómicos pero para hacer candados más eficientes ocupamos estas primitivas no podemos hacerlo sin ellas e y Bueno es es un ejemplo al final por ejemplo de de del ejercicio TR de la práctica anterior en donde pues queremos justicia Sí pero
(14:33) para tener justicia ocupamos ordenar a los hilos no entonces ocupamos una primitiva que es compan set y también get e entonces en esta práctica vamos a ver ejemplos de estos Spin locks que las utilizan y este y pues sí no son son más poderosas que volátil o sea es una herramienta de sincronización más poderosa que volátil porque volátil sabíamos que son nada más registros atómicos de lectura escritura entonces eh También ojo no no podemos utilizar los candados de synchronized no este nada así porque la idea es que
(15:12) estamos creando candados no sea de modo que utilicemos candados para carer candados pues no no y ya simplemente en la teoría es lo que les comento aquí pues vamos a ver por qué comper set es más poderosa que testan no y por test es más que que simplemente utilizar volátil no escrituras y lecturas volátiles porque es más poderosa Entonces ya en resumen Aquí les pong pero ahorita vamos a verlos a detalle estos algoritmos Porque la idea es esa que entiendan Por qué este o sea Cómo afecta o sea cómo programamos en el mundo concurrente
(15:56) afecta demasiado bueno también el mundo secuencial no pero acá como tenemos por ejemplo en este caso que lidiar con la contención afecta mucho como declaramos las cosas el orden de las instrucciones este entonces En general todos nuestros nuestros candados van a utilizar testet este si todos utilizan este y algunos utilizan estos dos van a utilizar compet compet entonces este y y vamos a ver un algoritmo que utiliza una ventana de tiempo estos esta ventana es similar a un algoritmo de redes este esta ventana de tiempo
(16:44) Simplemente nos dice este no lograste obtener el candado pues espera esta ventana de tiempo no s 30 segundos Perdón 30 segundos para aliviar la contención y no pudiste volverlo obtener Ah bueno pues ahora amplía la ventana y ahora espera el doble no y ahora espera el triple y ahora espera el cuádruple y así entonces se va aliviando la contención y permites que el sistema pues no se vuelva terriblemente lento no porque haces que los hilos como que se vayan tantito y luego lo vuelvan a intentar Pero bueno es es en resumen
(17:18) Pero ahorita lo vemos este ahorita vemos los códigos Entonces como Les comento no O sea en esta práctica Pues no hay que inventar Nada nuevo solamente este vamos a vamos a ejecutar el programa Run Spin para completar esta tabla vamos a comparar estos estos Spin locks estos y ya este es el candado reentrante de Java que bueno también ahorita lo vemos ahí nada más así este compararlo todos estos có funcionan no con algo ya implementado de Java y Este es un contador atómico Que varios de hechos se adelantaron Pero bueno es esa
(18:03) no era la idea de las otras prácticas la idea no era usar atomic pero también para compararlo o sea cómo cómo es si si utilizamos directamente get an increment en el candado Perdón en el contador en vez de utilizar un candado como como estos spinlock como estos de acá Vale entonces ahorita vamos a ver cómo funcionan estos códigos y este La idea es que prueben los candados para este 400 tareas con cuatro hilitos no 1000 tareas con cuatro hilitos ahorita van a ver la tarea pues simplemente es este aumentar en uno el
(18:38) contador e y este y en este van a utilizar el máximo número de H los de su compu menos un vale Para que veamos la diferencia Porque si cambia el ustedes ya analizaron lo del no Entonces el troup varios me habían comentado en la tarea de qué depende el troup Bueno pues sí del número de hilos no de de de equivalente a los cores de tu compo este ahora es el número de hil Los Reales Pues también depende de este la longitud de la tarea no que se haga entonces eh vamos a vamos a analizar no porque ahora sí que no no existe como vamos a
(19:32) ver que no va a existir el spinlock más increíble el que se debería usar por siempre no sea no no existe eso simplemente existen varias implementaciones y dependiendo Qué tipo de sistema tengamos es si usamos uno u otro si si tenemos pocos hilos pues probablemente con estos dos nos baste pero si tenemos no sé un millón de hilos no O 64 O 100 hilos 1 hilos pues probablemente nos funcionen más estos de acá Entonces es es y también no si la tarea es muy larga pues probablemente nos funcione esta si es muy corta nos
(20:03) funcionen estos entonces para eso es la la esta tablita Vale entonces La idea es que todos prueben este todos los integrantes de del equipo prueben todos los programas para que también ustedes puedan ver esa comparación porque hay personas que tienen compus increíbles no de 24 hilos ellos o sea ustedes van a estar así como ser más divertida esta práctica siento no O sea este para ver realmente este más hilos no eh peleando por contención porque pues imagínense cuatro hilos en contención es nada no pero 24 ya es algo y 64 No se
(20:43) diga no O sea Pero bueno Ah yo tengo una compu con 64 hos bueno no no yo no pero tengo acceso a una y este Ajá sí está cool no Y también vamos a ver ahí cómo ocurren eh también les comenté este quien si alguien si alguien tiene una compu de cuatro hilos O sea si si y en su equipo hay al menos dos con compus de cuatro hilos me escriben para que les dé acceso a la de 64 porque siento que como que no este Eh pues no no van a ver como mucho No o sea es que es muy distinto si solo tienen cuatro hilos la realidad es que
(21:25) estos primeros dos son los que funcionan bien pero para cuatro los estos otros es como mucho poder para muy poquito Entonces no se va a ver como gran diferencia de hecho estos van a ser lentísimo para cuatro hilos Este Entonces si alguien tiene bueno Y si algún integrante tiene una compu con solo cuatro hilos Pues solamente realizan el ejercicio uno porque el dos este La idea es que lo ejecuten este bueno hagan lo mismo pero ahora cambien le pongan como un slip al contador o sea para que se tarde 2000 milisegundos o
(22:05) sea para ver qué sucede cuando se tarda un poquito más y es que los que tienen cuatro hilos como que va a estar medio chafa entonces O sea no se va a ver mucho eh Pero los demás integrantes Sí o sea eh deben hacer los dos ejercicios y también Les comento no si Existen dos o más integrantes del equipo que tengan una compu de solo cuatro hilos Me comentan y también Me comentan este el tercero el tercer integrante Cuántos s los tiene porque si sí tiene bien poquitos pues mejor les doy acceso a la e64 si tiene una compu así O sea si el
(22:37) tercer integrante tiene una compo no sé de qué es bueno 12 hilos Pues bueno no estaría decente pero si tienen menos mejor este Me comentan y ya lo hacen este los corren de forma remota a ver entonces eso es y al final nada más deben contestar pues la implementación cuál implementación resultó más rápida del primer ejercicio del segundo y argumentar por qu se qué creen que se debe y Bueno ahorita vamos a analizar los códigos para que puedan contestar Esto Ah también en qué escenario no te conviene utilizar un contador no
(23:19) bloqueante atómico que un contador sin consistencia con un Spin loock lock entonces ahorita vamos a ver no contador no bloqueante atómico pues simplemente es este pues que tiene Counter que es un atomic integer integer este y se modifica Counter con increment and get Porque si nosotros utilizamos esto nuestro contador ya tiene consistencia no es un contador linealiza por qué Porque esta operación es indivisible este Entonces es la pregunta si nos conviene más utilizar algo así o nos conviene utilizar este un contador
(24:11) Pues normal como in Counter no se un entero y nada más lo aumentas este con más más No y Pero esto le tienes que poner un lock un candadito porque eso no tiene consistencia entonces como que es pregunta Como qué nos conviene más esto o esto otro y este ah también Al final que cuál es implementaciones satisfacen justicia Vale entonces vamos a las [Música] implementaciones Entonces el primer ahorita es que estoy en mi en mi en mi tablet ahorita vamos a los códigos códigos vale pero están igual o sea Ahí si no cambia nada este
(25:02) entonces pero aquí me gusta para por si tengo que dibujar o así siento que es más fácil aquí en la tablet entonces testan set de forma sobre un atomic Ban sobre un atomic escribo en rojo aquí sobre un atomic bullan consiste en que reemplaza el valor de la variable con true y devuelve el anterior entonces quiere decir que si se hace un State no State en este caso pues es el es el bullan no State inicialmente está en falso Entonces si se hace un State este ah y bueno Y aquí testan set es igual que getan set vale es que lo encuentran
(25:53) distinto pero son igual o sea nada más está escrito a veces distinto pero Son son este igualitas y este entonces lo que se hace aquí es que haces un eh Bueno voy a ponerle get no get and setet lo cambias a true pues qué hace esto te va a devolver este falso Sí el anterior era falso No pero si ya alguien lo modificó te va a volver te va a devolver verdadero entonces la idea de este candado es que e para tomar el candado simplemente consiste ya vieron de esta línea solamente es un While entonces este While te vas a
(26:42) quedar Este ahí si est truno si este eem el result no del getan set true es true este esperas Y cuándo va a pasar esto e esperas sí Ay no Les compartí la presentación bueno rato se las comparto espera Sí este alguien ya obtuvo false no es decir si alguien ya lo modificó primero eh Ya lo modificó y en cambio no si el resultado
(27:47) del getan set es false si gastr es false quiere decir que eres el primero en modificar este State no en modificar esta variable State quiere decir que eres el primero Entonces como eres el primero este Esto va a ser false y vas a obtener el candado y entras a la sección crítica entonces en la línea seis y s lo que haces es que eh dejas el candado Y qué haces lo cambias a false no O sea haces un set un set es una modificación atómica a a State lo cambias a falso para que así alguien más pueda cambiar en la línea cuatro el estado a a falso
(28:47) otra vez no sea está Ah perdón a a verdadero no Y él obtenga falso o sea como que va a ser el primero que lo modifique y entra la sección crítica y mientras los que no ganaron pues les va a salir continuamente true true true true true true no entonces van a estar dando vueltas ahí en ese W es similar Pero bueno ya vieron qué eficiente no Bueno o sea qué fácil una línea eh y solamente set es más rápido que get set set solamente es una minuto aquí set es una escritura atómica vale son distintos set es una escritura atómica
(29:38) set simplemente escribe false este en State y el get lo que hace es que escribe true pero te regresa este el valor anterior o sea son distintas son operaciones distintas vale Pero me imagino que escritura atómica es más rápida que que que getan set no getan set es lees el valor anterior escribes el valor nuevo y regresas el valor anterior eso es getan eso en una operación indivisible vale Sí entonces ese es el primerito el el este el test set loock no así se llama Aunque les digo no testan Z es lo mismo que getan Z son
(30:32) equivalentes este así luego el siguiente candado que vamos a probar es el es el doble t el doble t tanet este Déjenme ver si tengo Ah bueno ya escribí ahí me voy a esta que está más limpia Entonces el siguiente candadito es este este de acá y ual tenemos un atómico buano Vale entonces inicialmente está en falso lo que va a hacer es que en la línea 4 Bueno voy voy a empezar de la línea 5 en la línea 5 nos vamos a quedar dando vueltas si este si el valor de State ya fue modificado modificado a true Vale entonces nos vamos a quedar
(31:38) vueltas ahí si ya o desde antes no ya ni siquiera intentamos este y get que es get es una lectura atómica vale una lectura atómica o sea solamente leemos pero leemos de forma atómica entonces este si es true pues ya ni lo intentamos nos vamos a quedar ahí dando vueltas en la línea cinco hasta que pues alguien nos lo cambia falso no hasta que alguien deje el candado Entonces si alguien deja el candado Entonces vamos a ir a pelearnos con todos los hilos que estamos ahí esperando a que dejen el candado en la línea seis no nos vamos a pelear
(32:21) Entonces vamos a decir Este lo lo mismito del anterior si si este es distinto no de de este si bueno sí Si es Déjenme lo escribo así porque luego siento que no se ve Sí si el resultado del getan set es falso entonces Salgo no porque sale el return Y entonces Salgo de este ciclo While vale Y al contrario si el resultado no del getan set es verdadero
(33:29) entonces Este voy a la línea 4atro de nuevo no entonces vuelvo acá y otra vez Doy vueltas en la línea cinco este leyendo de forma atómica este que pues e que este que ya está en true O sea que alguien más tiene el candado y digamos que la línea se lo que pasa es es como que la idea de este dado es e como que aquí mientras a mientras este alguien tenga el candado espero en línea cinco si lo dejan con por él no Qué puede pasar si
(34:35) gano es falso o sea saco falso y termino y si pierdo saco true y vuelvo a comenzar no Y entonces vuelvo a comenzar y así y otra vez y así me la voy a pasar no Pero si se dan cuenta ahora tenemos dos wils no es como un Wi en otro Wild este igual para dejar el candado decimos false no O sea alguien lo vuelve a poner en false y empieza otra vez la pelea por el candado entonces teóricamente O sea si lo analizamos de forma teórica pues ambos si se dan cuenta bueno así como u no viéndolo así este a grandes rasgos pues ambos cumplen con exclusión mutua
(35:21) por qué porque solamente como la operación es atómica indivisible solamente va a haber un hilo que cambiar de false a true no solamente va a haber uno entonces solamente va a haber uno que va a obtener false se cumple exclusión mutu sí este lo vemos así y de hecho ambos son muy muy este Aquí no aquí Los vemos pues son muy idénticos no O sea ambos consisten en que tú vas a pasar si sales si sacas fs como que Qué diferencia habría haber bueno en la práctica es mucho más rápido testan set cuando Se incrementa el número de hilos
(36:03) miren aquí tenemos esta este esquem si el número de hilos aumenta no este testan set como que se mantiene no aumenta tampoco este en el tiempo pero el que solo o sea el doble testan set no y el y el solo testan set este este crece de forma exponencial no eh entre más y los le pongas peor se vuelve exponencial e y bueno este también es exponencial pero eh mucho Bueno pero maneja mejor la contención Vale entonces este este maneja mejor la contención no no no ahorita vamos a ver otros este no y les digo sea en realidad
(37:06) no es el candado no existe candado ideal porque por ejemplo este de estos dos Pues sí podemos ver que el doble testan set es mejor y hasta en poquitos hilos no como que van muy juntitos pero el testan set el doble testan set sí es mejor no O sea igual incluso con poquitos hilos responde un poquito mejor pero imagínense que este si si tengo si tengo poquitos hilos pues es distinto no no nos importa pero si tengo muchos de estos dos nos va a gustar el doble testan set no pero aquí también tenemos que pensar si nos piden
(37:47) justicia no Por ejemplo si en el Ticket Master Este estamos comprando nuestro boleto y no hay justicia entonces alguien que llegó después te va a ganar no Y eso no no se vale Bueno o sea entonces dependiendo la la aplicación no como qué queremos queremos justicia Porque si queremos justicia Estos no son nuestros candados no hay justicia ya vienen o sea puede ser que alguien le ganen repetidamente no y no y O sea que salga que esté dando vueltas ahí en el ciclo y siempre le ganen siempre le ganen entonces este
(38:24) eh es es Es entonces Bueno vamos a que este de acá el doble test es mejor maneja mejor la contención y bueno ustedes se preguntan o sea por qué no este por por qué maneja mejor la contención si son Pues realmente iguales no Y entonces este est de acá la maneja mejor la contención no el testan porque este digamos que e Cuando hacemos Cuando hacemos un un un get y ponemos a los hilos a dar vueltas en la línea cinco hacemos que se lea de forma atómica la variable State no Entonces al leerla de forma atómica este estamos dando vueltas no
(39:26) eh la leemos e y la revisamos Bueno o sea comprobamos y comprobamos el Wi de forma local no o sea estamos dando vueltas en nuestra propia este en en nuestra propia memoria comprobando que sigue siendo get Vale entonces ya este es el paso pesado porque si se dan cuenta lo que hace un getan set Es que hace una escritura o sea hace una lectura hace una lectura y luego hace una escritura bueno Déjenme escribo así set no entonces entonces lo que hace este getan es que pues Lee no
(40:37) lee le valor viejo actualiza y regresa a valor viejo es lo que hace el getan set no entonces imagínense esto lo que representa a nivel de caché a nivel de caché tenemos un bus Este Entonces tenemos aquí hilo uno hilo dos no hilo n Tenemos un montón de hilos Entonces en este bus imagínense hacer un getan set lo que representa a diferencia de simplemente leer no leer pues simplemente este la variable no se di aquí Y en este bus va hacia acá no va hacia acá hacia acá Este Entonces este es muy distinto
(41:42) solamente hacer un get a hacer un getan set porque quiere decir que un getan set vamos a ir a modificar esta variable y regresar no entonces imagínense que todos los siglos hacen eso al mismo tiempo lo que la diferencia de estos dos en a nivel práctico Es que este digamos que aquí permitimos que en la línea cco que se esté dando vueltas como que de forma local y simplemente estamos leyendo no de forma local comprobando este gu sin embargo Cuando hacemos la línea se es es lo pesado porque nos tenemos que pelear con todos
(42:18) para hacer un getan set sobre una variable compartida o sea modificarla ya no Y eso representa más si y es la diferencia entre estos en este nos la pasamos modificando la variable o sea imagínense Qué pesado no todo el tiempo modificamos esta variable todo el tiempo todo el tiempo y acá No acá te dicen bueno puedes estar un rato este espineando solamente leyendo una variable compartida no la modifiques y ahora sí cuando tengas la certeza de que de que puedes Ahora sí la modificas no entonces este es la diferencia vale o se
(42:54) es como es eso ya así haciendo un zoom en lo que pas abajo eh de Por qué es más eficiente que parecen igualitos Pero por eso es más eficiente usar el el doble test set Vale entonces Bueno vamos a ver eso ahorita este ya que lo lo pongamos a correr luego tenemos este otro algoritmo que es el backof Back of lock este este lo que hace Es igualito Utiliza también una variable que es un atomic buan un buan atómico que otra vez vamos a modificarlo ya vieron aquí está la mismita forma tenemos el gu este damos vueltas en leyendo de forma local
(43:39) la variable State luego Ahora sí la modificamos Cuando tenemos la certeza de que dejaron el candado pero si no lo pudimos obtener Esto es lo que cambia esta línea si no pudistes obtener el candado este antes de que vuelvas a dar vueltas aquí Entonces vamos a escribirlo no si no pudiste obtener el candado este entonces Bueno antes de ir a la línea oo a dar vueltas no un tiempo un intervalo mejor intervalo y cómo es ese intervalo pues miren es esta ventanita de tiempo vamos a tener el tiempo mínimo que van a
(44:43) esperar y el tiempo máximo que van a esperar y en eso vamos a inicializar no este nuestro bos el el el tiempo mínimo que podemos esperar el máximo y este y el límite hasta el momento y este límite va a ir aumentando de forma cuadrática aumenta de forma cuadrática Este Entonces ya cuando se hace se ejecuta backof lo que haces es que eh tomas o sea un número aleatorio para pero que no pase de Límite eh cuando tienes muchos este hilos
(45:48) Eh bueno igual o sea este este es est es ineficiente cuando tienes poco pocos hilos porque imagínense no O sea este que tenemos aquí los hilitos no Entonces por ejemplo tenemos este este intervalo este otro entonces imagínense que solamente tenemos a los hilos a b c y que solamente Ay estos no ganaron no s este se extiende en el tiempo y también no entonces imagínense que que obtuvo el candado no a ganó Bueno aquí es es lock lo acabó de ejecutar No pues aquí ganó ejecuta su sección crítica y lo vuelve a dejar no
(46:52) onl entonces este lo vuelve a dejar Pero estos están aquí en el backof O sea no no no despiertan están ahí durmiendo y ya pueden tomarlo pero no lo toman Entonces cuando tenemos poquitos hilos tener una ventana de tiempo no es muy eficiente pero si tenemos varios no de o sea bastantes 64 por ejemplo ahí sí va va a ser bueno este y sobre todo si la tarea se tarda un poco no O sea si si la tarea no es tan rápida si no dejan el candado tan rápido Pues está super bien se alivia la contención muy bien Este Entonces ese es otro ejemplo eh
(47:33) luego los otros dos caditos que tenemos este espérenme un momentito Entonces los otros candados que tenemos son este este Son son son justos vale es es el ch lock eh Ajá s el ch lock vamos a ver también el mcs lock este otro y este Ay finalmente vamos a ver este el aloc Entonces estos tres candaditos lo que van a hacer es formar a los hilos muy parecido a como hice el algoritmo de Bakery este Pero bueno esto ya eficiente vale Sí estoo escalable muy bien no como
(48:37) el mío entonces acá estamos entonces test set lo que nos permite pues es se dan cuenta nos dice Quién es el ganador no el que saque false y todos los demás sacan true pues saben que perdieron Este Entonces los perdedores pues no no se ponen de acuerdo no Simplemente pierden y lo vuelven a intentar y así lo vuelven a intentar a intentar Entonces no se cumple con justicia claramente pero en estos en estos siguientes candados vamos a ver cómo los forman como en una cola Esto sí el el cl el clh y el mcs los forman tal
(49:31) cual en una cola y el Loc está como es es todavía más eficiente los forman como en ranuras Pero bueno sigue sigue como que la misma idea de una cola Bueno pero vamos a ir entonces la cola nos va a permitir pues fijar al ganador y al siguiente y al siguiente y al siguiente perdedor o sea el que no tomó el candado no importa Pero al menos se formó y le va a tocar después de del de adelante entonces el primer candado el clh lock funciona pues es la misma lógica que el de Bakery que les presenté o sea tal cual Pero bueno aquí está más eficiente
(50:06) Por qué Porque utilizan este utilizan e bueno es distinto Bueno ahorita Ah ven Entonces tenemos tenemos este Tail esa es una cola imagínense tal cual una cola Tail tenemos Tail esta Tail es una referencia a un nodo y este tenemos las este estas dos variables que son de tipo thread local el que utilicemos th local y yo creo que ya varios lo saben lo que es local es este digamos que guardar guarda eh los valores Bueno guard sí vamos a ponerlo así referencias de
(51:10) forma local a cada hilo entonces a pesar de que estas dos variables son globales el que utilicemos la palabra local nos va a hacer que este sean referencias globales pero cada quien tiene su referencia de esa variable o sea este y por eso en la línea cuatro siento que es la gran diferencia porque es eficiente esto pero bueno en la línea cuatro utilizan este guardan un nodo no el nodo su nodo propio Entonces al guardar este nodo propio no crean que este nodo va a ser el mismo para todos no cada quien tiene su propio o sea de forma local este su
(51:59) nodo guardado pero como que en esta variable local en esta variable global que es como global No pero lo que nos dicen simplemente es que todos van a tener de forma este como estandarizada su propio nodo guardado en TR local o sea como que tienen referencias pero de forma local su propio su propio nodo Vale entonces así como que no pierdes la referencia de Qué nodo es el tuyo no qué nodo creaste porque ahí está guardado entonces eh lo que hacen es que bueno se inicializa no Tail es un es un este una referencia atómica a a un nodo
(52:37) eh el el el nodo lo vamos a guardar en TR local no lo guardamos en nuestra memoria local vale y este ahora sí no eh Ah bueno y Ah bueno y lo inicializando entonces este Ajá inicializando como tal el novito Entonces qué es lo que hacemos acá o sea ya digamos que todos por default tenemos un noito creado en My no entonces lo que se hace Es que este en la línea 21 no obtenemos nuestro nodo O sea ya ya lo tenemos puesto pero lo obtenemos en la línea 22 este marcamos nuestro
(53:39) K bueno los K van a tener un campo que va a ser locked este y va a tener un campo que va a ser [Música] espen espérenme punto c s bueno a ver hay que tenerlo ahorita valeta vamos po entonces un noito no el nodo pues va a ser tiene el atributo lock que inicialmente va a estar en falso vale Entonces nosotros este tomamos nuestro candado Perdón nuestro nuestro nodo lo ponemos en verdadero o sea lo cambiamos y luego
(54:43) hacemos que el predecesor que que este Al que está apuntando bueno guardamos el en pre el anterior no sea el que está apuntando Tail no entonces lo que hacemos Es que en esta línea eh si se dan cuenta otra vez tenemos get and set pero ahora como Tail no es una atomic bullan sino un atomic reference pues lo que va a cambiar y va y es es un atomic reference de tipo nodo Entonces ahora ya no es como que le pasemos un true y obtengamos un false ahora le pasamos una nueva referencia en este caso eh le pasamos nuestro nodo le
(55:30) pasamos nuestro nodo y obtenemos el predecesor no O sea al que apuntaba este Ajá sí sí entonces eh Ah sí entonces lo que vamos a hacer es que bueno eh Entonces digamos que le ponemos el nuestro nodo no O sea en Tail por ejemplo Tail pues inicialmente entonces ahí lo que hacemos Es que inicialmente pues estaba apuntando a un nodo no O sea a un entonces este de no sé del hilo uno no Entonces yo lo que hago en esta línea
(56:33) pues simplemente es cambiar a mi Kun 2 no se pues es imagínense no que Este es el Kun 2 entonces lo que hago es cambiarlo aquí obtengo a quien le estaba apuntando no spreed pred es al quien estaba apuntando apuntando Y entonces en la línea 24 en My pred no es este my PR Quién es es la referencia que todos tenemos pero que cada quien va a guardar ahí su propio su propia información entonces en My pred voy a guardar a quien le apuntaba Tail no entonces en My PR guardo a quien le apuntaba Tail y este y entonces voy a esperar en la línea
(57:24) 25 este mientras el pred del anterior ya vieron Es igualito no mientras el pred del anterior esté en true entonces yo voy a esperar en cuanto el anterior este a mí pase eh este ya yo paso no Entonces si se dan cuenta la idea es que al final nuestra cola no nos va a quedar algo así este ot con no del hilo no s TR y otro con del hilo este cu Entonces tenemos así una cosa como de nuestras referencias locales Ahí es donde vamos a guardar al anterior no este s es el my pred pero del hilo en el mypr del hilo 2 está el Kun 1 en el mypr del hilo un
(58:13) está el kune 3 en el mypr del hilo 3 está el kune 4 no así O sea cada quien tiene Y entonces va a llegar un nuevo hilo y va a apuntar a el mismo no va a ser en la línea en la línea 23 no va a ser el si va a agregar nuevo no por ejemplo el noo asterisco entonces va a cambiar Ya aquí y y va a guardar en mypr el siguiente no de su de su este disco entonces así así va a ir creciendo Vale entonces todos vamos a tener este inicializado en en en true no en true porque ya se hizo en la línea 22 todos tenemos aquí TR Entonces vamos a estar esperando aquí no
(59:03) dando vueltas en en el anterior vale o sea digamos que estamos revisando todo el tiempo la memoria del nodo bueno de Pues sí O sea la memoria del hilo que tiene el nodo anterior así vamos a estar dando vueltas no entonces este por ejemplo el hilo que tiene este el asterisco pues va a estar dando vueltas en la memoria del que creó Elo dos no y est va a estar dando vueltas en la memoria del tres y así no como que damos vueltas ahora pero la memoria de del siguiente vale si se dan cuenta esto cambia por qué porque o sea es distinto
(59:43) y es y es mejor al que yo les había pasado al Bakery chafa que les pase bueno la implementación no para neilos Porque si se dan cuenta la cola este que creamos o sea bueno que se creó en o sea el anterior la cola es totalmente una memoria o sea es una cola compartida no y los vamos formando ahí pero aquí lo que hacemos Es que estamos dando vueltas Ay estamos dando vueltas en la referencia del otro o sea no es completamente compartida no O sea guardamos la referencia simplemente del otro y ahí damos vueltas pero no es que
(1:00:18) conozcamos todo lo de los anteriores No no es que sepamos justamente este que Bueno o sea por ejemplo este sabe que este es el anterior pero no sabe quién es el anterior del anterior no porque solamente tienes guardada la memoria local del anterior justo no de los no de todos los demás entonces por eso es más eficiente este algoritmo que el que vimos este que el que les hice revisar en la práctica tres es muy interesante no comoo cómo utilizamos estas Memorias de trad local Entonces este ya si vemos no este este lock pues es es similar no
(1:00:57) Qué haces este haces que Tail apunte ahora a ti guardas a quien apuntaba Tail y tú te pones a dar vueltas en ese y hasta que cambie su bandera a false porque cuando deje el candado va a apuntar a fs entonces tú ahora sí vas a vas a este poder avanzar no vas a poder tomar el lo y para tomar para dejar este en la línea 29 lo pones en false y además este lo que haces aquí es que pones tu nodo como el el anterior no O sea digamos que haces que tu nodo o sea tue se ahora al a mi PR no y así como que se va reseteando esto como que
(1:01:47) si se dan cuenta no hacemos una cola como les presenté yo no se hacemos una cola de 400 nodos No aquí lo vamos reseteando vamos reutilizando entonces por eso también es más eficiente Eh entonces así funciona este clh Bueno ya lo expliqué todo allá pero este así funciona e damos o sea estamos dando vueltas en la memoria de alguien más de quién del anterior Eh entonces este otro Es igualito es Es igualito Solo que aquí cambia una cosa es que cambia que e el el método unlock lo que va a hacer es que sí va a obtener su su nodo el que
(1:02:39) le corresponde pero va a hac que que este bueno Y aquí también cambia que que cada nudo en este caso en el anterior tenemos eh a además no En el anterior teníamos la referencia mipr se acuerdan Y en este ya no tenemos por qué porque ahora los los nodos la clase tiene los dos Campos tiene lock y en cada nodo guardamos al siguiente en next sea aquí camb en el otro no teníamos la referencia la anterior no O sea no teníamos el next en cada noito lo guardábamos de forma en local en mypr y ahora Aquí sí Vale entonces este ahora
(1:03:29) lo que va a consistir este eh es que vamos a tomar nuestro nudito y vamos a apuntar este qe Eh bueno si es igual a nul o si no si ya la cola está vacía pues no no hago nada no O se algo de aquí este ah no perdón si si no está vacía este Bueno ahorita vemos la línea 30 entonces entro pensamos acá entonces lo que vamos a hacer es que hacemos este en Tail que es la memoria global vale es global Tail modificamos de forma global por eso utilizamos un comper hacemos que que está apuntando ae y ahora lo ponemos a nul y
(1:04:20) este y entonces acá vamos a esperar si si Y si ya lo movieron este no creo que los estoy haciendo bolas tamb estoy haciendo bolas vamos vamos Mejor Es que creí que iba a ser más rápido pero mejor lo lo lo reviso desde el inicio Entonces vamos desde Loc vale vamos desde lo aquí mejor entonces este lo que lo que consiste aquí no es que ahora s cada uno tiene su este su noito no con false y con en vez de solo myp entonces este cada uno otra vez en my Note va a guardar su propio nodo se su referencia si no la pierde y Tail es
(1:05:06) una es este una referencia atómica a un a un nodo no entonces y est es una variable local entonces así supongamos no que Tail pues ya existe aquí y apunta a un nodo entonces lo que vamos a hacer acá es que este tomo mi nodo hago que guardo en pred no en mi variable local pred este al que apuntaba Tail y me pongo yo no O sea eh q no del hilo un entonces hago que ahora apunte a mí y este y yo guardo el el predecesor Eh entonces si pred es distinto a nul no este Ajá entonces lo que hago si PR distinto no entro No aquí y pongo q Note
(1:06:06) igual a true Sí como que quiero pasar y hago que el pred pun next sea igual a qe no entonces Ah sí Miren el predecesor era este Entonces algo que es un next me apunte a mí vale Y este apunte a mí Y entonces dónde voy a estar dando vueltas en mi propio en mi propia memoria en mi propio log O sea que este espero revisando mi propia este Eh mi propia variable en mi propio
(1:07:10) nodo no como ener anterior que estás revisando el nodo de alguien más no al dar vueltas en mypr aquí lo que vas a hacer es que vas a hacer que que que este que el siguiente Bueno el el que apuntaba ahora apunte a ti no O sea como que modificas ahora la variable del hilo anterior similar un poco no O sea se parece un poco al que les compartí pero es que son sí son distintos al tener este el TR local pero bueno entonces La idea es que si la la cola está vacía Pues paso automáticamente no O sea si Tail es igual a
(1:07:50) nul entonces eh termino eh Bueno entonces tomo el lock sin formarme no O sea pues ya paso o sea no no no tengo que hacer nada vale o sea Qué quiere decir que mi lock se queda en false no O sea nadie lo mueve tomo el lock y me paso pero si no está vacía Entonces coloco el anterior ahora que me apunte a mí y este y pongo mi lock en true Y entonces quiere decir que este cómo se va a ir construyendo esto no pues va a llegar alguien más este va a poner aquí su en la línea dos lo que va a hacer es que va a cambiar la referencia de Tail
(1:08:40) al nuevo nodo y en la línea este la línea 20 no como es distinto n porque ya hay varios hilos formados lo que va a hacer es que va a hacer que que un outlock sea igual a true o sea su propio nodo y el predecesor este va a cambiar la referencia no del al que apunta el predecesor a su propio nodo Y entonces va a esperar a que kote su propio nodo sea true no O sea como que aquí espero a que a que yo sea true entonces lo que va a hacer el unlock Ahora sí es que bueno primero no si si kuno va a tomar su candadito no entonces
(1:09:25) mir por eso sí no tal cual bueno que lo revisamos así entonces voy a copiarme esta imagen okay Entonces por ejemplo aquí supongamos que nosotros somos el kde de de este este de aquí vale entonces va a decir no next es igual a nul eso que qué implica que tenemos ya alguien formado después de nosotros no Entonces si con es igual a nul este perdón si si no es igual a si es igual a nul eh No tenemos a nadie no pero si no es si tenemos a alguien entonces bueno el vamos a ver este caso vale en el que somos nosotros este en entonces quiere
(1:10:17) decir que no entramos a este a este If no nos vamos hasta acá o sea para dejar el candado lo que haríamos es vamos a modificar este al siguiente ya vieron o sea lo que hace es si tenemos formado a alguien entonces en la línea 36 lo que vamos a hacer Es que modificamos su bandera su bandera y este y hacemos que bueno y dejamos de apuntar no a a ese nodo entonces quiere decir que pues ya se perdió O sea no O sea como que Pues digamos que si es que ya le tocó a este el de adelante ya no ya no existiría no porque pues ya perdió la referencia al
(1:11:18) siguiente o sea como que cambias tu tu referencia el siguiente ya se pierde entonces como que solo van quedando Pues los hilos no que que que van y Solamente damos vueltas en nuestra propia memoria Bueno entonces más o menos O sea cómo cómo lo ven este mm Bueno espero que bien 10 Vale entonces este esa es una no la la otra es que si no tenemos A nadie Simplemente lo que hacemos Es que hacemos un compan que en vez de que apunte a nosotros el Tail Pues que apunte a nul no lo reseteamos y acaba y este ah ya me acordé Y esa línea 34 surge por
(1:12:19) si alguien modifica este Ah ya me acordé sí sí sí sí entonces la línea Bueno aquí es así como para lidiar con la con la Pues con los traslapes entonces en la línea 30 vamos a escribir aquí No todo lo que pasa aquí es que primero este si es el último entonces en la línea 31 pues lo que hago es cambiar no cambiar Tail a nul y recordemos que el comper te regresa true si si lo hizo y false si no lo hizo true pues acabas No ya muy bien acabó pero en la línea 34 es que si no este fue
(1:13:23) cierto entonces quiere decir que que este que que o sea que alguien se anotó después de mí no O sea que ya ta No apuntaba a mí sino que apuntaba a alguien más entonces quiere decir que ahora o sea que justo en ese momento alguien decidió apuntarse el mismo Entonces para eso es esta línea en la 34 no si no fue cierto entonces alguien este se apuntó después de mi nodo no Y entonces por eso aquí en la línea 34 esperas dices next no O sea esperas Hasta que el siguiente ya no sea nulo ya O sea que tengamos ya alguien ahí y Entonces ahora sí vuelves
(1:14:14) a empezar no este bueno sea bueno no vuelves a empezar no te vas a la línea 36 y haces que el siguiente sea false no y este y y haces que que Kun next sea igual a nul no para ya te por fin ahora sí te quitas de de la de la lista porque sabes que en ese momento sea como que esto esto de la línea de la línea 31 a la 34 es porque en ese punto alguien se metió no Y si alguien se metió pues quiere decir que ya no eres el último y que ocupas tú darle la bandera no cambiarle su bandera para que esto no no se quede ahí entonces así así F funciona
(1:14:55) este Mc mcs Vale entonces Estos son las dos diferencias los primeros dos que vimos testan set y doble testan set Solamente damos vueltas en un While de un enan set no y el otro este metemos metemos este While no en otro While y así aliviamos la contención porque hacemos que los hilos como que uno se detengan acá y ya que les decimos ahora si pueden ya todos van se pelean estos otros dos consisten en construir una col pero como vimos hay formas de construir una cola no O sea la forma que yo les compartí pues es así como Pues lo más
(1:15:32) trivial vale es este literal creas una cola este haces un comper set para poner al siguiente y ya está no pero aquí vemos que cambia cuando este utilizamos TR local Porque si se dan cuenta no no tenemos como si vamos a hacer 400 tareas no no conservamos los 400 n simplemente cada cada hilo tiene su propio nodo y se va escribiendo después de la de Tail no O sea Tail simplemente lo que hace es guardar la referencia de la anterior entonces tú solamente vas guardando la referencia a la que apuntaba Tail y das vuelta en su este en este no en
(1:16:14) clh la diferencia es que Das vuelta en la memoria de alguien más de bueno de un hilo de otro hilo no y aquí lo vemos damos vueltas en pret este y la diferencia con este otro es que e lo que hacemos ahora es que en el método unlock Pues los hilos le dicen al siguiente que le toca no entonces como que el que ya acabó le tiene que decir al siguiente al que y este y entonces lo que sucede acá es que a entonces acá ya solamente tienes que dar vueltas en tu propia memoria en tu propia
(1:17:22) memoria Vale entonces es la diferencia y resulta que en la práctica esto es importante este ustedes que creen que sea más más este mejor espinear en tu propia memoria o espinear en la memoria de alguien más pues aquí sí no mcs Exacto Entonces sí en la tuya entonces la diferencia Vale y de hecho si se dan cuenta en el mío en el Deer que les compartí espine en una variable compartido Está peor No porque espinas en toda la variable o sea en el objeto compartido y aquí no solo espinas en tu hilo no ent por eso son
(1:18:06) más eficientes estos dos este entonces sí mcs nos gusta espinear en la memoria local y ya entonces finalmente la lo este consiste en que es como esto es como una una implementación como este de mentira de de una de una cola miren Aquí está entretenido Lo que sucede es que ahora tienes un este otra vez con módulos como nos encantó módulos aquí enpo concurrente Entonces tenemos este el local otra vez es un entero no entonces este y este tres local va a estar inicializado en cero inicialmente entonces lo que lo que
(1:19:03) vamos a lo que va a suceder o sea cada quien Digamos que cada hilo cada hilo tiene un slot vale entero pues tiene como un contador cada hilo Vale y están inicialmente cero todos entonces este lo que sucede aquí en la línea 30 Ah bueno Tenemos también una variable Tail es un es atómica tenemos este un arreglo de banderas eh del tamaño de de los hilos Y entonces este lo que vamos a hacer aquí Bueno pues el tamaño es el número de hilos vale Tail inicialmente está inicializado en cero es un atomic entero y y y la bandera pues del tamaño de los hilos y
(1:20:02) todas las banderas están en Ah bueno la bandera de del de del registro cero está en tro Bueno creo que son todos pero sí supongamos que todas inicialmente están en en true Bueno ahorita vamos entonces en la línea 43 lo que hacemos Es que guardamos en slot en o sea como que nuestra en una variable local este al siguiente hacemos un ketan increment y el getan increment Qué hace incrementa y devuelve el valor anterior vale es lo que hace Entonces si estaba en cero lo incrementa uno y regresa cer0 Entonces el slot no
(1:21:04) principal pues o sea si si este Tail igual a 0 entonces slot va a ser igual a cer y Tail va a ser igual ahora a uno no así va a ser entonces en la línea 45 este en My Index guardas El slot o sea el slot que que obtuviste y vas a espiar simplemente aquí vas a decir mientras Mi bandera no esté este Eh no esté en verdadero mientras Mi bandera Eh sí verdad falso Ah sí Más bien no esté en falso verdad no esté en falso y no en verdadero verdad es que luego me hago este mientras Mi bandera no est en verdadero porque vamos a
(1:22:09) quedarnos ahí si nuestra bandera está en falso este a es no se me va Disculpen mientras Mi bandera no est en falso HM entonces este me quedó no Sí es correcto Bueno digo sí sí sí lo ven bien ya les estoy este diciendo algo bueno entonces la línea 49 lo que haces es que este para dejar el candado o se digamos que la idea es que te quedas ahí no como que esperando que alguien eh te diga en Tu bandera que ya puedes pasar Vale entonces Ah si Mi bandera no esté en en true no es que sí es así mientras Mi bandera mientras alguien no
(1:23:09) ponga Mi Bandera en true pues me voy a quedar vale Esa es la idea de este algoritmo entonces en la línea 49 pones tu propia bandera en falso no tu propia bandera y en la línea 50 lo que haces es que le agregas este a tu slot O sea al que tocó le agregas uno y pues haces módulo no para siempre estar dando vueltas ahí porque ya vimos no se ha el módulo del tamaño del número de hilos entonces quiere decir que pues si tenemos nuestra flag no nuestra variable flag que es una arreglo de booleanos entonces quiere decir que en size este
(1:23:54) si es módulo se pues Siempre vamos a estar dando vueltas no O sea le va a tocar a este y luego a este o sea si vamos aumentando de uno pues van a ir formados no este Ajá sí Entonces es la idea después le va a tocar true al que sigue entonces aquí lo curioso Es que este ah sí sí ya record Entonces lo lo interesante de esto no es que este digamos que que la idea es que eh tengamos siempre nuestra nuestra flag no nuestra nuestro arreglo flag entonces la idea Pues si se dan cuenta aquí es que en la línea 50 vamos a ir este pues de c
(1:24:53) 1 do 3 h n no n si n hilos entonces Siempre vamos a ir así talal no O sea todo el tiempo y y eventualmente vamos a llegar aquí y vamos a regresar porque es módulo no Y entonces mientras todas las demás vamos a estar en false Ah Sí por eso solo la primera aquí es true Bueno entonces todas vamos a estar en false Y entonces vamos a decirle true a este no y todos los demás en false o sea como que se se va a ir moviendo ahora quién le toca el truno ahora le va a tocar a este ahora le va a tocar a este así así es como se
(1:25:30) va a ir este escogiendo a quién le va y y es interesante entonces que este los los hilos van a revisar en el slot que les corresponde o sea cuando cuando hacen el getan increment en Tail si se dan cuenta Tail pues simplemente es un contador no entonces Tail simplemente les entrada al que le va o sea Digamos que cada hilo no tiene justamente un slot asignado en en este en flag O sea no tiene no siempre va a tener el mismo slot el hilo no el hilo va a cambiar de slot O sea a veces por ejemplo el hilo uno está esperando
(1:26:13) en el slot cero no el hilo dos va el hilo no sé este y + un va a estar esperando en el slot un Y luego el hilo dos el hilo tres por ejemplo no va a esperar en el en el slot dos y así O sea digamos que se van a formar pero en los slots Entonces como siempre les van a ir dando paso así no O sea primero este luego este y luego este y todos los demás va estn en false no Entonces tú nada más estás esperando a que t slot ya te den el paso y cuándo te van a dar el paso en la línea 50 este cuando ya pongan su bandera en false y ahora sí al
(1:26:51) siguiente entonces quiere decir que que este bueno que no va va si quiere volver a pasar pues tiene que volver a tomar un nuevo slot y verificar no que se cumpla en su bandera Vale entonces bueno así así funciona Este pero si se dan cuenta como que la idea es que no crees nuevos nodos como que los hilos deciden En qué O sea como que van los hilos son los que ven en qué referencia van a formarse no O sea no tienen ellos que crear un nuevo nodo con una nueva referencia Y entonces esperar a que alguien les modifique eso
(1:27:34) no O sea flag ya está dada no Exacto en este caso también otro hilo es el que te da acceso Entonces si se dan cuenta aquí simplemente donde estamos dando vueltas es que cada hilo está dando vueltas en una variable compartida que es flag en una en un determinado este entrada de este de arreglos Vale entonces también cambia pero se dan cuenta como que Ay pues está más más sencillo o sea tiene su complicación como siento que está como o sea también la simplicidad está este la dificultad no O sea como de Pues si es como un poquito difícil de
(1:28:10) entender pero se dan cuenta como que es el código es bastante corto no O sea ya no tenemos que crear nuevos nodos y este entonces hacemos una modificación de Tail a mí y este o sea ya no ya no hay referencias vale está cool no se está bonito que ahora simplemente ponemos a Tail como un contador tomamos el slot y nos vamos a formar en el que nos toca y eventualmente cuando los hilos dejen el candado No pues me va a tocar a mí me van a avisar a mí que Mi bandera ya está en true Y entonces voy a pasar y se va a
(1:28:45) reutilizar esa entrada Porque alguien más se va a ir a formar ahí y así entonces así vamos a estar dando vueltas sobre esta flag no Y si se dan cuenta es como una cola Sí pero como que abstracta no O sea pues al final nos formamos no nos formamos en un Tail por eso por eso utilizan esta palabra de Tail No pues sí nos vamos a formar en el Tail el Tail va a decir quién es Quién fue el último no O sea Quien tenga quien haya aumentado al final el contador pues ese va a ser el último y yo tengo el siguiente y me
(1:29:16) voy a formar después de él pero no precisamente como o sea como en nodos no de formas en este arreglo de de flag entonces así le llaman a lo este porque por los slots bueno el libro lo explica pero este no me acuerdo bien pero bueno entonces son todos los los este cados entonces así funciona esto y el código yo les había pasado compartir aquí entonces Acá está chat
(1:30:23) aquí entonces aquí está el el código de Run Spin lo pueden modificar si quieren porque vi que varios Y si está más bonito no pues nada más le ponen este aquí en vez de que en vez de tomar todos los futures le ponen este terminate no si si ya acabó el executor y también eso es válido vale ent bueno sea lo pueden acomodar como ustedes quieran Yo lo hice así pero lo pueden hacer si quieren hasta más eficiente Pero bueno sea si no quieren meterse en problemas pues nada más lo Ejecutan esto como está lo que hace este
(1:31:00) código pues ya ustedes ya son así ya saben un montón Cómo ocupar los executors entonces ponemos este en mi caso mi compo tiene 11 hilos Vale entonces ponen yo puse ahí mis 11 hitos y este y Y entonces vamos a vamos a ejecutar los distintos candados aquí tenemos les Pase todos está el testan set el el el doble testan set este acá no por ejemplo están bien sencillitos o sea les digo es lo mismito nada más que como implementan l este son los códigos de herly vale o sea aquí está aquí está su nombre acá entonces este Él te dice que pues todos toda
(1:31:49) implementación de un c debería tener estas otras O sea estas otras clases Vale entonces este pues simplemente es esto lo que vimos ya vi tal cual y acá está el otro no también pero dice aquí dice no cl debe proveer estos métodos entonces aquí están los códigos Ah aj entonces así así se ve que está el clh No aquí están todos vale Ya los revisamos están igualitos Eh entonces aquí nada más van descando O sea la idea pues ya vieron está muy sencillo O sea ya lo difícil lo pesado pues es entender no este analizar el
(1:32:38) código como ya vieron no sea pues correrlo pues sí no van a correr Entonces los hizo herle pero o sea lo interesante es entender y entender Por qué pues uno jaló mejor no O sea este qué hicimos pues mejoramos o sea lidiamos mejor con la contención esa es la razón pero claro o sea contención implica más hilos O sea que si ustedes tienen una compu de cuatro hilos pues no van a ver contención ahí no se va a ver mucho entonces sí O sea nada más es como ponerlos a correr por ejemplo yo tengo aquí 11 hitos y de hecho en mi compu ni
(1:33:11) este el mcs por ejemplo o que el al sean mejores no se ve por ejemplo aquí con 11 hitos por ejemplo 2.4 [Música] pero por ejemplo ahora este está en set el doble mir tarda más no si suele tardar más De hecho aquí no se ve o en mi compu por ejemplo no se nota la diferencia como de lidiar con la contención la lo que también es muy eficiente este miren aquí es cuando cambia 7.
(1:33:56) 3 y O sea a pesar de que es mejor me 3.6 pero es más pesado los hilos que que proven justicia son más pesados Pues sí no imagínense el testan set solo es una operación lo malo es cuando Tenemos muchos Entonces es la idea que que los prueben Ah y en la en el ejercicio uno yo les puse Aquí este dónde estás el contador atómico no que ustedes ya Hubo quien Pues siento que es como hacer trampa no porque le pusieron atomic al contador en la práctica anterior y cuando ustedes le ponen atomic pues les digo que en realidad se convierte en en este pues ya tiene consistencia no no no
(1:34:35) ocupa un candado siempre va a salir correcto Entonces es la otra no cómo funciona si nada más este ay ay qué pasó este Ah es que me faltó acá en vez de Esta es esta y esta para m no ejecutar aquí directito miren 2.6 me tardé con sin utilizar cantados ya vieron Porque si utilizamos atomic el contador ya tiene consistencia pues nada más modificamos con get an increment o con increment and get cualquiera de las dos primitivas y ya pues es una operación indivisible no no hay problema si se dan cuenta cuando son pocos hilos pues hasta
(1:35:22) me conviene no es un o sea corre un poquito peor que el spinlock de testan set entonces como que aquí vemos no que Este pero bueno de seguro esta no ha de lidiar bien con la contención si la ponemos a correr con 64 Entonces miren Aquí tengo por ejemplo vamos a compararlo no esta compu si tiene cuando tengoo de forma remota tiene 64 entonces este dej CD PC me cu Vale entonces Bueno eso es lo que van a hacer este si alguien creo que Camilo me había comentado que tenía cuatro hilos
(1:36:25) este Cuántos hilos tienen tus otros compañeros No te acuerdas Porque si sí entonces te voy a o Pues sí estaría mejor que te diera acceso pero está muy fácil Ajá vale si hay alguien que tenga en tu equipo una buena cantidad de hilos pues bueno ya lo pondrán a trabajar en su compu pero si no si te comparto acceso esta Entonces tal cual en esta nada más es un acceso remoto no te doy tu credencial este para Bueno tu acceso este bajas programas aquí y este y los [Música] compilasion creo que el que tengo abierto ya va
(1:37:40) Sí se ve eso ahora sí cre que ya les había puesto por el que tengo puesto miren 27.33 milisegundos no s es muchísimo Ya vi con 64 Déjenme ver a quién puse a correr en este sí son 64 a ver [Música] este a creo que lo tengo muy chiquito verdad más grande no se ve nada ven mejor no [Música] entonces Ah miren tengo al 27
(1:38:49) milisegundos con4 hos vale lano y ahorita vemos los otros no es como es acceso remoto dejen apago mi cámara Porque luego el internet no da este vamos a descomentar este este y luego me entonces otra vez ya vaas ya va Sí verdad sí a ver miren 25 sí 23 ya vieron en 64 hilos sí podemos ver que es más eficiente el doble testet que el test set normal
(1:39:54) vieron ahí sí Este Entonces sí se cumple no pero por ejemplo en mi compu de 11 hos y bueno que seguro ni han de correr ahorita a los 11 porque tengo abierto todo no O sea tengo este zoom y y este sí O sea no con zoom yo creo que no no ha de correr también pero sí el el testan set y pero cuando antes de abrir zoom o sea sigo corriendo los ahoritas son un seos el testan set sencillo corre mejor que el doble testan Z pero en la compu de 64 hilos corre mejor el doble t stet Por qué Porque Lidia mejor con la contención
(1:40:37) Vale entonces este Ese es ese es un ejemplo también otro que estaría interesante ver es Qué pasa cuando este en vez de utilizar por ejemplo no qué tal que utilizamos el contador este así Si utilizamos el contador directo O sea ya con su propia este consistencia Entonces cómo jala esto ya corre 29 milisegundos Lidia mejor con la contención el doble testan set y también el test set ya vieron bueno miren aquí ahí se van no no
(1:41:42) 19 29 miren est estuvo bueno pero bueno habría que ponerlos a varios resultados no este ahí también cór al menos cinco veces Vale y saquen ahí como nada más el promedio sin incertidumbre y esas cosas no más así como el promedio que corrió c veces es este para que no vaya a ser no qu tal que primero el primer este la primera ejecución salió Enton Así tiene por ejemplo el aloc que se supone que es de los más este eficientes el al vamos a ver cómo corre en esta Sí yamos este ya Lu Java normal 25 27 23 yo creo que ocupo más hilos no para
(1:42:47) que se note que realmente la lo es mucho mejor pero miren es curioso es este bueno Y si ustedes se preguntan Oye por qué este en esta de 64 se tarda tantos milisegundos no y en la de en tu cuo de 11 se tarda tres ya vieron 3 milisegundos Pues porque liar con 64 hilos requiere este o sea es más contención o sea obvio se va a tardar más no es que sea más eficiente si ponemos a los 64 hacer una cosa al mismo tiempo no entonces si o sea s es Es lógico Pero bueno sa es que buen ustedes me dirán No pues solamente usa unilo no
(1:43:31) no porque hay situaciones en donde s requerimos o tenemos sistemas distribuidos en donde este no s Ticket Master no sea tenemos mil ejemplos no pero bueno a m este duro con mi Ticket Master pero sí O sea tenemos ejemplos en donde no no podemos O sea no podemos no lidiar con contención redes por ejemplo no Qué horror las redes este son caóticas entonces si este por ejemplo la Loc aquí cóm funciona comamos este este quitamos este [Música] este que se [Música] como comandos entonces a ver qué corra miren TR Ah 3 milisegundos Wow qué bien corre Este
(1:44:30) pero este el este el Alo se acuerdan perdón el test normal 2.3 no y este 3 milisegundos o sea sí es bastante No creen 4 milisegundos los que son terribles son el MC lock y el clh clh 3.1 Ah no está tan mal 3.7 pues ahí se va no pero sí es peor el clh es peor en contención que el alc Ajá muy poquito bueno es aquí ese muy poquito es importante no o sea es Sí este sí sí es importante ese poquito pero vean por ejemplo acá acá no se ve mucho la diferencia o sea acá podemos ver que o sea se acuerdan primera la de 25 esta de aquí es este el el el este ah
(1:45:32) no el de 27 no este es el testan set el de 25 es el doble test set 23 cre también lo corrí varias veces luego estos del 29 25 son los del contador y este de 24 es el aloc no O sea como que si se dan cuenta aquí no cambia mucho no bien podríamos usar el aloc y tener justicia o sea es muy importante la loog te promueve justicia a diferencia del del doble testan no este Y bueno ya no más para ver para completar esto vamos a ver cómo corre este el el clh no porque ese según yo no no está muy bueno o sea promueve justicia está bien
(1:46:29) pero según yo la que es bastante mejor para más para un número de hilos más grande entonces ya s yaa 28 sí miren Sí si es distinto el otro 24 23 no este 28 26 Y eso es importante no o sea porque solo liamos aquí con 64 hilos pero les digo no si ocupamos 1000 no o si ocupamos 10000 Entonces ahí es donde se vuelve horrendo esto o sea es como que por eso les digo O sea si tienen una compu de cuatro y no hay quien tenga una buena compu en su equipo sí me dicen porque no se va a ver nada con con cuatro hilitos no se va a
(1:47:12) ver mucho o sea va a ser así como este con cuatro hilitos Pues sí Ah bueno Y también acá no sería también que le cambiara yo porque estoy utilizando lo el máximo número no pero si le pongo cuatro también se va a ver que el testan set pues es más es mejor y en el ejercicio dos yao les había puesto que este de la práctica les puse que aquí en el en el task antes de increment o en increment no Si antes de increment le pongan un este un trat slip de 2000 no de 2000 milisegundos para ver si también si si espera O sea qué tanto No si si si
(1:47:54) la tarea se tarda más Y si ocupas esperar si realmente o sea cómo es no si se alivia la contención Este pero bueno entonces s Yo creo que sease con 24 hos va a estar padre entonces eh Ajá sí te pones a jugar ahí le pones un slep un slep aquí ves que tanto y y tratas primero con cuatro hilos cómo funciona y con los 24 cómo funciona igual no no habrán tantas pestañas O sea no estén haciendo ahí mil tareas al mismo tiempo porque pues si los hilos se consumen no O sea ponen el video ponen su una pelle en su en su en no sé en su
(1:48:40) tablet en su c y pero no en la compu vale o sea no estén ahí jalando constantemente e y Vale pues eso es todo eh Déjenme revisar mis correos este Déjenme revisar acá qué más les pedí miren ya está el examen puesto práctica cuatro acá además les pedí sí miren bueno en el dos ya vieron aquí modifiquen para que un slip de 2000 2000 milisegundos no O sea do segunditos a ver qué tal y contestan acá Ajá Pues sí En realidad creo que ya con eso pueden contestar todo y este Pero bueno me escriben con tiempo vale para que les dé el acceso y
(1:49:35) no lo hagan a la última hora eh esta práctica se entrega el les puse que el domingo este 13 de octubre Ajá domingo 13 de octubre como se se nos va a encimar con el examen pero ya vieron que en realidad no hay que implementar nada va O sea no no tienen que hacer como algo siento no O sea siento que si se ponen a hacerlo en máximo dos horas o sea y el siguiente jueves tenemos clase Pues en esas dos horas las aprovechan y lo hacen vale o sea no ocupan mucho este tiempo según yo para esto este tal vez nada más en las preguntas no como
(1:50:11) analizar si cumplen con justicia o si les salió algo muy rápido bueno o sea cuál es en la tres Noa Cuál es la implementación más rápida Pues por qué no también qué tal que gana testan set este el más chafa Pues sí puede ser que gane porque tenemos pocos hilos no entonces este puede ser que gane no eh lo interesante va a ser Quien tenga varios hilos que pueda ver como o sea Quién gana entre aloc no mcs mcs y el clh que son justos no y y ya eso sería todo entonces tienen dudas por el momento todo bien Sí este ahorita no vale Bueno entonces
(1:51:04) nos vemos mañana en la clase teórica y este y pues eso sería todo Vale Nos vemos bonita tarde Bye an
