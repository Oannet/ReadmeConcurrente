2024 08 26 10 00 38 - YouTube
https://www.youtube.com/watch?v=tsXmIQjQpiU

Transcript:
(00:29) al al al Hola buenos días
(02:00) k okay Bueno cómo van con su tarea no empieza Bueno
(03:06) pues mejor mejor pronto no para que por si tienen dudas porque bueno quedan ayudantía del martes y jueves no O sea tod tiene un buen tiempo todavía pero mejor empezar bueno este si tienen alguna duda de la tarea Me comentan igual ya han este te han preguntado en el discord no está bien recording in progress Okay bueno el Este es el tercer tema Ya si objetos concurrentes e entonces bueno este tema siento que es este y el del consenso son como muy pesados pero como teóricamente como que hay mucho H muchos términos nuevos yo creo no tal
(04:06) vez que no han oído bueno en Sí por ejemplo del tema pasado pues tal vez no exclus muta free y de este tema vamos a ver otros otros este conceptos como weight free lock free e linealiza bilidad consistencia secuencial o sea cosas así por eso les digo como que Está pesado teóricamente como que mucha muchoo pero en Sí pues siento que no está difícil bueno estos temas se pueden complicar bastante no para hacer este papers así cosas así más pesadas Pero bueno sea como como lo vemos como introductorio siento que no Está pesado
(04:46) nada más le digo que mucho mucho concepto entonces entonces bueno el tema el tema anterior pues vimos Pues no más en realidad digo algunos problemas pero pues el fundamental que vimos fue exclusión mutua no y y vimos sus soluciones entonces Bueno cómo solucionamos la exclusión mutua Pues bueno implementa un objeto candado y vimos hay implementación para dos hilos para para n no es lo que vimos el tema anterior todo el tiempo candados y bueno vimos también además que pedirle un candado porque resolver la exclusión mutua yo les había
(05:40) comentado que era trivial la exclusión mutua dice pues que solo entre uno a este código este a este pedazo de código este bloque de código y para solucionarlo de forma trivial pues dices bueno que no entre nadie no O sea eso es una forma así entonces por eso están estas dos propiedades de loock free y free y bueno entonces nada más vimos este al final una vista no de cómo se usa Pues en realidad este problema exclusión mutua para resolver otro tipo de problemas pero les digo que hay muchos no O sea productores y consumidores es
(06:15) uno muy clásico este para nosotros como como comput tologos entonces la solución por ejemplo para este sería implementar un candado y Añadir una restricción Eh pues que solo se puede consumir si producto no y por qué ocupamos un candado porque dos productores Perdón dos consumidores no pueden consumir lo mismo no entonces ocupamos sincronización entonces bueno en el curso Siempre vamos a tener siempre les voy a estar hablando No pues el hilito el proceso así eh les digo que a veces los uso de forma distinta si me va eh
(06:54) Pero bueno ya vieron Por qué no en realidad pues pueden ser como lo mismo e Entonces siempre tendremos esto y además tendremos yo siempre les estaré hablando todo el tiempo de objetos y es este esta esto de objetos lo vamos a ver un montón en este en este tema y bueno Buen a ver por Entonces siempre en este tema vamos a vamos a ver qué relación existe entre ellos y bueno también vamos a ver cómo decir que un objeto es correcto Entonces qué relación existe entre los hilos y los objetos Pues bueno los hilos Ejecutan los
(07:32) métodos de los objetos no estilo Java o sea como Sí o sea como mucho esta programación orientada a objetos no se parece un montón se teoriza de esta forma entonces e y bueno una ejecución no o sea los los Ejecutan Pues esta ejecución se realiza en el tiempo y entonces lo malo o lo que nos interesa en el cómputo concurrente por lo que es difícil no es que lo Ejecutan pueden ejecutar métodos al mismo tiempo Entonces nosotros ahí es cuando hacemos un zoom en la ejecución para ver pues qué está pasando no e Entonces ya viéndolo así por ejemplo
(08:15) vemos no eh lo que vimos la toda la el tema anterior qué objeto vimos un candado no Qué es un cado pues es un objeto que permite que solo un hilo entre a una sección crítica solo un la vez y este candado qué tiene dos métodos Uno de ellos es lo que te permite entrar a la sección crítica y el otro es unlock para salir de ella no es como esta es la definición de este objeto y Y entonces es la diferencia en el libro y yo también me van a escuchar diciendo eh A veces les voy a decir miren vamos a hacer Este es un objeto tipo candado no
(08:58) O Este es un objeto una cola un objeto esto es una pila Este es un contador Este es un snapshot el siguiente tema vamos a ver snapshots entonces me van a escuchar decir como estos este Estos son objetos sí Y además existen implementaciones de objetos se dan cuenta el objeto pues es como es como este déjen escribo aquí un objeto es como la descripción descripción escribirlo descripción teórica y y pues abstracta Vale o sea lo que esperamos una cola pues es un objeto que permite que los que primero entren sean los
(09:49) primeros que se consuman no y tiene dos métodos en y así O sea como esta descripción ya que implementos como nos Pues de la gana no como analicemos como lo que queramos es distinto entonces una implementación de un candado pues puede ser peterson puede ser Decker puede ser filter puede ser Bakery no Deer es creo que no sé si lo vieron con Isabel Pero bueno Deer es un pues se parece peterson es un candadito igual para dos hilos e entonces estas son implementaciones vale o sea el candado pues es una o sea es una descripción abstracta Pero cómo
(10:30) lo llevamos nosotros a la práctica Pues con implementaciones Vale entonces es la diferencia e lo digo porque vamos a o sea como que si este siento que a veces eh dices Bueno y o sea tengo el objeto y tengo la implementación Cuál es la diferencia no Entonces es esta Okay entonces este es nuestro índice m primero vamos a ver un ejemplo qué concurrente bloqueante entonces bueno ya ya les platiqué ahorita no que es un objeto un objeto concurrente pues vamos a ponerlo Así es un objeto bueno es la descripción de Pues cómo podríamos
(11:25) decirlo noir objeto no es la descripción de un conjunto de métodos atributos y y reglas buo como la abstracción de lo que implica un objeto vale pero que que puede ser ejecut por varios hilos vale al mismo tiempo es como la diferencia si se dan cuenta pues nada más como lo que cambia con los objetos que ya conocemos Pues es que o sea los que conocemos Pues de Java no por ejemplo estructuras de datos no todos estos objetos que hemos visto la diferencia Pues es que podemos ejecutar sus métodos este bueno a ejecutar los métodos varios
(12:31) hlos no al mismo tiempo cómo lo implementamos eh un objeto lo podemos implementar de muchas formas existen implementaciones de un candado por ejemplo como les había comentado no peterson bery este depende no O sea depende A quién se le ocurra Y qué quiera y cómo argumentamos que es correcto esta Va a ser la pregunta que vamos a solucionar bueno que les voy a contar no en este tema es lo importante Cómo cómo vamos a argumentar que un objeto es correcto por ejemplo un candado Cómo argumentamos que es correcto Bueno pues que cumple exclusión
(13:06) mutua que es de free o que esv free si se dan cuenta es es la argumentación No pero en general Cómo argumentamos no que cualquier objeto es correcto Esa es la pregunta vale responderemos en este tema entonces bueno primero vamos a ver un ejemplo de una cola concurrente con candados Vale entonces ustedes Bueno tienen aquí un Quiz e Cuáles son las variables compartidas en este en esta cola por ejemplo pues aquí tenemos que las variables el constructor el método enq Cuáles ustedes ven consideran que son ems Ajá sí si es una variable
(14:02) compartida Hey Tail Ajá sí exacto y el candado no ajá si todas estas variables compartidas y ya lo que hagan los métodos adentro de loog pues es local no local a los y los entonces Pero bueno sea quiere decir que todos los los este los hilos no van a poder veril yems y tienen compartido un cado Entonces cómo funciona esta implementación pues miren Si esas son nuestras variables compartidas luego tenemos el constructor simplemente que se se inicializa con la capacidad ems Pues digamos que es comoes un arreglito
(14:55) una lista no un arreglo este pues de la capacidad vale de Pues de la cola luego inicializando he ta en cero y y inicializo lo como un Loc reentrante ahorita este este loog reentrante pues es un tipo de loog que tiene que tiene Java y me tienen que creer no que lo que hace es que pues características del Loc reentrante es que eh voy a ponerlo con este soporta que un hilo ejecute es que pienso en inglés no execute ejecute este el el dos o
(16:02) más lock métodos lock o lock o sea como que tienes el candado y no le importa que vuelvas a pedir el mismo candado vale es como lo que me tiene que creer ahorita cómo funciona r en la sección cuando veamos monitores vamos a ver cómo crear uno pero bueno mientras este pues es un tipo de candado que ya tiene Java no que pues lo que nos gusta o sea por lo que se usa es porque eh si alguien ejecuta dos veces o más Loc oa seguido sin dejar el candad no se bloquea todo bien e entonces bueno eh se inicializa de esta forma luego Existen los dos métodos
(16:44) en q y de q eh Porque pues es una cola no entonces e antes o sea para digamos que para ejecutar todo lo que está dentro del método enq se toma el candado o sea lo no lock y luego se hace un lock al final Entonces digamos que todo lo que está aquí será una sección crítica vale Y este muy interesante el candado se toma se toma con try Finally Okay Por qué Porque eh digamos que pues se intenta no ejecutar todo lo que está dentro de la sección crítica y si no se logra siempre siempre tiene que dejar el candado para
(17:31) que pues no te lo quedes no O sea ya sabemos que en Java Pues luego se avientan este eh excepciones no O sea lo que sea que pase aquí siempre siempre siempre deja el candado es lo único que dice vale o sea por lo que se pone siempre en TR Finally entonces así funciona no esta parte de en la los ems se ven como de esta forma cuenta que este es el arregl pues es como una cola así normal no un arreglo de ítems de cero hasta la capacidad no que es que es esta entonces inicialmente Tail y Head apuntan a a este a cero no O sea bueno Están en
(18:23) cero Y qué van qué se va haciendo si bueno se se Checa No si Tail este y Head No es igual al tamaño O sea la diferencia es igual al tamaño de de los ems O sea al al a la capacidad máxima pues avientas una excepción no de que está lleno y si no lo que haces es que vas a meter este el siguiente digamos que tu tu x no O sea lo que quieres en colar lo vas a meter justo en Tail módulo el número de items que tienes esta cola Vale y aumentas Tail Entonces por ejemplo cómo va va avanzando como que pues se van moviendo de esta forma
(19:06) por ejemplo aquí puse no sea e si quieres agregar uno pues simplemente en este caso como la cola está vacía pues es módulo cero no bueno pensemos como que se puede hacer esto ya ven que el módulo cero Pues algo módulo cero no se puede pero supongamos no que es como que pues este como es aoc código aquí supongamos que entonces se mete donde está ta Entonces es x entonces aquí metes la x y simplemente se aumenta ta ent va hacia acá la punta aquí no a un se queda ahí y así entonces se va aumentando si se van llenando Si siguen haciendo enq pues
(19:52) simplemente t aumenta no y luego por ejemplo para borrar algo pues es el que se mueve por ejemplo aquí igual el método enq funciona también de esta forma tenemos un lock un unlock entonces todo lo que esté aquí pues es la sección crítica critical section no eh t es igual a g Entonces si es así pues este lanzas una excepción no está vacía la cola y si no pues entonces e [Música] este regresas el el ítem el primerito en este caso por ejemplo Head regresarías x por ejemplo aquí regresarías x y simplemente aumentas O sea no borras el pues la el
(20:48) ítem que está y simplemente como que se va a ir sobrescribiendo ent por ejemplo haces esto y ahora consideras que lo que tiene tu cola pues es nada más y y z y ya pues x no lo considera entonces van a ir siempre he va a ir e siempre he va a ir antes no que ta siempre va a tener un este número menor entonces van a ir avanzando noces por ejemplo aquí pues puede ser que G está acá y ta acá entonces lo que sí no va a pasar es que he sea mayor a Ta no porque pues tenemos eh tanto la excepción no de que está vacía Entonces no puedes quitar
(21:32) nada O sea no puedes avanzar a no o también no puedes este si está llena no puedes hacer que Tail avance más que vale es como que nada más estamos dando vueltas ahí enem con este módulo así así funciona esta implementación de una cola entonces Bueno si se dan cuenta eh una un ejemplo de cómo de una ejecución de de esta implementación de una cola sería se podría ver de esta forma tenemos por ejemplo los hilos A B y C Vale entonces en realidad las líneas donde se toma el candado Pues en realidad son todo un Pues todo un intervalo Entonces qué Va
(22:21) qué va a suceder por ejemplo en este caso casi que empiezan a hacer la este a ejecutar el método al mismo tiempo no pero el que logra terminar primero de ejecutar el método Loc en este caso es c ya vieron entonces aquí c lo que hace pues es que ejecuta eh su critical section que en este caso está haciendo un dq no es como una critical section no es esta y esta es otra critical section Vale entonces va de aquí a acá entonces aquí este se ejecuta su sección crítica y deja el candado no entonces mientras estos dos ve Ya están O sea
(23:09) pues ambos quieren ejecutar algo no O sea en dos de hecho los dos quieren ejecutar un enq Este pero pues el que gana el candado es el que lo va a poder ejecutar Entonces por ejemplo aquí ve es el que termina después de ejecutar el candado y pues aquí no toma otra critical section y hace un enq deb y hasta que no lo deja es que alguien más puede puede realmente tomar el candado Vale entonces por ejemplo aquí pues él lo toma Ah lo toma y pues por fin aquí él puede ejecutarlo y y este y en este caso por ejemplo se
(23:47) quiere volver a a pasar Entonces este ya vieron que casi enseguida hace un lock no O sea te quiere tomar el cado otra vez y hasta acá lra otra sección entonces lo que nos permite utilizar ls es que los formamos Pues como secuencialmente ya vieron Ah dice Por qué se hizo de primero y no en Ah o sea bueno porque digamos que este es una situación así como aleatoria no O sea en realidad si te das cuenta pues los hilos pueden este ejecutar tanto enq como de como quieran no entonces pues pudo ejecutar un enq o ejecutar un deq no O
(24:30) sea lo que lo que él quisiera y en realidad como es una cola concurrente pues no es como Ajá dice Por qué pasó Primero c y no a Ah porque eso depende no Qué tipo de candado tengamos eh Por ejemplo como no si nos acordamos de de qué candado por ejemplo filter no en filter ya habíamos visto que puede ser que un empiece antes no Y en este caso imagínense No pues aquí empieza antes realmente pero se es más rápido y se nombra víctima este antes que ha de algún nivel le gana no O sea por ejemplo o sea como que es así no es no es no es
(25:16) como algo rígido no pero entonces items ya tenía objetos cuando empieza esa ejecución no en este caso no por ejemplo sí considera no que la cola estaba vacía este bueno es que miren aquí hacen un deq pero pues lo que se regresa es vacío no emp entonces la cola hay que ponerlo aquí vale para que lo veamos este inicialmente c colola está vacía Ah sí no había visto el mt Pero entonces Ajá sí sí sí sí es que bueno Yo casi siempre escribo las cosas así No pero en el libro luego les gusta escribirlas como que esto es lo que
(26:18) regresa no pero bueno consideren esto que es lo mismo va o sea como que lo que ejecutas al final regresas que es como lo mismito va Ajá Entonces se ejecuta la col está vacía entonces pues sí tiene sentido no se obtiene en luego B en en cola B luego a en cola a y luego c hace otro esz otro deq y ahora en cola pues lo primero que es en cola no que tiene sentido o sea en cola b y es lo que como que quería como que apreciamos no cuando usamos candados hacemos que las cosas o sea que las secciones críticas pues se Ejecutan de
(26:58) forma secuen entonces eh Como utilizamos un solo candado para encolar y desencolar pues este algoritmo en realidad no O sea funciona como secuencial o sea si analizamos esta línea de cosas que pasaron en la cola nos vamos a dar cuenta que que se pueden formar de forma secuencial no entonces bueno para analizar la corrección si se dan cuenta eh Bueno es lo que como que quer quería que viéramos primero que si analizamos la corrección de esta cola como se forman secuencial o sea en el tiempo o sea lo que lo que sucede en la cola como que es fácil de
(27:39) analizar no O sea ustedes Ven aquí o sea solo nos concentramos solamente en esta y decimos Bueno o sea c hace de qm en qb en qa y se ccola B al final pues es correcto no se es una cola realmente que cumple con fifo Bueno yo aquí les pongo No si o sea hay que analizar Cómo se traslapan las operaciones Pues sí pero aquí como que no se traslapan mucho en la cola no O sea en los lock Pues sí no pero lo lo que nos permite Pues es que al final este estos intervalos pasen seguiditos no O sea bueno de forma secuencial entonces bueno este cómo se
(28:18) les ocurre log lograr más concurrencia no O sea aquí tenemos un solo candadito compartido entonces cada vez que tú quieres hacer algo pues lo tomas no es como ponerle sincron Entonces cómo se les ocurre a ustedes que podríamos lograr más concurrencia como no sé o sea ideas Así que se les ocurre como que hay mucha concurrencia no sea bueno Se forman en la cola no se les ocurre Bueno este usaron Bueno entonces Este sí me van entendiendo
(29:23) verdad Bueno este una cosa para lograr concurrencia muy bueno Gracias es este es por ejemplo qué podríamos hacer qué tal que en vez de usar un candado usamos dos no cuando unos hacen hacen que y otros de que es que sería como ponerle concurrencia es que cómo sería Ah ya ya ya aquí un hilo cuando se enca Ah okay Ah dice o sea una forma sería cuando unos hacen en y otros de Ajá sí O sea como poner dos candados no le ponemos un candado solo a deq y otro enq Sí Fernanda por ejemplo ponerle más concurrencia a la a lo que me refiero si
(30:08) es que es son extraño no eh ponerle más concurrencia sería permitir que se ejecuten por ejemplo en este caso se ejecuta todo de forma secuencial no O sea al final con los candados con un solo candado hacemos que todos se formen entonces si yo quiero que mi algoritmo sea más concurrente O sea que que aprovechemos más este Entonces como dice exel no permitiría que que este en vez como de poner un lock pues pusiéramos no se lock uno y hago otro log do Y entonces hago que el log uno lo tome los enc y el log 2 lo tomen
(30:53) los de que no Entonces al final podríamos permitir que se ejecuten en q y de q justo al mismo tiempo no O sea como si usamos esto podríamos permitir que suceda algo así e como a b c y como este está peleando por un candado y este está peleando por otro por ejemplo este es el log un y este es el log dos Pues podría ser que ejecutemos el enq y el de que al mismo tiempo no por ejemplo o sea como y así tendríamos más concurrencia O sea como es A eso me refiero como eh permitir que las cosas se traslapen más Ajá ese es un problema
(31:37) Exacto hay que ver cómo hacemos esto porque eh si por ejemplo alguien está encando algo no y alguien justamente está borrando algo qué tal que no lo encola justo al final no O sea lo encola después no O lo encola antes y entonces ahí ya no se cumple fifo Ajá o sea como que tiene su chiste no y y la otra sería o sea como pues una pero como por ejemplo cómo cómo propiciamos más concurrencia solución uno usemos más candados Ajá sí su raro Sí es que como tiene así su chiste eh percimos más candados solución dos Bueno pues qué tal que no somamos
(32:18) candados no O se es como la otra aj un candado para los candados Ajá Sí de hecho hay implementaciones así e entonces Bueno definitivamente como dice Fernanda no sea como que ahí está extraño qué pasa con los valores de la cola Pues sí realmente es más difícil uno hacerlo y dos demostrar que es correcto o sea todo se vuelve más complicado no eh entonces Bueno una forma eh de cómo funcionan estas propiedades de corrección para demostrar que que es correcto es transformar ejecuciones con correntes en secuenciales y analizar la
(33:01) ejecución de las secuenciales Ah entonces Bueno ahorita vamos a ello vale Pero bueno es la idea es mucho esta palabra de transformar concurrente a secuencial entonces Bueno Este es otro ejempl ito de una cola concurrente sin candados pero solo es para dos hilos no O sea que chafa Pero bueno sea para nilos no los hilos que sea esto solo es para dos pero que nos permiten utilizar candados entonces e vamos a ver que solo es para dos hilos y que de hecho solo un hilo puede encolar y que solo otro puedes encolar Vale
(33:48) entonces este cómo funciona eh tenemos este variables compartidas otra vez no pues y ems vale Cómo se inicializa simplemente pues otra vez es este circulito de ems vale es la misma como abstracción Entonces se inicializa en el tamaño de la capacidad van a cero Entonces ya vienen aquí pues ya no hay candados O sea pues ya se hace lo que lo que este lo mismito en realidad miren solo igual no se compara si hay este espacio Eh bueno si si hay espacio para encolar pues lo hago No pero si no pues lanzo una excepción Entonces ya para encolar pues
(34:37) hacemos lo mismo nos fijamos en En dónde está Tail y metemos nuestra x y aumentamos Tail vale Y eso es para encolar para desencolar otra vez Es lo mismito No si está vacía pues no des encol nada pero si no está vacía pues leemos al que apunta Head y aumentamos este el apuntador de G Y regresamos simplemente la x no [Música] entonces y bueno es curioso no Esto bueno analizando no ustedes qué creen o sea tenemos por ejemplo dos hilos tenemos un hilo a Y tenemos un hilo B a y b y vamos a pensar que es el en en y v es el
(35:37) de entonces e pues por ejemplo pues quiere encolar cosas no en q a en qb así él quiere encolar cosas no entonces en por ejemplo no en Pues si va solito no tiene mucha ciencia No pues él simplemente hace cosas ahí y bueno vamos a pensar que é quiere encolar c y se queda ahí como pasmados no y luego B pues quiere aquí este él quiere hacer de simplemente no entonces como que aquí como que qu regresaría no es la pregunta de y de bueno aquí que regresa no entonces La pregunta es esta este como que ve o sea es como la pregunta es si ya se
(36:41) congela O sea si ya se queda como aquí dormido No pues o sea ya no terminó o sea iba a ser el enq empezó pero no acabó Entonces como la pregunta es afecta a b o sea B tiene algún impedimento en seguir desencolado entonces bueno esa es la pregunta dice no detiene dice Camil no lo detiene solo ve tira la excepción de ta igual a Ajá exacto no y ya está entonces empty empty y ya está eh Okay entonces Déjenme ver acá a sí hay que dejarlo así entonces Bueno aquí en estas vamos a suponer no que pues aquí realmente é desenca a aquí
(37:25) desenca no sé aquí dicen colas porque pues ya está o bueno puede ser que realmente no acabó a no que nunca dispuso s o puede ser que sí no pero vamos a poner vamos a pensar que sí y ya Lu ponemos No pasa nada no dice pues nada más hace un deq y regresa la excepción No importa que ya se quede pasmado por siempre no Entonces sí pues no no pasa nada entonces cuando no usamos candados este el el que se detenga pues no nos molesta no no detiene el progreso de los demás hilos en este caso solo son dos no entonces el que el que hace detenga no
(38:22) no detiene el progreso de B pero si se dan cuenta en la anterior aquí sí no si algún hilo por ejemplo ha se detiene aquí no y y este y pues no deja el candado pues entonces todo se detiene no es distinto cuando usas candados y cuando no Bueno entonces e esa es una cosa El Progreso no O sea como es es Es como eh Progreso aquí se ve no El Progreso de los hilos y luego acá o sea además hay que hay que analizar tenemos esta misma implementación hay que ver no bueno las operaciones ahora se traslapan y este entonces hay que ver no realmente se
(39:15) sigue manteniendo fifo o sea realmente es correcta esta ejecución con respecto a una cola O sea si si permitimos que las cosas se traslapen Déjenme copiar esto o sea como que qué podría pasar no entonces eh Por ejemplo dónde y aquí como que para analizar si realmente esto es correcto si no vamos a tener una situación ahí extraña como dice como dice Fernanda no sea pasa algo con con los valores de la cola no si permitimos que se en q y de q al mismo tiempo entonces bueno por ejemplo dónde estaría eh Dónde es donde tiene efecto una
(40:06) operación en el método enq no O sea Cuándo realmente los demás s los perciben que algo se agregó a la cola en este caso cuando el el deq no percibe que algo se encol Pues bueno sería en la en la en la línea 12 no en la línea 4 es dice dice Camilo la línea 4 1 2 3 cu O sea la línea cu del enq no a Sí sí Ah Sí justo no es línea cu o sea línea 12 Entonces en esta línea justo como dice Camilo No porque si por ejemplo si está aquí haciendo cosas el hilo no y por ejemplo aquí pues él dice ay voy a ver si está llena no ay no está llena
(40:54) entonces voy a escribir mi y por fin aquí es que dice Ah voy a hacer Tail más más no Y entonces cuando Tail sea diferente este Porque si por ejemplo el hilo de ker va a decir bueno Tail es igual a g o sea son igual a cero Pues no hay nada hasta que vea que Tail cambió es que realmente el el hilo Deer va a poder este leer No pero no va a poder leer o sea aunque el hilo en colador ya haya escrito x y no mueva Tail o se si no mueve Tail él no va a poder leer este último ítem que que el ener escribió no Entonces es esta justo esta línea no es
(41:43) justo esa línea entonces a fuerzas para que el deq haya regresado a pues quiere decir que a fuerzas eh la línea e 12 no la de Tail más más tuvo que suceder antes que este la línea 15 esta de Tail menos Head igual a cer No porque si no quiere decir que están en el mismo no O sea no este entonces bueno sea para que se tuvo para que se haya regresado a tuvo que haber pasado esto No porque si no el de regresó empty se Si no si no sucedieron este en este orden entonces Bueno ahí no hay problema o sea como que dice sí tiene sentido no
(42:42) O sea no no van a pasar cosas raras en este caso ese es un ejemplo Pero bueno Déjenme ver si vemos la corrección de esta No creo que no Entonces Bueno sí Acabo de explicarles esto [Música] eh Bueno ese es un ejemplo Déjenme copio esto otra vez Ah perd sí ahorita ya voy puedo copiar esto ni lo copié bueno cre que estoy acá Entonces yo lo que les había comentado zuriel es que que es correcto que de qw regrese a pero es muy importante notar que si
(43:46) regresó a quiere decir que la línea 12 en donde el el en hizo Tail más más No o sea por fin modificó el apuntador de Tail qui decir que que esto tuvo que suceder antes que la línea 15 en donde el de q ve si realmente t es igual a No Ahí es donde ve entonces forzosamente Tuvo que pasar pues que línea 12 sucedió antes que línea 15 vale para que pudiera regresar el deq el de qa otra cosa pues también pudo haber sido no lo puedo copiar pegar Okay entonces eso es una forma la otra cosa pues qué puede haber pasado no
(44:46) en realidad puede ser que regresemos en q a o puede ser que regresemos en q empty no O sea pues que no lo leímos Por qué Porque la línea 15 eh En este caso podría ser no que sucedió antes que Tail no que la línea 12 del enq vale o sea pod puede ser Entonces no no vio que realmente escribió el encuer Entonces por ejemplo si acá [Música] eh este por ejemplo supongamos no que después el deq de B qué podría pasar no otra situación dejen borro esto y supongamos que que
(45:53) se que se traslapan no imagínense que se traslap un deq con dos enq vale qué podría pasar pues bueno eh aquí eh Como en realidad ya se escribió a o sea digamos que nuestra cola pues ya tenemos esto no Entonces tenemos a no imagínense que ahí va Head y Tail ya está aquí entonces qué podría pasar Bueno pues en realidad independientemente de que de de cuandoo pase la línea 12 del método enq Pues en realidad el o sea el deq siempre va a regresar a no O sea no no importa aquí Cómo se traslape no siempre tiene que regresar a por qué Porque
(46:44) he pues está en el primer elemento no y de hecho ya Tail es distinto a cero entonces va a ver que pues la cola no está vacía este forzosamente va a pasar a la línea 18 y entonces se va a dar cuenta no que get eh apunta a a Y entonces qué va a hacer pues va va a mover Head no ay va a mover Head acá no y va a regresar a independientemente de Cuánto tarda en escribirse B no O sea de cuánto tarde pues no no le importa o sea no no se puede avanzar dos veces no O sea como para que pasen cosas raras solo solo avanzas de uno entonces este como que
(47:32) funciona en realidad esto porque solo somos dos hilos No pero si fuéramos tres ahí sí habría un problema o sea si alguien te avanza el get doble no ahí sí habría un problema pero en este caso funciona Vale entonces funciona cuando se traslapa un dq con un enq cuando se traslapa un dq con dos enq o cuando se traslapa un enq con dos deq también funciona vale porque get solo se aumenta uno no y siempre estás checando que Tail no alcance a get y los dos tienen que siempre ver eso vale entonces por eso funciona pregunta nunca se borra al
(48:08) elemento arreglo no no se borra o sea ahí se queda y se sobreescribe lo que va avanzando son heavy Tail vale Ajá sí solo se mueve la cabeza m Sí sí sí entonces Bueno ahí voy eh Entonces eso es un ejemplo vale vios una cola concurrente para nilos pero que es bloqueante O sea que usa candados y Vimos una cola concurrente no obviamente concurrente para dos hilos nada más pero que este no utiliza cantados O sea que es no bloqueante vale o sea son dos dos implementaciones distintas de una cola Entonces vamos a notar que las
(48:55) implementaciones de objetos tienen condiciones de Progreso y también tienen condiciones de corrección las de Progreso tienen que ver con esta propiedad de viveza es decir como que suponen que algo bueno en algún momento pasará Vale entonces por ejemplo deathlock free starvation free son condiciones de Progreso pero entran en el lado de las bloqueantes eh Y y este y ahorita vamos a ver no Qué hay de lado de las no bloqueantes entonces la diferencia entre que sean bloqueantes o no bloqueantes Es que este el el es en el progreso o sea Pues justo
(49:38) no en el retraso si si un hilo se retrasa la pregunta es bloquea los demás o no las bloquea vale o sea y es la diferencia en esta implementación si un hilo que está ejecutando el enq se pues se pone lento no O se detiene y no deja el candado o sea realmente dice aquí como Ah Ya voy ya voy no y no deja el candado este pues los otros hilos este se quedan como en cuello de botella no todos tratando de de hacer el deq o enq no O sea Todos quieren hacer progresar pero el hilo que se quedó con el candado medio dormido que va lento Pues nos
(50:19) detiene a todos y en este caso acá no no O sea si el hilo encolador o el desencolado se detiene pues no pasa nada el otro hilo simplemente va a decir pues regreso que está lleno O sea ya cuando ya no puedo meter nada pues digo ahy está lleno está lleno y si no ya no hay nada que des encoder pues simplemente regreso está vacío pero no me pasmo ahí no O sea termino y ya está Entonces es la diferencia y justo como que es lo que veíamos no la la el tema anterior que ustedes me comentaban no como bueno Qué tal que hace detiene Sí pues si hace se
(50:57) detiene Pues nos retrasa a todos porque estamos usando candados no estamos en este lado de los bloqueantes y y este y bueno entonces les digo no existe otro lado en donde no sucede esto Ah entonces bueno justo no es bloqueantes si el retraso inesperado de alguno de los siglos retrasa a otros y estos retrasos Eh pues di buenoo cómo va a ser no que alguien se retrase Pues bueno sí sucede no porque pues las máquinas pues no se están resolviendo varias cosas no no es como que controlemos que todos se muevan a una
(51:35) misma velocidad y también depende pues del sistema operativo en realidad pues una cosa es nuestro procesador no y otra cosa es todo lo que está encima Entonces sí O sea hay como pues así cierta no que me pregunten Por qué se tuvo este candado justamente o sea Perdón por qué se tuvo este hilo está cañón no pero hay que entender no que hay muchas variables entes en realidad pues un hilo Pues en nuestro caso este nuestras compos tienen los hilos pero sobre ello está nuestro sistema operativo y sobre ello está Eh pues llva no la máquina virtual
(52:11) entonces de allá a ver que por qué se detuvo un hilo peroo se detienen no y no corren a la misma velocidad entonces eh Por ejemplo aquí se ven no sea si si utilizábamos un candado peterson no y dos hilos están aquí tratando de de ejecutar este esta cola Pues si este se detiene detiene al otro no y hasta que no dej estee el candado Es que este va a poder hacer su método no O sea no seq un enq entonces bueno deadlock free y starvation free son condiciones de Progreso bloqueantes y y es por eso justo que está como esta
(52:55) palabra de eventual mente no O sea eventualmente no sé cuándo no pero eventualmente alguien va a pasar no O eventualmente todos vamos a tener éxito Vale entonces mucho esto como Pues si es que si ya se detiene Pues si nos atoramos No pero eventualmente va va a despertar no O sea O se va a mover y una implementación No bloqueante si alguien se atrasa pues no nos detiene a todos Entonces es como eh en esta no O sea en este en esta implementación si por ejemplo pues yo estoy ejecutando aquí un deq luego un enq este Ese es el
(53:39) hilo sería el desencolado y está el encolador no entonces este se se llega a detener no pasa nada no O sea pues va a regresar mt por siempre y nada pasa vale está bien si alguien se detiene este no me afecta ni me doy cuenta no entonces eh Qué tipos de porque ya vimos no deathlock free starvation free son block anes Por qué regresa empt aj Sí es que ya vimos no que esta operación este puede regresar empty o puede regresar eh que se c colo dos no Cuál es la diferencia es que eh Por ejemplo aquí para que este regrese empty tuvo que
(54:25) haber pasado la línea 15 antes de la línea es la línea 12 no la de Tail más más por qué Porque el hilo el desencolado no se va a dar cuenta que hay pues algo no en los candados no hay entonces en los no bloqueantes no hay candados sí exacto sí O sea si si no ven candado hay que si hay candado es así bloqueante O sea no hay de otra es idea Ay Oiga este diseñé un sistema con candados Bueno diseñaste un sistema bloqueante no Y si no hay candados hay que analizar porque seguro es no bloqueante no Sí o sea regularmente son No
(55:17) bloqueantes si es así es casi un hecho no sé O sea no lo no lo generalizo porque no sé no O sea qué tal que hacen una implementación no tremenda y Se bloqueó no Ajá pero sí vale entonces sí O sea les digo como que pues este ser podría regresar dos o podría regresar m depende el orden en el que se ejecute la línea 15 y la línea 12 pero eso es un ejemplo realmente este es una ejecución ejemplo de esta implementación o seaas corresponde Okay entonces wait free A qué se refiere bueno eh un método es we free si decimos así s
(55:57) que cada llamada a un método termina su ejecución en un número finito de pasos Vale entonces eh si se dan cuenta aquí weit free o sea bueno si no usa cand wait fre Pero además te garantiza que que todas no o sea es las llamadas es decir todos los entonces este es lo que nos dice no wiit free Entonces sí se podría ver así garantiza que todo que cada hilo progrese que todo hilo progrese Okay entonces eh En este caso est esta implementación ya vieron hasta la nombraron así en el libro pues es una
(57:00) implementación fre Por qué Porque el retraso de a no interfiere con el progreso de b y b puede terminar su ejecución siempre en un número finito de pasos no sea no no se queda dando vueltas como en los candados y este y además esto sucede también para para bueno sucede también para B no para B entonces también el retraso de B no interfiere con el progreso de a o sea como que ambos progresamos no puede ser que solo uno progrese los dos o sea esta implementación es solo para dos hilos y todos progresamos independientemente de que el otro se
(57:38) detenga entonces bueno Esa sí una pregunta como que si me cacharon no me venido entendiendo según yo está fácil este esta implementación es weit free sería por ejemplo Cómo la ven dice pues si Camilo es el que no también Eduardo si no no es no por qué Porque los candados Exacto fre no usa candados No jamás no usa candados y esta pues es una implementación lo bas basada en candados entonces simplemente por esto decimos que pues ya no es we free Vale qué podríamos analizar de esta implementación Pues de esta si podríamos
(58:24) pensar no sea bueno respuesta pues no es eh Pero bueno podríamos analizar si es eh deadlock pre O sea si no hay candado muerto o si no se mueren de hambre no starvation free son dos cosas que sí podríamos analizar sobre esta implementación pero así así de pura vista decimos Ay usa cs no no O sea no puede ser Vale entonces así este y bueno está lock free Perdón está wiit free y está lock free que es distinta de lock free Okay pero bueno creo que no me va a dar tiempo pero nada más les digo ya la siguiente clase Empiezo con esto lock free un método va
(59:21) a ser lo garantiza que infinitamente seguido alguna llamado todo acabará en en un número finito de pasos Cuántos infinitos no pero bueno Eh Lo importante de l free es esta palabra no alguna quiere decir que algún proceso termina en un número finito de pasos y esto cada cuánto pasa pues infinitamente seguido vale es como lo que dice lock free Entonces si se dan cuenta weit free es como todos y lock free es alguien alguien acaba en un número finito de pasos e entonces bueno Esto se ve así ya nada más para terminar así lo vemos vale
(1:00:11) tenemos implementaciones no bloqueantes bloqueantes y este la diferencia por ejemplo es que si todos progresan o alguien progresa y ya vieron la wiit free pues es como el análogo a starvation free pero para los no bloqueantes y lock free es el análogo a lock free para los eh igual no bloqueantes vale entonces así se ve y ya ahí Ahí le dejamos Entonces nos vemos el miércoles vale que tenga buen inicio de semana Bye
