(6) 2024 10 01 10 01 41 - YouTube
https://www.youtube.com/watch?v=p6bP0yYd56Q

Transcript:
(00:29) al al al al al
(02:35) les va en la vida Hola Dulce Oigan se acuerdan que Hola Alan les estaba contando que mi película favorita de cuento in tarantino era la de perros de reserva resulta que fue su primera película o sea y sí se nota bastante No sé si ya la vieron pero sí véanla O sea está 100% recomendada pero sí se nota bastante Y además es un hito porque resulta que este era una película o sea para empezar fue su primera película y luego e o sea se considera una película como que una mezcla entre dos películas porque era su primera película
(03:30) y en sí Él trabajaba en una como donde prestaba las películas Entonces siempre había querido escribir algo pero pues nunca le había salido nada y eh esta película la iba a hacer como con muy poco presupuesto con sus amigos pero o sea no No me pregunten Cómo resulta que este que su guion llegó a a un productor importante y este dijo No pues está buenísima y la produjo Entonces está muy chistosa porque pasa todo en un escenario pero está muy buena entonces básicamente véanla está muy buena Cómo van con su tarea Cómo van con su
(04:21) tarea perros de reserva se llama Solo falta el cco Ah muy bien Ahorita lo vemos llevan tres o sea los primeros tres Ah Muy bien buen es hoy vemos el cuatro y el cinco les parece Oigan ya les dejé a todos comentarios en su tarea tres Hoy les mando las calificaciones para que las revisen Y si tienen dudas Eh me preguntan va entonces okay la idea del día de hoy es revisar bueno volver a revisar el ejercicio 3 de la tarea revisar el ejercicio 4 y el ejercicio 5 y Si tiene alguna duda verla ahorita el jueves no voy a poder darles
(05:16) clase Porque este tengo un examen en el instituto Entonces nos veríamos hasta el siguiente martes va entonces si tienen duda de cuier cosa pregúntenme Ahorita va Okay entonces se acuerdan lo que habíamos dicho que era un snapshot no los snapshot la mayoría de los snapshot se basan en los registros atómicos que ya habíamos visto y acuérdense que los registros atómicos son los registros más seguros no porque lo que les da los registros atómicos es una garantía de que solo van a tener dos valores posibles al regresar algo y los
(06:00) snapshots básicamente es cuando ustedes quieren hacer un multi No acá incluso cuando ustedes quieren hacer multi aquí leer múltiples valores ustedes van a necesitar un snapshot un snapshot lo que les va a regresar Es un arreglo de cierta forma de estos múltiples valores es como si taran una captura de pantalla de de un montón de registros entonces de estos registros ustedes van a poder leer múltiples valores gracias al al arreglo que les regresa el snapshot entonces un snapshot atómico construye una vista instantánea
(06:42) de registros atómicos sí un snapshot es básicamente e un un tipo de de de captura de pantalla si lo pueden ver así eh sobre cómo se llama sobre sobre un un montón de registros atómicos sí Okay entonces eh su ejercicio tres todos más o menos se acuerdan lo que hicimos la vez pasada para para el ejercicio 3 el ejercicio 3 les dice qué les decía su ejercicio 3 que demostraran que era esta implementación que era bounded weight free no No si mal no recuerdo Sí sí Okay entonces para demostrar que era bounded weight free acuérdense que
(07:43) nosotros siempre vamos a tener dos casos tenemos el caso en el que este las llamadas a los métodos no se traslapan y el caso en el que las llamadas sí se traslapan no entonces el caso en el que tienen que anotar los dos pero básicamente el más fácil es el caso en el que las llamadas no se traslapan porque si no se traslapan significa que un hace ya sea un update o un scan solos Entonces si se dan cuenta esta parte de acá Este la línea ahora vamos a ponerlo con verde esta línea esta línea está está no esta línea esta línea y
(08:32) esta línea son constantes toman tiempo constante la única línea que no toma tiempo constante es esta por el scan entonces esa línea toma el tiempo o toma la complejidad del escan acuérdense que scan básicamente también tiene muchas constantes pero lo importante acá es estas líneas de acá los collects y la hasta acá todo lo demás es constante si se dan cuenta o sea todo esto del aquí acá es lo que nos importa para sacar la complejidad del escan y todo lo demás lo hacemos en tiempo constante no bueno excepto Este pero básicamente lo hacemos
(09:19) en qué tiempo en tiempo la complejidad odn no en tiempo lineal Entonces esta parte de acá si un hilo está ejecutando el scan solo significa que nada más eh que cuando ustedes estén haciendo el scan y se recolecte la copia no va a ha e no va a ver o sea el scan no puede ver que otro se movió porque está solo Entonces esto Solo va a pasar una vez sí este While solo se va a ejecutar una vez porque no va a haber una diferencia entre las dos copias que que vaya a tener eh este scan entonces ent si solo se hace una vez básicamente lo que se
(10:02) tienen que enfocar es en esta en esta línea de acá igual si se dan cuenta es odn Entonces cuando y acuérdense que nosotros queremos que sea bound we free es decir que todos terminen en Alo más o de n cuadrado pasos y cuando nosotros tenemos el caso de que no se traslapan si termina en o n cuadr pasos y más aún termina en tiempo lineal porque lo que nos importa lo que ustedes necesitan ver para sacar toda la complejidad es de la línea 14 a la línea 24 eso el While nada más ejecuta una vez Entonces nada más ejecuta una vez tienen que fijarse en
(10:50) ese for ese for se ejecuta o sea hace n iteraciones entonces tiene complejidad odn entonces en el caso en el que no se traslapen con ese argumento ya pueden sacar que sí es bounded we free o bueno que termina lo más el odn cuadrado pasos en el caso que no se traslapen tienen que termina en al lo más odn pasos y más aún en odn cuadrado pasos la complejidad de collect eh la complejidad de collect según yo si mal no recuerdo era igual lineal porque lo único que hace es que revisa la tabla revisa la tabla y actualiza eh o sea
(11:41) esta misma tabla Pero entonces acá la complejidad Sí lo pueden hacer pero básicamente es igual tiempo lineal la parte fuerte de este ejercicio es Cuántas veces se hace el While y o sea la parte que nos importa aquí es Cuántas veces se hace el While Y cuántas veces se hace el While depende de Cuántas veces sean diferentes las copias que tiene el scan Entonces tenemos el caso Sí más o menos va Y entonces acuérdense cuál era nuestro segundo paso cuál era bueno el segundo caso más bien Cuál era el segundo caso que habíamos visto
(12:34) n updates concurrentes muy bien n updates concurrentes y como la maestra creo que nada más les pide para cuatro hilos pues pueden ponerlo como cuatro updates concurrentes No pero si si lo quieren generalizar es n updat n updates concurrentes Entonces cuando ustedes tienen updates concurrentes eh imagínense que los hilos a b c y d todos un update eh al mismo tiempo no y nos interesa que se traslapen que se traslapen Por qué Porque si no regresamos a nuestro caso uno y en ese ya habíamos visto que es bounded we free
(13:14) entonces en nuestro caso dos lo que tenemos es que imagínense tienen el hilo a b c y d entonces este imagínense que eh de llama scan no O sea vamos a hacerlo de acá para atrás porque todos tienen que ir ligados no necesitamos que las cuatro se traslapen para estar en el peor de los casos con nuestros cuatro hilos entonces imagínense que d manda Llamar a scan y ve que alguien se movió entonces d hace el esan pero ve que alguien se movió imagínense que es B O sea nada más ve que B Se movió entonces a ver mejor vamos a poner
(14:02) as llega d y este d hace su copia normal de hace su copia normal suct y luego d que B Se movió B Se movió y entonces de tiene que o sea para este punto tiene que volver a hacer el collect Pero como se movió Entonces esta de acá nada más para que se haya movido que ya terminó de hacer el update para que haya terminado de hacer el update significa que ya pasó por su línea tres que es el escan Entonces como en este supuesto B no ha visto o no tenemos que B vio que se moviera alguien más B terminó en odn pasos pero este de vio que B Se
(14:52) movió no y luego este c también vuelve a llamar scan y ve que d Se movió porque d llega no normal pero ve que B Se movió Entonces se tiene que volver a mover y C no sé si lo van viendo Así se ve que d Se movió entonces para este punto determinó en este o de dos n pasos o sea se van acumular las veces que se movieron o las veces que vieron al otro este moverse entonces luego llega este a y a b que c Se movió pero c había visto que si se dan cuenta C había visto que d Se movió d terminó en dos n pasos entonces c vio que uno
(15:53) que terminó en dos n pasos Se movió eso significa que hizo un paso más tres n Ya vio que c Se movió y como c había visto tres n pasos y a tuvo que moverse por c se acumula y termina en cuatro n pasos si lo ven o sea básicamente va así esto llega este d llega b y luego d ve que B Se movió d no ve a nadie entonces termina y termin en o a la n pasos porque no ve a nadie moverse Entonces no tiene que volver a hacer ese collect y nada más hace el While una vez Entonces lo que nos interesa es el mismo o sea la misma
(16:44) análisis que el caso uno luego d ve que vio que B Se movió y se acumulan entonces hace o2 n y así se van acumulando o sea se van como que ligando de cierta forma y si lo generalizan tienen n y n tardaría o nn Y esto es odn cuadrada pero si lo ven todas estas es básicamente todas estas están contenidas en la complejidad n cuadrada decimos Cuántos collec for hace cada hilo Eh sí sí sí sí sí sí pero básicamente Ah sí eh lo que nosotros queremos es una ejecución donde o sea queremos El ejemplo donde todos están traslap con
(17:46) todos no entonces Imagínate que tú tienes todos estos que se están traslap sus llamadas y pero no necesariamente se traslapan eh sus llamadas a scan se traslapan sus updates pero no sus llamadas a escan Entonces ve es el primero que hace un escan Sí entonces B hace un escan y como no hay nadie o sea imagínate que B es el primero que hace el escan B es el primero que hace el scan Entonces es como si lo pasara solito y ya habíamos visto que eso termina en tiempo lineal hasta ahí sí va y luego fíate que B es el segundo
(18:30) que hace el scan entonces d hace su copia Pero además tiene que volver a repetir el While porque vio que B Se movió Entonces lo hace dos veces luego c tiene que se vio que B Se movió Entonces si d hizo dos ejecuciones de While y C vio que d Se movió o sea fue el tercero Tuvo que pasar por esto por esto entonces y por el mismo Entonces lo ejecutó tres veces o sea ese While lo hizo tres veces y luego a vio que c Se movió pero c había visto que d Se movió y d vio que B Se movió entonces se van acumulando esas llamadas y Tuvo que
(19:23) pasar por esto por esto por esto y por esto tuvo que hacer cuatro ejecuciones del Wi entonces eh el tiempo en el que termina cada hilo es este de acá o n o 2n o 3n y o 4n Pero si te das cuenta todos estos básicamente es complejidad lineal no O sea básicamente todo esto es complejidad así y entonces de ahí ya puedes ver que más aún está contenido en N cuadrado pasos esos cuatro hilos no Entonces todos en el peor de los casos van a ser a lo más eh en cuadrado operaciones ya quedó mejor va todos los demás es más
(20:32) bien okay va luego el el ejercicio cuatro es relativamente más fácil les dice describe una ejecución del snapshot obstruction free en la cual el método escando un hilo a Nunca termina consideren n = 3 hilos esta parte está bastante fácil en En dónde no terminaría O sea dónde quedó Ajá En qué parte no terminaría cuando un hil lo hace scan y los otros dos hacen muy bien la parte que ustedes tienen que revisar es este While de aquí entonces se va a quedar eh se va a quedar en ese Wi O sea no va a salir de ahí no
(21:36) sale no sale de ahí en qué caso no sale de ahí si se dan cuenta ese While se queda o sea se queda pegado o siguen ejecutando ese While si las copias son diferentes Entonces no sale si la copia vieja y la nueva son diferentes entonces básicamente son diferentes entonces la única forma de que no termine sería usando este ciclo While entonces las copias Uy vamos a escribir las copias son diferentes las copias viejas y la copia nueva son diferentes entonces para que estos sean diferentes los otros les piden tres hilos no los otros dos os
(22:29) tienen que estar haciendo updates infinitamente si hacen updates infinitamente como decía José eh las copias viejas y nuevas van a ser infinitamente diferentes o sea siempre van a ser diferentes entonces van a ser diferentes por un número infinito de tiempo porque se están haciendo updates infinitas y este Eso hace que se quede infinitamente en el While Y eso hace que no salga del While s lo V sí le van más o menos sí los demás va entonces en general tienen dudas
(23:38) hasta acá del anterior y de este no Okay entonces eh para este para el cuatro nada más tienen que argumentar En qué caso se quedaría siempre en el While Y ese es si las copias son diferentes y tienen que argumentar En qué caso las copias serían diferentes Sí y luego el último ejercicio de su tarea no lo copié pero eh les decía algo como si se cambiara esta de obstruction free creo si la la implementación del snapshot obstruction free o sea este de acá el obstruction free no Entonces sí si se cambia la implementación del scan del obstruction
(24:35) free a este de acá se podría eh que se hiciera esta ejecución de acá y seguiría siendo linealiza sí o no eso es lo que les pregunta Entonces primero vamos a ver cómo cambian eh los scan qué es lo que ven de esos scan O sea qué cambia de los scan qué cambio solo ha un collect y termina muy bien José sí acuérdense que en este snapshot de obstruction free lo que hace o sea vean esto acá esto de acá les está asegurando ahí está les está asegurando que va a ser Va a ser un collect y luego eh si la copia vieja es diferente a la
(25:34) copia nueva eso significa que algo más se movió no va a comparar dos copias Entonces al comparar estas dos copias eso significa que va a tener una segunda verificación para revisar que todo siga como aparecía en su primer collect y no haya cambiado nada en caso de que cambie va a actualizar ese collect y va a volver a revisar Entonces al menos va a hacer dos verificaciones para o sea va a tener como dos veces que verifica si esas copias siguen siendo iguales si no se ha movido nada más o si no se ha hecho un update sí Entonces en este
(26:19) caso por como cambiarían scan eh este scan No verifica si buen No verifica dos copias lo que hace Es que hace una copia y eso ya actualiza es a el While es esta parte de acá es esto acá y después se actualizan los resultados y no se actualiza en en el obstruction free no se actualiza hasta que estén seguros de que la copia vieja y la copia nueva son iguales y esto Qué significa que no hubo un update desde la última vez que hicieron un collect entonces después de que revisan que no hubo un update después de que hicieron al collect ya es
(27:03) cuando empiezan a actualizar e el resultado entonces acá lo que hace Es que la parte que tienen ustedes de collect o sea toda esta parte es la que tienen ustedes de collect en el obstruction free y acá la parte de collect es esto de acá y si se dan cuenta Esto es lo mismo se actualiza el resultado pero el resultado ya no se actualiza o sea ustedes pueden con con este método scan pueden hacer un collect y luego puede que vuelva a haber una actualización entre ese collect y O sea concurrentemente que haya una actualización entre el anterior entre el
(27:48) anterior collect y no lo vean sí Entonces esto es un poco más tienen que tener más cuidado cuando ustedes estén viendo esto porque significa que no siempre van a tener esa garantía de que si dos se traslapan siempre les va a mandar o sea siempre va a revisar eh si hubo un update diferente sí Entonces les dice podría suceder la siguiente implementación supongamos que inicialmente el arreglo está en empti todo podrías suceder o o no podría suceder si no y por qué ustedes qué creen J dice que no y dice que sí no ya
(29:00) que update c terminó antes que update B inicie sí Y Gael Por qué sí por y los demás qué creen por no se está comparando lo con lo nuevo no Okay ahorita vemos los demás sí o no No Bueno entonces e hay Okay vamos a hacerlo de atrás para adante no supongamos ya tenemos este resultado no este de acá para este punto Qué significa según yo no porque en el arreglo no está c no Ajá muy bien Vamos
(30:06) para allá entonces vamos a empezar de atrás para adante e a veces es conveniente empezar de atrás para adelante o sea el resultado para atrás no sé si o sea si han puesto se acuerdan de esos Laberintos que nos ponían como que en la primaria que tenías que encontrar la desde el punto de inicio hasta el punto final pero no tenías que topar con pared o sea era como que el laberinto ese Ajá eh normalmente era más fácil o sea cuando no encontraban la respuesta era más fácil eh empezar de atrás para adelante no Y eso a veces es cierto
(30:51) cuando tienen algo medio complicado o complicado a veces es conveniente empezar de atrás para adelante por ejemplo en la investigaciones eh yo publiqué un artículo en una revista de genética española de Inteligencia artificial y enfermedades raras con unos investigadores de la Universidad de Arizona y este estuvo curioso porque la investigación o sea como le hicimos la investigación normalmente Las investigaciones pues tienen este este formato no de cómo de cómo hacerlo entonces eh empieza o sea todos tienen esta idea de cómo se tienen que hacer
(31:31) las investigaciones eh Cómo tenemos que recabar las bases de datos o sea seguir paso por paso No pero estos investigadores eh eran de los más importantes de oncogenética no bueno son entonces e me dijeron No es que las investigaciones nosotros las empezamos de atrás para adelante de los resultados para la hipótesis y después O sea cuando cuando estuve haciendo más de estas investigaciones todos los investigadores importantes empiezan de atrás para adante Y esa técnica normal o sea parece Yo pensaba que nada más se usaba en
(32:14) estos Laberintos pero también se utiliza investigaciones también se utiliza eh Por ejemplo en el diseño de software se utilicen muchas cosas Entonces si ustedes no le ven la respuesta a algo mi recomendación es que empiecen de atrás para adante pero no se lo digan a nadie no porque es como que una blasfemia en la investigación Y si le dicen a alguien lo voy a negar pero sí empiecen de atrás para cuando no vean la solución a algo entonces empecemos de atrás para adelante ya después de esto e acá este este scan o sea tenemos el
(32:52) resultado de un escan y el resultado de este escan nos dice que vio a b si lo ven entonces partimos desde ahí el collect que hizo el scan acuérdense que este scan Nada más hace un collect sin importar quién se mueva Nada más hace un collect entonces este este Nada más hace un collect y cuando ustedes tienen que o sea en el arreglo ustedes ven que el scan ya vio a b Entonces el collect por lo menos debió haber H estado aquí sí lo ven si hubiera estado Antes si hubiera estado por aquí el arreglo no tendría B si hubiera estado por acá el arreglo no
(33:40) tendría B entonces para que este arreglo sea el resultado el el collect debió haber estado por lo menos aquí no sí están de acuerdo va entonces el único collect que hizo ese scan debía haber estado por lo menos ahí pero para este punto eh Como decía creo que zuriel y José básicamente para este punto cuando hace el collect ahí quién más ya hizo o bueno ya terminó su update quién más ya lo terminó Ah muy bien entonces el hilo a ya terminó el update para el punto en el que se hizo el collect entonces aquí no hay o sea en
(34:38) el scan la nueva la nueva implementación del scan no les dice eh o sea no hay una forma diferente de hacer un collect el collect se mantiene igual no entonces sabemos que ese collect va a recolectar todos las actualizaciones de acá para atrás los que pegue de acá para atrás en específico va a recolectar a c Entonces si se dan cuenta el arreglo que debió haber estado sería c no no puede pasar que que vea B Sin que vea c porque para ver a b eh debió haber estado al menos en este punto de aquí en este punto de acá y si estuvo al menos en ese
(35:23) punto en ese punto o en adelante debía haber visto la actualización de c Entonces siempre siempre siempre Si vio a b debió haber visto a c no hay un cambio en en la forma que se hace un collect sí lo ven nada más hicieron que el scan recogiera las cosas una vez pero eso no significa que hubo un cambio en Cómo se hica en Cómo se hace el collect no sí lo ven entonces para este punto eh si el collect se hace en ese punto el arreglo que debía haber obtenido debía haber sido este de acá No pero el arreglo que obtuvo era este de
(36:20) acá Entonces se puede o no se puede cambiando el scan no muy bien no se puede y luego les pregunta si es linealiza no Entonces véanlo no cambia nada Lo único que cambia es la forma en los que se hacen los collects Y eso en qué le pega a la lineab biliz no ya no tengo pero bueno es un que le pega la estabilización que nada más se haga un collect básicamente le pega Porque si ustedes tienen un scan y luego ustedes tienen un update aquí y luego un update acá y el collect resulta que se hace aquí este que puede regresar un valor
(37:22) antiguo Sí muy bien si el collect dependen mucho o sea aquí dependen de este dónde hagan el collect no entonces antes o sea en el en el obstruction free original ustedes no dependen de dónde se haga el collect porque hacen dos copias y si esas dos copias eh están diferentes van a volver a hacer un collect van a actualizar su copia pero acá nada más hacen una copia entonces aquí sí dependen de dónde ustedes hagan el collect si lo ven entonces imagínense que ustedes hacen el collect acá que va a regresar o sea imagínense que hace un
(38:07) update igual o sea imagínense que tienen Ah pues vamos a hacerlo con este ejemplo de acá imagínense que el scan se hace aquí Digo el collect que regresa ese scan si csi con la nueva implementación del scan o sea cambiando el escan qué va a regresar ese scan puede regresar solo a tal vez no dependiendo d se el upate a muy bien muy bien muy bien José entonces muy bien básicamente regresa de acá para acá puede o no regresar a por eh Porque puede que a todavía no esté actualizado pero eh este scan o sea
(39:12) imagínense al final lo que les está pegando que nada más haya un scan digo un collect es cuando ustedes tienen cosas traslapadas Si ustedes no tienen algo traslapado o sea imagínense que tien un update aquí y luego tiene esa implementación del scan acá no se traslapa eh está acá y este está acá qué regresa si el collect o sea imagínense que tienen acá el hilo a el hilo b y tienen update c también qué regresa Este scan sí muy bien Entonces esto lo tienen que argumentar o sea formalmente pero por aquí va la idea cuando no se están
(40:02) traslap no importa dónde se haga el collect del scan va a regresar o sea tienen este caso no tienen que argumentar este caso si no se traslapa si no se traslapa la modificación del scan no les afecta porque o sea la modificación del scan implica el esan nuevo el scan nuevo implica nada más un collect no no importa que pase implica nada más un collect Entonces si no se traslapan no importa que nada más haya un collect porque no se están trasladando entonces este collect va a ver de forma correcta e este lo lo que esté o sea los updates
(40:54) que estén antes de ese scan no traslapados si lo ven entonces tienen que argumentar Qué pasa si no se traslapa si no se traslapa eh Ya vimos que no afecta esto porque o sea no afecta tener un solo collect porque ese collect va a regresar todas las actualizaciones anteriores que ya sabemos que no están traslapadas Entonces si estas e operaciones de update y de scan no se están traslap esta diferencia pero en el ejemplo sí se están trasladando No sí a eso vamos a eso vamos pero tienen que revisar estos dos casos Si no se
(41:29) traslapa e no les afecta que nada más haya un collect Pero qué pasa si se traslapa Entonces si se traslapa vamos a poner esto por acá vamos a poner así okay Si se traslapa lo que ustedes van a tener Es que si les importa Dónde esté haciendo el collect Entonces si se está traslap les vo a importar Dónde está el collect para ver lo que va a regresar este scan si el collect está aquí va a regresar nada o a si el collect está acá por ejemplo va a regresar a y C si el collect está acá va a regresar c y b si lo ven Entonces cuando se está traslap sí
(42:28) les importa dónde se haga el collect pero si se está traslap tienen que si se traslapa les importa Dónde está el collect no les importa dónde se hace el collect pero o sea por qué les importa dónde se hace el collect les importa les importa Porque eh el scan va a regresar el último o nada ahorita lo vamos a ver más gráficamente Pero chequen si el collect está aquí Este es nada más un ejemplo lo tienen que argumentar formalmente pero si el collect lo ponen acá eh Es scan puede regresar o no puede regresar a Pero como se están traslapado O sea la
(43:33) parte clave aquí es que se están traslap como se están traslap Cómo se están traslap lo que ustedes tienen es que al final al final se acuerdan de la linealiza iliza lo que les permitía cuando se trasladaba qué les permitía ser linealiza cuando se trasladaban dos operaciones acomodar como queramos muy bien entonces acá si se traslapan o sea el caso en el que les les genera problemas es si se traslapa pero eh ser linealiza eh les da que pueden acomodar como quieran Entonces ustedes pueden acomodar esta parte de acá como ustedes quieran o sea
(44:25) pueden acomodar el el update Por ejemplo si regresa a Si regresa a nada y nada Ustedes pueden acomodar el update de a luego el scan luego el update de c y luego el update de B si lo ven Entonces en este punto las cosas siguen siendo linealiza pero en este ejemplo o sea en este ejemplo las cosas siguen siendo linealiza bles lo tienen que revisar eh Generalmente para ver si este scan les afecta este scan lo único que les afecta es que nada más se hace un collect si tienen que revisar si que nada más se un collect les afecta en la lineal habil
(45:15) viación ahorita ya vieron que no porque al final el escan lo que les regresa es el último valor que que se pudo actualizar entonces pero eso nada más es en el caso de que se traslapen entonces tienen que verificar si en el caso de que o sea si en el caso en el que las operaciones de update y las operaciones de scan se traslapan eh se mantiene la la propiedad de ser linealiza por ejemplo si ustedes tienen eh esta parte de acá el collect por acá al final lo que les puede el collect por acá al final lo que les puede regresar o
(45:56) lo que les va regresar Es a o sea el scan les va a regresar a nada y digo Perdón perdón les va a regresar a y puede o no este o este si lo ven entonces para este punto tienen que revisar si se mantiene O sea si sigue siendo linealiza y para este punto Sí sigue siendo linealiza Porque pueden acomodarlo igual o sea igual que allá no igual que aquí primero hace el update de a luego el de scan y luego pueden hacer cómo se están trasladando puede acomodar este para acá o sea puede ser update DC y luego scan o al revés porque se están
(46:47) traslap entonces e básicamente en este ejemplo la la diferencia del scan no les pega en ser o no linealiza nada más generalísimo formalmente para eh que puedan ver O sea que puedan argumentar que en general no les pega cuando O sea que solo sea un collect no les pega en en esta propiedad de ser linealiza sí lo ven tienen dudas hasta acá no tienen dudas de de un tema en particular porque ya va a ser su examen Ya están listos para su examen lo de acomodar como queríamos no era de consistencia secuencial era de eh la
(47:45) consistencia secuencial Acuérdate que la consistencia secuencial Es sobre los hilos y la linealización Es sobre la ejecución entonces la consistencia secuencial lo que te dice es que tú puedes acomodar estos como tú quieras y estos o sea puedes acomodar los hilos si es linealiza en todos los casos básicamente si es linealiza en todos los casos porque el esan o sea el lo que lo que ustedes están viendo en este nuevo scan es que o sea la diferencia es que nada más hace un collect Comparado con el scan Real de obstruction free que hace uno o varios
(48:37) collects la diferencia es que si ustedes tienen la diferencia Es cuando se está traslap cuando se está traslap el collect les puede regresar el último valor actualizado o sea el collect depende lo que es el scan depende de dónde se hizo el collect pero en el caso en el que se están trasladando esto es muy importante porque en el caso en el que se están trasladando no importa o sea ustedes pueden eh acomodar la forma o sea ustedes pueden acomodar las diferentes operaciones y llamadas a métodos de update y de scan para que de El el
(49:22) resultado que vaya a dar ese scan no Entonces no no importa dónde se haga el collect si se están traslap ustedes lo pueden acomodar de forma que haga sentido Esa es la idea entonces básicamente Sí es linealiza en todos los casos pero tienen que argumentar Por qué cuando ustedes o sea por qué el hacer un solo collect no les pega en esta propiedad y no les pega Porque la única diferencia en el collect es cuando se están traslap eh Cuando se están traslap O sea la la diferencia en el collect Les pega nada más cuando se
(50:03) están traslap y cuando se están traslap ustedes lo pueden acomodar de todas las formas en las que ustedes quieran eh Porque ustedes lo pueden acomodar de todas las formas en la que ustedes quieran para que no importa dónde se haga el collect haga sentido s más o menos O sea o les haga un dibujo entonces BS ente el caso en el que no se traslapan ya lo vimos que que no afecta no entonces sigue siendo linealiza si no se traslapa lo que ustedes tienen que revisar que es lo importante es si se traslapa si se traslapa les va a importar donde ustedes
(50:44) están haciendo el collecta si ustedes lo hacen acá les va a dar algo diferente si ustedes lo hacen acá y algo diferente así el collect se hace hasta acá no imagínense que tienen acá Pero eso se está traslapado entonces si se dan cuenta eh este collect cuando se está traslap al depender de dónde se está haciendo En toda esta ejecución del escan o sea el collect depende de dónde se hace en toda la ejecución del escan Entonces cuando ustedes estén revisando el collect si el collect se acá si el collect es este de acá imagínense que el
(51:30) collect es C2 qué les va a regresar B si el collect está en ese caso qué les va a regresar ahce muy bien les va a regresar c nada ya Entonces hasta este punto lo que les va o sea el collect per s les va a regresar todos los actualizados anteriormente pero la diferencia es que el scan no revisa e todas las actualizaciones traslapadas Entonces no importa si ustedes están haciendo el collect en C2 o en c1 ustedes pueden encontrar una forma eh de de acomodar dar los updates y el scan para que el escan dé el arreglo que
(52:32) ustedes quieren que dé si lo ven entonces básicamente Sí es linealiza en todos los casos porque solo les afecta cuando se está trasladando y les afecta en qué sentido en este ver cuáles se actualizaron Pero como se está traslapado eh ustedes pueden acomodarlo de la forma en la que ustedes quieran para que dé el resultado de el arreglo del escan Sí más o menos lo ven Eduardo los demás todos sí Okay entonces nada más tienen que argumentar esta parte eh Para que ya les quede bonito y la consistencia secuencial acuerd que nada
(53:27) más es sobre los hilos ser linealiza Es sobre todo esto y la consistencia secuencial Es sobre esto va entonces eh acomodar eh las operaciones como ustedes quieran cuando se traslapan también era una una garantía o una propiedad que les daba la lineal estabilización entonces acuérdense de eso y ya con eso nada más argumentan e por qué sigue siendo o sea se mantiene que que sea linealiza va tienen dudas hasta acá de la tarea en general todo bien va los demás no Okay entonces ya pueden mandar su por
(54:30) bien su tarea no no se entrega hoy verdad Ah el jueves Ah okay Ah entonces todavía tienen tiempo pero ya quedó No nada más tienen que ponerlo bonito argumentarlo bonito y ya quedó no si no cualquier duda me me mandan mensaje o me escriben va va entonces cuídense mucho nos vemos hasta el siguiente martes acuérdense que el joves no va a poder darles la ayudantía y ahorita les subo el el anuncio al classroom para que no se les voay a olvidar nos vemos hasta el siguiente martes va cuídense mucho
(55:33) cualquier cosa me [Música]
