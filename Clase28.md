2024 09 09 10 02 52 - YouTube
https://www.youtube.com/watch?v=QjWbjsk28k0

Transcript:
(00:29) al al al hola hola sí se escucha verad Hola
(01:57) buenos días [Música] este ya le subí su siguiente tarea la tercera este bueno como es puente 16 pues entrega el el martes el 17 as la puse entonces la clase anterior nos habíamos quedado en que este habíamos terminado de ver no las condiciones de corrección las tres aunque les digo que en realidad hay bastantes más no sé cuas pero se debe un montón es por porque Bueno hay este digo que hay incluso que hay inidad fuerte abilidad este cuando tiene s los
(03:02) bizantinos así O sea hay de todo este entonces Bueno hay un montón pero estas unas tres unas tres este pues bastante famosas no y principales entonces simplemente para aterrizar un poco esto que vimos eh en el en Java que es lo que estamos viendo pues vamos a ver no e y la bueno La pregunta es como este pues no bueno ver primero pues Cómo se aplican estas condiciones no O sea por ejemplo conocemos estas tres y la pregunta es qué garantiza O sea si el modelo de Java dice este yo garantizo linealiza no O yo garantizo consistencia
(03:52) secuencial Esa es la pregunta y bueno me imagino no que este que es un modelo de memoria la primera parte también y Bueno antes de decirles que es un modelo de memoria eh Les comento no que de hecho la la el modelo de memoria de Java No garantiza pues ni linealiza bilidad ni consistencia secuencial no y lo digo así porque pues sabemos que la liability si no imagínense todo sería como muy fácil No si se garantizara utilizad Pero bueno vamos a ver no Qué es Prim primero que es un modelo de memoria y para qué nos sirve Entonces un
(04:43) modelo de memoria eh nos dice en realidad bajo qué condiciones los hilos escriben y los hilos leen lo que otros escribi igual Bueno o sea si escribo Cómo se va a reflejar para todos o sea son como estas reglas entonces Bueno vamos a suponer que tenemos esta siguiente variable que es Counter no igual a 3 Por qué Porque un hilo a Escribe 3 vale o sea es una es una variable comparti entonces variable este compartida entonces un modelo de memoria lo que hace es que esta pregunta nos dice bajo qué condiciones un hilo B O sea otro
(05:34) hilo B no cualquier otro le Counter y le tres no Esa es la pregunta por qué Porque por ejemplo este si tenemos nuestro típico modelo de memoria de Java no tenemos la stack de a la stack de b y este entonces tenemos la Hip no y en la Hip Pues supongamos que vive counter porque es parte de un objeto compartido Entonces si a y b ambos en su stack tienen copias de la variable Counter no tienen copias copias de lo que está en la Hi Entonces si ya modifica Counter en va a ser capaz de ver que realmente se modificó no Por qué Porque por ejemplo
(06:36) pues a como vimos en realidad lo que modifica primero pues es su variable local y después pues esta modificación se va a la Hip no y b pues está leyendo su variable local de Counter que probablemente quién sabe No qué tal que es un valor atrasado en qué momento él va a poder leer que realmente se actualizó entonces un lo de memoria Para qué nos sirve nos dice eh este nos dice bajo qué condiciones B va a poder leer Counter o sea las reglas no en realidad bajo qué condiciones o sea las reglas y por ejemplo este es muy importante un modelo de
(07:28) memoria y nosotros saber como nos garantiza el modelo de memoria sobre el cual estamos programando por ejemplo en este caso pues es Java no pero no sé si ustedes utilizan exir o rost o así O sea ver el mod la memoria qué nos garantiza no y saber si es que nos tenemos que blindar no O sea tenemos que este forzar a que eh Si queremos que B siempre lea lo que escribe cualquier otro hilo a cualquier otro hilo a pues forzarlo no pero si no pues eh si nos dicen Ah tu modelo de memoria te garantiza que todas las lecturas que haga un hilo se van a
(08:01) ver exactamente o sea luego luego por cualquier otro hilo que que esté leyendo esa misma variable de forma concurrente entonces Bueno qué podría pasar no si no tenemos ninguna forma de sincronización O sea si el modelo de memoria no dicta una regla pues qué podría pasar que ve simplemente pues no ve la actualización de a no O sea como que es compartida la variable Pero de aquí a qué Counter este se refleje este globalmente no sea bueno la memoria compartida no y de que B pues actualice su su variable local entonces
(08:36) este para eso es un modelo de memoria no y ya va tiene un modelo de memoria se ha estudiado desde los 2000 el 2006 creo que tienen así su gran artículo y de ahí se ha Pues creo que es es el que se mantiene hasta ahorita nada más le dan algunas cosas pero en realidad el gran cambio este es es este en el 2006 dice el primero a Escribe tres en Counter o Counter ya tenía tres Ajá O sea a Escribe tres este o sea no se suponga contar en realidad es valía cero y a el Lilo a Escribe tres Vale entonces este por ejemplo lo que
(09:20) les comento no O sea Counter tal vez B tenía eh la variable anterior y a tiene la variable nueva no la que actualizó o seaa bueno el valor nuevo de Counter que puso Entonces si a modifica Counter en tres no eh obviamente lo modifica en su variable local y luego se va a la a la Hip no Y entonces B Es capaz de leer no eh Pues en la variable global y una no Cuánto se va a tardar o sea en que le llegue la actualización a b eso es como la eso es lo que resuelve el modelo de memoria es a lo que me refiero zuriel como si
(10:03) este Como qué reglas hay Vale qué reglas hay para que realmente B pueda leer las modificaciones que hizo a y el modelo de memoria este Pues digamos que es bueno todao interface tanto de Hardware como de software o sea todo todo todo ente no computacional que permite el acceso multihilo debe tener un modelo de memoria porque como somos varios hilos no sea bueno son varios hilos o procesos este ocupamos decirles no Cómo hacer estas lecturas y escrituras no al menos Entonces este un modelo de memoria en un sistema multihilos lo que nos va a hacer
(10:47) es que va a especificar no O sea nos va a dar las reglas nos va a decir cómo los hilos tienen que leer y escribir entonces va a especificar cómo se Ejecutan las acciones en memoria Y pues sí un ejemplo las lecturas y escrituras Aunque vamos a ver más operaciones distintas que lecturas y escrituras Pero bueno al menos nos dice cómo se hacen esas lecturas y escrituras es lo que nos especifica Este modelo de memoria Vale entonces Eh y además también determina las transformaciones que el sistema no el compilador Máquina virtual Hardware este
(11:23) pueden aplicar al algoritmo concurrente no O al programa al que nosotros hacemos entonces un ejemplo de ello de las transformaciones son las optimizaciones por ejemplo no es bien sabido que Dependiendo el compilador que uses en Java por ejemplo Que si es git o que si es Ay Se me olvidó el otro pero bueno o sea si es este el compilador como en tiempo real o si es el otro o así O sea dependiendo es como se hacen las optimizaciones y depende también de eso de qué tan pues eficiente va tu programa no pero o sorpresa No qué tal que nos
(11:55) cambien el programa y este o sea Nosotros hemos visto que en los programas concurrentes es bien importante el orden en el que se Ejecutan las operaciones no entonces ahí hay como un problemita eh Bueno entonces aquí otra vez especfico no si lo vemos en un nivel de un procesador un modelo de memoria define las condiciones necesarias para saber cómo se hacen visibles las escrituras de otros pues no como les había comentado sea especifica Cómo se lee y cómo se escribe son las reglas entonces Bueno sí O sea además
(12:29) este me gusta esta porque pues sí O sea sí es hardware no O sea nosotros cada quien de ustedes pues Hay unos que tienen unas compus muy chidas no de 24 hilos y así y de hecho hay varios que tienen este he visto que tienen compus muy buenas pero aú sí me llamó la atención no que en sus programas sí se Ejecutan de forma distinta no a pesar de que tienen no sé los dos tienen 24 hilos o 12 Hilos de hecho hay varias que también tienen 12 que son de distinto fabricante y pues una una va más rápida que otra es lo que me di cuenta no como
(13:03) que tienen ahí pero bueno oa otro factor no este añadido a para determinar qué tan rápido va tu compu pues es también su modelo de memoria O sea sí O sea sí una cosa es en la ram los gigahertz y nosotros ahora vimos los cores no pero también otras situaciones Ajá pero Cómo están las reglas en tu modelo de memoria porque sí es muy distinto como las Us amd como las o sea las reglas que tiene Intel no y no s digas los nuevos no buen digo nuevos porque no tiene mucho que salir este la verdad son recientes entonces bueno
(13:43) eh Cómo se ve no pues la cadena de de ejecución de de Java para ejecutar tu programa en tu compu Eh pues primero tenemos nuestro programita no así en código diríamos qu es como sí como fuente No s traduce este el programita punto Java no entonces este ah más bien si no después el compilador revisa si tiene ciertos tipos de errores No o sea ahí mismo Entonces el modelo de memoria Entonces si es una parte física de la computación o es algo más o es el software nada más de la computadora no Sí o sea es nada más un una situación de
(14:25) software pero se pone sobre cada eh componente por ejemplo eh este tu arquitectura [Música] no tiene como ya habíamos visto tiene Eh bueno acá tengo unas figuritas no pero por ejemplo mejor acá mejoras o sea por ejemplo tu arquitectura de software es perdón de tu Hardware Pues se ve como de esta forma no O sea dependiendo tu compu Pues tienes tantos procesadores y cada uno tiene tantos cores no y cada Core comparte dependiendo hay quién tiene c1 kh2 no y los tiene divididos este hay quien no pero bueno o sea como
(15:12) que es más o menos así más o menos una arquitectura eh moderna no entonces sobre esta arquitectura no está un modelo de memoria que especifica no es es como el software del Hardware lo primerito no O sea bueno entre otras cosas pero este especifica por ejemplo cómo este procesador eh Por ejemplo como este corno tiene No sé a su hilo a su hilo el número cinco Cómo se va a comunicar con el seis No si si este no sé si tienen tengo que decirse los dos hilos no Entonces por ejemplo aquí no O sea si si van a comunicarse
(16:05) por aquí y cómo va a llegar la información cómo va a ser visible para el hilo c o el seis no o si no es que más bien se tienen que comunicar desde la memoria l3 no o sea es el modelo de memoria Este es el que especifica cómo se comunican Pues digamos que los Silos no e sí Y cómo son visibles sus escrituras sus modificaciones no O sea si por ejemplo van a ser visibles hasta acá o si son visibles hasta la ram no y es cómo es que llegan o Pues sí O sea para eso también son los los las memorias no entre más cerca esté la memoria más
(16:41) eficiente más rápida es no entonces este como que bueno es como el software el primerito software del Hardware de cómo se comunica toda esa arquitectura Pero además en Java y en otros lenguajes de programación como como en c+ como o sea Pues en realidad creo que todos no este pero todos tienen su modelo de memoria en todos especifica cómo los hilo se van a comunicar o sea digamos que es como el m de memoria sería el software del Software no y en o el software el Hardware como que pero siempre software vale No pero bueno s tiene que ver no
(17:24) cómo está puesto esa arquitectura sí depende entonces Bueno lo lo que hace lo que hacemos en Java pues es este primero Se revisa no sea de hecho luego el compilador ni te deja dependiendo cuál uses ni te deja no este si tienes ahí un errorcito no no corre Pero bueno al menos revisa como los los más este como de tipo no y así ya luego se produce el bitcode y en el bitcode se hacen las optimizaciones Para qué para que corra no sea o sea para que la máquina virtual no no lo ejecute así tan lento O sea no si lo lo hace lo más
(18:06) rápido posible vale Y después Este Ahora sí se ejecuta sobre pues la realidad es que se ejecuta sobre la computadora no sobre tu arquitectura y se ejecuta además siguiendo también el modelo de memoria de tu computadora no O sea como la máquina virtual de Java corre además sobre este modelo de memoria Entonces como son estas estos cambios no Entonces digamos que para llegar de aquí a acá pues como que pues tu programa sufre algunos cambios no Qué cambios los que dicte uno el modelo de memoria de Java y dos pues al final el
(18:46) este tu modelo de memoria de tu compo no pero bueno lo que nos permite ya es enfocarnos nada más en el entonces Eh pues las optimizaciones es dónde se dan para generar el bit code no eh Entonces qué puede pasar en las optimizaciones pues pasan dos cosas uno que que las líneas del programa se reordenan no o sea puede existir un reordenamiento y también puede ser eh que las modificaciones en memoria compartidas a que hacen los hilos al mismo tiempo no sean visibles para todos los hilos Entonces tenemos un problema
(19:26) de reordenamiento y de visibilidad Vale entonces bueno el modelo de memoria de Java este si lo buscan no este en la en Pues en internet no si ponen a ver en realidad pues está aburridísimo no Bueno o sea a quien le guste no quien se quiere dedicar eso pero pues es así este toda una documentación enorme no de cómo se hacen las las lecturas cómo hac las escrituras Y bueno pues también está el artículo este no que dice que este qué es lo que le importa ya va a mantener Vale entonces así muy largo pero nosotros no como lo estamos viendo pues
(20:07) nada más así este pasando no O sea lo que ocupamos nada más para programar nos vamos a quedar con que el modelo de memoria de Java tiene Pues nos debemos preocupar por dos problemas vale porque que re reordene las líneas de nuestro programa y porque las variables sean visibles para todos o sea son los dos problemas que como programadores nos compete Vale pues ya si nos queremos meter a no se mejorar el modelo de memoria Java No y esa sería otra cosa pues bueno no pero mientras como programadores ordenamiento
(20:44) y visibilidad entonces eh esas dos condiciones son justamente las que hacen que no se garantice la consistencia secuencial Por qué Porque si si se acuerdan a la conen secuencia lo que importa es que el orden del programa se mantenga No pero si los hilos O sea si se reordenan imagínense no se reordenan las instrucciones de los hilos es decir que se reordenan [Música] eh se reordena el orden del programa de cada hilo no el orden del programa de un hilo no Y además se reordena y además ni siquiera es visible cierto en
(21:38) el programa para los demás hilos entonces estas dos situaciones no es lo que hace que ya van ni siquiera mantenga consistencia secuencial vale e Pero bueno no todo está perdido no o sea porque nuestro curso pues está basado en pensando en que el modelo sobre el cual estamos ejecutando pues este nos da ciertas garantías Pero bueno ahorita vamos a ver vale Cuál es la solución entonces Bueno vamos a ver primero el problema no del reordenamiento por ejemplo en en el algoritmo de peterson El que está en el libro y de hecho también el que vamos
(22:16) a ver en la práctica tres este se usa las variables bueno los campos volátil entonces flag Y victim ambos son Campos volátiles y Pero bueno esto tiene una razón volátil nos permite uno que las líneas a las que le has aplicas Pero bueno no solamente las líneas no también las variables con las que se relacionan este Por ejemplo si solo le pones volátil a a victim la variable con la que se relaciona victim por ejemplo en este caso y me refiero a que se relacione O sea que tiene un orden en el código un orden secuencial O sea que primero hace
(22:59) flag y después se hace victim se mantiene digamos que lo que te permite volátil Es que uno no se reordenan las líneas de quién de la variable que estás utilizando pero también de las que se afectan o sea de las instrucciones que van antes o después Entonces en realidad con que le pusiéramos volátil a victim ya con eso e aseguramos que primero suceda plag O sea la línea 8o y luego suceda la línea nueve 18 y luego la nueve no Entonces si no le ponemos nosotros volátil Mira Vean este hay un problemilla no entre estas dos líneas
(23:40) y por ejemplo si el compilador sea considera no en la optimización dice no pues en realidad es más fácil escribir victim que que pues leer un arreglo y modificar a true no sé o sea por alguna regla que tenga el el compilador vale si decide cambiarlas entonces ahí tenemos un problemilla Por qué Porque en este por ejemplo no si tenemos así dos hil hilos el hilo a y el hilo B Entonces el hilo a está ejecutando el Loc no Y entonces imagínense que nos lo cambia el compilador Y entonces a se pone primero como víctima y luego B se pone como como
(24:28) víctima no victim entonces la línea 10 va a pasar a la sección crítica bueno se va a quedar esperando si alguien este es la víctima y también tiene la bander en true no Entonces por ejemplo supongamos no que que V escribió después como víctima y se escribió Primero su bandera en verdadero FL igual a true vale esto sucede aquí y luego este quiere decir que B va a llegar la línea 10 y supongamos no que aú a no se escribe como víctima entonces B va a terminar de ejecutar el lo porque pues sí O sea él es la víctima es el que
(25:24) se escribió al final pero la bandera de a no está prendida O sea no está true entonces B va a pasar a la sección crítica no va a pasar aquí a la sección crítica y supongamos que por fin no en este punto Ah dice Ah mira Sí ya voy a poner Mi Bandera en verdadero y pasa la sección crítica no porque pues este no se va a quedar ahí por qué porque pues sí este porque ves la víctima No él la bandera de V esta verdadero pero él no es la víctima Entonces es sorpresa No si si el compilador se le ocurre voltear noos estas dos líneas en la optimización y va
(26:13) va bueno Esto va a implicar que no se va a cumplir exclusión mutua Vale entonces Eh bueno sí más o menos lo ven entonces bueno este bien que hace volátil este Bueno lo primero que hace volátil hace dos cosas vale volátil nos ayuda con ambos problemas tanto con el reordenamiento como el de visibilidad Pero bueno ahorita estamos viendo un ejemplo djen lo escribo acá si hacemos a una variable volátil Entonces volátil mantendrá el orden del
(27:24) programa de esa variable así lo escribo vale mantendrá el orden del programa qu era el orden del programa se acuerdan el era Pues el orden en el que un hilo ejecutaba sus operaciones no entonces aquí es aún como haciendo como todavía un zoom al programa no solo mantiene el orden de las operaciones sino que mantiene el orden de las instrucciones entonces eh Por ejemplo si victim sucede nu no eh se va a preocupar porque antes se tuvo que haber hecho este flag igual a true y después se tuvo que haber hecho pues la línea 10 no gu o
(28:10) sea como que no solamente mantiene este bueno digamos que lo que hace volátil es que mantiene que que el orden como causal de las operaciones o sea te dice vitim sucede después de flag siempre nos dice eso algo nos impide devolver todas las variables volatil o sea así como que ya para evitarnos errores pues no en realidad puedes poner todas las variables volátil este m lo único que que sucede es que tu programa se hace más [Música] lento pero Ajá sí zuriel sí sí O sea ya va es secuencial cuando lo ejecutas de forma
(29:02) secuencial el problema es que cuando lo ejecutas de forma concurrente eh A veces el modelo de memoria dice Mira si tienes dos escrituras a la misma variable y una lectura Por qué no las pones juntas al inicio y y y y la escritura al final O sea ya vas eso cuando lo ejecutas de forma concurrente Por qué Porque el modelo de memoria eh está digamos que puesto para cuando para cuando hay lecturas y escrituras de forma concurrente entonces hay lecturas y escrituras de forma concurrente lo lo reordena como a él más
(29:46) le plazca o sea optimiza el programa sí es curioso porque en realidad de forma secuencial en realidad también las reordena pero no nos da damos cuenta porque pues solo le ejecuta un hilo Ajá sí O sea si en realidad creo que siempre hay un reordenamiento y Dice Eduardo si solo hacemos que una que una sea volátil igual no funciona en este caso a mí me parece que sí funciona si funciona si solamente hacemos una volátil pero este bueno porj en este caso mantiene el orden del programa si en este caso sí funciona Bueno ahorita vamos vamos a
(30:38) ello que es visibilidad entonces Y entonces puede pasar que a y b hayan hecho lo de víctima al mismo tiempo para eso poner volátil para evitar eso Ajá s también esa es otra este si también para eso le pones victim Ahí está victim voltil para evitar que para para que se refleje sí Exacto para que aquí no cuando los hilos estén vayan a leer la línea 10 no realmente vean no que el otro es la víctima y Noel ver que si realmente Se reflejó porque tiene que ver volátil también con visibilidad ahorita solo vemos el problema no de
(31:15) reordenamiento eh Y dice Eduardo entonces mantiene el orden de la variable en el programa respecto a qué respecto a las otras lecturas y escrituras eso mantiene vale Sí o sea respecto a otras lecturas y escrituras de otras variables también entonces por ejemplo este no sé O sea si victim dice yo sucedía y después de esta pues mantiene ese orden vale o sea y yo sucedía antes que esta Y antes que bueno ya no hay más No pero mantiene ese orden Ya como que lo que pase entre estos de aquí acá como que ya no le importa pero importa que antes tuvo que
(31:59) haber sucedido flag igual a true Ajá s volátil es es decirle compilador fuerza a que no se me muevan estas líneas de esta variable Exacto Sí si es lo que te dice y además te dice fuerza a que a que realmente las que están antes pasen antes y la que están después pasen después O sea fuerza así a que dice esto se ejecuta pero se ejecuta aquí no Y todo lo que va después sí no pero este tiene que ir después y no se puede reordenar es lo que nos dice dice y si víctima aparece dos veces haría la que está primero Cómo Ah o sea
(32:40) como que se escriba victim víctima igual a y dos veces Ajá sí O sea no eras poí si le ponemos volátil No sí sí Okay entonces Que aparezca después del While Ajá sí o sea las mantendría así sí O sea por ejemplo huer una víctim una victima acá no O sea como una línea 11 aquí no que fuera victim igual a uno igual a y este mantendría ese orden Ajá O sea primero haría haría primero esta y luego esta y luego esta O sea mantendría sí o sí ese orden Porque si a veces cuando se escribe doblemente habla el compilador dice Ah mira hay que
(33:30) ahorrarnos la y la escribimos antes es que es A veces lo que hace el compilador no HM Ajá Okay entonces bueno ya como les había comentado en realidad les había enseñado esta Este nosotros nuestro nuestros nuestras arquitecturas de modelo Perdón nuestras arquitecturas de de Pues de nuestras compus e nuestras arquitecturas tienen sus propias eh tienen sus propios modelos de memoria y probablemente si nos vamos a leer ahí la ficha técnica de nuestro procesador Pues nos va a venir ahí no este Qué sucede cuando dos hilos
(34:20) escriben en la misma variable en el cach 2s no Bueno obiamente yo creo que es muy bonito se los digo pero no ha de estar mu muy muy este muy así Bueno muy este fácil no de leer pero bueno sea es lo que dice no si dos variables este tres variables no leen en la cach TR Pon primero la escritura y Pon después las lecturas o es como estas instrucciones y cada uno tiene su propio no Y también este el pues Java tiene su Java Memory model así lo van contra el jmm bueno bueno o sea cualquier lenguaje de programación que soporte programación
(35:04) multi tiene su modelo de memoria otro famosísimo no que se ha estudiado también un montón desde los 2000 pues es c+ más también ese Este tiene su modelo de memoria e Bueno entonces este otra situación es el problema de visibilidad y bueno Este ahí está el dicho no en este en programación concurrente y Bueno en realidad para los los que trabajan en modelo memoria que entre entre entre más visible va a ser menos óptimo y también no entre Entre más lejos y grande más tardado por ejemplo no es lo mismo que el hilo este el cor uno no quiera leer algo
(36:07) hasta la ram Ah bueno por ejemplo no es que es no es la ram no pero bueno o sea que tenga aquí la ram no es lo mismo quiera leer algo en la ram que quiera leer algo en el cach do no y que el cach do pues lo comparta con el Core dos y con el hilo dos no Entonces no es lo mismo compartir solamente con lo dos que compartir en la ram con no sé los 16 cores que tienes no no es lo mismo e definitivamente pues tardas más en leer hasta acá o sea está mucho más lejos y además las memorias sabemos nosotros que son más grandes no entonces tiene ahí su
(36:45) su este este pues su lejanía no entonces imagínense si yo quiero escribir algo y estoy aquí no y quiero escribirlo en la ram cuánto me voy a tardar no O sea este camino pues es tiempo entonces ahí hay un problema de visibilidad cuánto tiempo se va a tardar el Core un en que sea visible para el Core 2 no pu escribimos en L2 cuánto tiempo va a ser el Core uno para escribir hasta la ram no O sea y en lo que pues llega no es un problema de visibilidad y en lo que el Core este pues no sé el Core de acá decide leer
(37:26) hasta la Ram la actualización no y no leerla su en su copia local porque obviamente va a ser más rápido si la Lee de forma local no entonces aquí o sea en modelos de memoria Hay un problema siempre de visibilidad entonces otra cosa en la que nos ayuda volátil es este la definición de visibilidad por Ajá sí sí visibilidad vamos a nombrarla así eh es el tiempo Bueno voy a ponerlo así existe un problema de visibilidad e en el tiempo que tarda un hilo en actualizar una variable
(38:32) en memoria compartida vale Y además no [Música] eh Ay discúlpenme es que como ya las traigo hechas no yo creo que voy a dejar más más hojas en blanco pero bueno además este HM los hilos es la decisión de un hilo de leer la memoria compartida y no su memoria local ahí hay problemas de visibilidad y bueno Por qué un hilo primero por por qué Por qué tardaría tiempo en llegar una
(39:37) actualización a la variable compartida porque este la variable compartida regularmente en realidad no la hiip por ejemplo pues vive en la O sea la hiip vive en la ram no o sea es en el código que est estamos ejecutando todos en en tiempo real en realidad vive en la ram entonces imagínense el hilo uno que comprende pues su cach un no tiene aquí su contexto de ejecución no Entonces para el hilo uno Obviamente le representa más ir a actualizar una variable este eh compartida en la ram y bueno yo digo como que el hilo aquí se mueve no así da
(40:20) el hilo se mueve va caminando así pero bueno en realidad lo que hay acá abajo es son algoritmos para que no sé si el hilo nada más escriben en l1 que ese l1 llegue eventualmente hasta la ram no O sea digamos que es como se mueve un paquetito a través de los algoritmos que hay aquí de cach para que llegue hasta la ram Vale entonces en realidad si se dan cuenta actualizar una variable compartida para un hilo Pues sí le representa un tiempo no Claro que ese tiempo pues está en o sea es como en nanosegundos no O sea sí En realidad es
(40:55) rápido No pero no es tan tan simple como que el hilo nada más escribe en su caché entonces aquí o sea en lo que no sé pues el hilo escribió Counter 3 Ajá sí pero en lo que llega a actualizarse a la variable compartida que está en la ram pues va a tardar No entonces hay un problema de visibilidad vale vale Fernanda Por qué Porque tarda tiempo no tarda tiempo y por ejemplo qué tal que ambos aquí no este H lo también Ay Se tardó en actualizar no no Y entonces estos dos van los dos quisieron actualizar la memoria compartida no Cómo
(41:34) se hacen estas o sea cómo le dices Sí que suceda primero el Core un y después la de lo que hizo el Core 2s Vale entonces también ese es otro otro problemilla no y a la vez la decisión aquí pongo no la decisión de un hilo de leer la memoria compartida y no su memoria local Pues sí no porque también le representa a no sé al hilo acá cinco no un gasto este en vez V de leer su memoria local aquí tiene una copia de la memoria compartida decirle Oigan Pásenme el valor actualizado Entonces el valor actualizado que tiene que ir Pues
(42:07) por el bus de memoria luego va por el cach 3 luego el cache 2 luego el cach un hasta que le llega finalmente no Entonces digamos que aquí o sea como que lo vemos muy bonito no O sea en Java pues está est esto más este abstracto no O sea nada más tenemos stacks y hips no pero en realidad lo que pasa hasta abajo es que pues sí O sea en realidad las actualizaciones se van a tardar porque tienen que pues atravesar todo el camino y también este cuando un hilo quiere el valor actualizado no el más reciente pues se va a tardar en llegar hasta
(42:41) hasta el hilo no Entonces como dice Camilo No pues hay que ponerla todo volátil y ya con eso nos evitamos problemas de reordenamiento y de visibilidad Ajá sí también no es es una opción pero bueno o sea justo como que es así el meollo no del asunto aquí este saber dónde vale e para no hacer los programas tan ineficientes no pero bueno entonces aquí también puede haber un problema de visibilidad No si por ejemplo yo escribo en Mi bandera true no y voy a ponerlo así vale si este el hilo B no le flag de a igual a true
(43:42) entonces también puede no cumplirse exclusión mutua porque pues imagínense no que que a es el que está este pues hay tiene el candado no y todo y ve llega a escribirse como víctima pero no se refleja que que a actualizó su bandera no O sea no se refleja entonces eh B va a pasar a la sección crítica porque pues sí es la víctima pero para él la bandera de a está en falso no O sea si no le que realmente ha actualizó su bandera imagínense no que que pues aquí ambos como que están haciendo cosas ahí similar no entonces uno quiere pasar no
(44:26) el otro también pero este no s en el trayecto no no se reflejó a tiempo y ve mientras ya escribió victim se escribió como víctima por ejemplo y pues ambos ya pasaron a a la sección crítica no O sea como que hay un problema si no vemos lo que el otro escribe por ejemplo como en este como en peterson es muy importante saber si la bandera del otro está en verdadero no entonces lo que nos permite hacer volátil es hacer una especie como de eh Ah bueno aquí está como de flush no así le dicen en programación concurrente y
(45:03) lo que hacemos Es simplemente hacer que se hace como digamos no sea como está escribiendo algo y llega aquí este al hacerle flush y bueno así como muy ambiguo Pero simplemente lo que hace es que fuerza al programa les dice que nadie haga nada hasta que se actualice la variable sl es lo que hace como que detiene pues todas las las las escrituras que hay aquí que se hayan hecho después y fuerza a que el programa no le llegue este flag igual a true Y que ahora sí todo lo demás llegue después O sea por eso imagínense Bueno eso es lo que hace
(45:48) volátil no con el problema de visibilidad entonces bueno volátil es en realidad una forma de sincronización así como los candados nos ayudan a sincronizar Pero bueno o sea esta sincronización es débil y ahorita vamos a ver Por qué este los candados son una forma de sincronización fuerte e Bueno este vamos a ver más adelante los registros en realidad lo que nos crea volátil es un registro atómico Pero bueno Esto lo vamos a ver en el siguiente tema y hay también eh otras formas de sincronización mucho más fuertes que son las primitivas igual
(46:26) la vamos a ver más adelante vale Pero bueno ahorita estamos en volátil que pues como que nos da garantías pero o sea nos deja que el programa no se reordene y que las actualizaciones sean visibles es lo que nos permite volátil e entonces bueno por ejemplo aquí no está el problema de de reordenamiento ordenamiento no asegura que las actualizaciones a una variable se propaguen de forma predecible y dicen predecible O sea que no se reorden no O sea que así como está así se propaguen si primero se hizo un flag igual a true
(47:04) que se propague primero y si después se hizo un víctima igual ahí que se propague después no es lo que nos dice y y además fuerza no a que las variables lleguen no haciendo flush Dice que se detenga todo antes de que cualquier hilo pueda leer flag igual a true porque aquí ya va hay una actualización no Entonces si se dan cuenta este pues sí nos va a afectar no usar volátil en todo pero hay situaciones en las que no podemos evitar no usarlo no eh Bueno entonces aquí hay un ejemplo no seaas así resumido todo no lo que les
(47:42) estoy comentando si un hilo a escribe en una variable que es volátil y después no un hilo B lee la misma variable quiere decir que entonces todas las variables visibles para a antes de escribir lo son también para B Entonces por ejemplo este se refiere no O sea si gr si a escribe una variable y b escribe le no este read b y la misma variable si sucede este orden quiere decir que todo lo que este eh todo lo que era visible para a no O sea todas las operaciones acá también no son para el rit de de B entonces A eso me refiero veen se
(48:40) acuerdan dice dice Víctor se hace un hilo actualiza una una volátil para todos los hilos en el punto que usen esa variable como checkpoint Ándale sí sí sí sí porque es como en el programita no O sea si le ponemos nosotros a bigam este igual ahí le ponemos volátil no O sea si este es volátil Entonces cuando este bueno volátil fuerza a que bigam sea visible para los demás hilos Pero además fuerza a que lo que sucedió antes no este Por ejemplo si antes escribió que flag igual a true que todo lo que esté antes suceda realmente antes no O
(49:22) sea para cuando se lea victi esto ya tuvo que haber tenido efecto y visible para todos también entonces sí como dice Víctor no como que forzamos a que se haga un checkpoint no O sea si todo andaba siendo como valiendo queso pero si se ejecuta una variable volátil todo lo que sucedió antes ya Ya debió haber pasado y no no se va adelantar esa actualización hasta que no suceda lo demás y además tiene que ser visible vale Sí sí Qué buena analogía Okay entonces bueno eh o sea acabando no como les comenté este este campo volátil no hace flush no sea
(50:05) hace que por ejemplo viéndolo En esta abstracción si Counter se modificó a tres que se haga flush para que aquí también esté modificado no y que si yo quiero leer este el hilo B no se tiene cero y quiere leer su variable pues entonces que se haga también a él no y que se lea tres o sea se actualice entonces dice zuriel entonces la variable se actualizaría en tiempo real y los demás s los verían reflejado ese cambio luego luego seguirá tardando Ajá sí Exacto es lo que garantiza volátil que los cambios eh se vean de inmediato no los
(50:50) cambios eh Son inmediatos vale si es lo que garantiza entonces bueno volátil acaba con nuestro problema de visibilidad como les comenté y también con nuestro problema del ordenamiento no porque mantiene este orden parcial entre los hilos o sea como Bueno aquí puse la relación happens before que es muy muy este muy este famosa creo que yo no le he mencionado no pero la relación happens before es la línea que vimos nosotros en la parte de teoría ahorita que vimos laliz abilidad mantiene el orden parcial vale o sea las líneas de precedencia si
(51:36) esto sucede antes se mantiene entonces gracias a volátil no es que podemos asegurar que peterson pues así como lo analizamos de forma teórica a la práctica también se pase o sea realmente siga funcionando si no ponemos volátil Pues en la parte práctica como que la teoría decimos Mira qué bonito funciona no pero la parte práctica si no usamos volátil podría dejar de funcionar No este Ah bueno Y además si nosotros usamos campus volátil esos registros los convertimos en registros linealiza bles Por qué Porque quiere decir que todos
(52:15) van a preservar el orden parcial o sea el orden de las flechitas no Y la linealiza bilidad es lo único que le importa hay más ejemplos de objetos que que que mantienen este orden un ejemplo es este toda la paquetería atomic de Java es que es atomic reference atomic integer y todos los métodos que mantienen estas esto este tipo de objetos que son Conan set set no esto ya lo vamos a ver en la práctica tres Ajá este entonces bueno volátil implica costos en el desempeño miren Aquí les encontré esta tablita que por ejemplo
(52:54) este el tiempo de nanosegundos no e si por ejemplo haces una una una instrucción de procesador un nanosegundo no si la pides o sea haces un fetch desde el cche un pues tard 2.5 eh si haces un fch desde cche dos pues te tardas siete no Entonces ahora imagínense en un flush no en volátil cuánto se tardaría no O sea por ejemplo leer un MB eh de forma secuencial del disco tardas este pues creo que 2 segundos no 1 dos 3 punto dos no por ahí este entonces entre entre más cosas pidas pues va a ser más tardado no y por ejemplo Aquí
(53:43) les puse como una tablita de los modelos de memoria algunos ejemplos que por ejemplo lo que se refiere es si si por ejemplo Arm reordena las o sea mantiene el orden de las lecturas y te dice que sí no Arm sí mantiene el orden de si se hace una escritura y una lectura Perdón una lectura y una escritura sí mantiene el orden de escritura escritura escritura Sí pero por ejemplo Spark no amd64 no mantienen el orden no O sea te permite reordenar así más o menos se ve el modelo o sea las reglas del modelo como que lo hacen así de si hay una lectura y
(54:20) una lectura te dice no las reorden déjalas No pero si hay una lectura y una escritura ordénalas como quieras oa que o se no no le importa el orden vale Este Híjole ya no me va a dar tiempo eh Déjenme este así rapidísimo ay creo que ni siquiera lo tengo abierto este que ya lo encontré Ya ve mi pantalla
(55:38) verdad s Okay gracias miren ve miren por ejemplo este programita Ay no bor esto peroo es de una bandera este miren vean por ejemplo esta variable la de la línea 13 si le quitamos el volátil por ejemplo cuando esa volátil Este tenemos a un hilo lector y a un hilo escritor no Entonces digamos que el hilo escritor lo que quiere es cambiar la variable a true inicialmente está en falso y el hilo lector va a estar esperando a que la cambie a verdadero para poder imprimir la bandera está en impr primir el estado de la bandera es lo único que hace si le
(56:31) dejamos volátil el elector va a decir Ah mira la bandera fue cambiada true No acá abajito pero si no si no le cambiamos miren Ah ah sí miren por ejemplo solo aparece la bandera [Música] control miren si no le cambiamos si sí usamos volátil este pues El lector dice Ah mira la bandera está en trus así lo le pero si no usamos volátil El lector jamás ve que el hilo escritor la cambió a verdadero vale o sea miren aquí se ve un problema así tal cual entonces solo solamente Se imprime lo que el hilo escritor este escribe
(57:24) pero no lo que el hilo lector Por qué Porque nunca le o sea nunca nunca le llega la actualización pero si usamos volátil ahora sí no la bandera fue cambiada a true y la bandera está en true ya vieron si no usamos volátil o sea aquí se ve tal cual no es el problemita y el otro ejemplo es este ah por ejemplo acá no igual si no usamos volátil Incluso el programa nos reordena estas líneas así las puse así estas líneas Así nada más no este por ejemplo a ig a cer luego B la aumentas en uno B ig a a y así si no ponemos volátil nos
(58:04) hace lo que quiere el programa también este pero s se cambia la variable no a pesar de que no se hace lo de r Ajá sí Exacto o sea se cambia true en en este primerito este sí O sea siempre se cambia true ya vieron la bandera fue cambiada true la bandera está en true pero pero si no le ponemos volátil este solamente lo que nos dice el hilo Es que la bandera fue cambiada true o sea el hilo escritor el hilo escritor es el que dice esto no Pero el hilo lector no lo ve a pesar de que fue cambiado true Entonces el hilo lector se quedó
(58:42) Aquí dando vueltas no porque para él sigue siendo falso Entonces él Sigue esperando vale Este Bueno ya no leí con ustedes la tarea eh Pero bueno este si no le digo a a Isabel que la lea con ustedes mañana pero sí porque ya no me dio tiempo pero bueno este sí este la primera parte es cosas que ya habíamos visto de laliz habilidad con secuencial Pero bueno el miércoles la revis vale Si no mañana la revisan se le digo a Isabel que las revise con ustedes pero mientras vayan leyéndola va sí Y al final Les explico bien el
(59:38) último ejercicio que tiene que ver con volátil vale Vale Nos vemos bye Bonito inicio de semana Bye stoped
