2024 08 28 10 02 01 - YouTube
https://www.youtube.com/watch?v=42Rx2ekILfU

Transcript:
(00:29) al al Hola buenos días recording in
(01:55) progress ok a ver entonces empecemos la clase anterior nos quedamos en que este Bueno yo les había dicho presentado por fin este este cuadrito entonces habíamos visto que había Bueno les había comentado y habíamos sido testigos de que de una implementación no bloqueante no pero bueno yo les había comentado que los objetos concurrentes este llámense las colas los candaditos no las pilas otros que no conocen probablemente como los snapshots este y así Bueno hay muchos muchos objetos Entonces todos ellos se implementan se implementan Por
(02:52) qué Porque en realidad el objeto como tal pues tiene una descripción así abstracta no entonces a ver hay que hacer aquí escribiendo lo que vimos Okay entonces uno habíamos presentado este objetos concurrentes yo les había comentado así este ejemplos no candados pilas eh colas snapshots y bueno también De hecho hay primitivas estos me imagino que han de ser nuevos no ustedes pero los vamos a ver eh entonces hay objetos concurrentes luego los objetos concurrentes este se implementan implementaciones Okay se implementa Por
(03:46) qué Porque los objetos concurrentes en Sí pues es una descripción abstracta por ejemplo pues qu qué queremos de una cola que sea fifu qué queremos de una pila que sea lif eh qué queremos de un contador Pues que realmente vaya de cero a infinito no y que vaya de uno en uno de dos en dos o como sea no este entonces son descripciones abstractas ya las implementaciones pues ahora sí es el código o específico O sea ya como tal nuestro algoritmo concurrente no eh Es decir nuestro algoritmo concurrente y además yo les había
(04:26) comentado Que bueno hay que para para analizar la corrección de los algoritmos de los objetos concurrentes de estas implementaciones eh tenemos Bueno vamos a ver si lo pongo así entonces para analizar la corrección de sus implementaciones este yo les había comentado que tenemos e condiciones de Progreso esta de aquí y tenemos condiciones de corrección entonces en eso nos habíamos quedado eh Y entonces tenemos condiciones de Progreso y de corrección de Progreso este es una tablita que resume no es lo primero que hemos visto las de corrección ahorita
(05:28) voy a ello vale pero las de Progreso es lo que es lo que llevamos vale es como en este punto estamos Entonces por qué porque las implementaciones pueden ser con un progreso no bloqueante o con un progreso bloqueante habíamos visto la clase anterior que pues así el tip no para saber si es bloqueante pues es si tiene candados si tiene candados pues si no va a ser no bloqueante O sea un candado a fuerzas es bloqueante por qué Porque detiene el progreso de los demás ti Bueno este un hilo puede detener el progreso de los
(06:12) demás A diferencia de lo no bloqueante no Entonces lo bloqueante este eh andamos en ese mundo desde el tema anterior No candados todo es bloqueante si ya se detiene y ya iba a agarrar el candado era el siguiente en en el algoritmo este de Bakery no del panadero Pues ya ni modo o sea nos vamos a esperar a que Ya despierte porque le va a él no este esas cosas Entonces para estas algoritmos bloqueantes habíamos visto starvation free y deadlock free vale Y para los algoritmos no bloqueantes las implementaciones no
(06:46) bloqueantes este habíamos visto solamente una implementación para dos hilos weight free de una cola es lo que llevamos no lo que sabemos de este mundo entonces El ejemplo de esta implementación lo habíamos visto Ah mir Aquí está no es la implementación Por qué Porque no usa candados entonces puede ser que un hilo este bueno estén los hilos p y hilo q el Q se detenga y no va a haber problema para peno él va a seguir haciendo sus cosas no importa va a regresar casi siempre vacío No porque si el encolador se detuvo y no encola nada pues
(07:27) eventualmente regresará vacío pero pero este no hay problema O sea no no se detiene el otro si siq se detiene entonces habíamos visto esta implementación que justo no le le ponen weight free la cola weight free Bueno entonces qué era weight free era que eh era el análogo no de starvation free Wi free era que si este si bueno garantiza que todas las llamadas O sea que todos los hilos terminen su ejecución en un número finito de pasos es decir que O sea qué implica no que alguien se quede un número infinito de pasos pues que no
(08:07) acaba no Entonces garantiza que todos acabamos y garantiza que cada hilo progrese o sea en otras palabras la diferencia con lck free con esta otra que no hemos visto ahorita ejemplos implementaciones así pero los veremos Es que este dice que Bueno les digo la definición es así como muy mu este muy matemática siento no sea si lo leemos así como garantiza que infinitamente seguido alguna llamada un método acabará en un número finito de pasos No pues simplemente lo que nos dice es que algún proceso debe acabar el número finito de
(08:44) pasos cada cuando pues infinitamente no es como acordándonos este de cómo debe ser vale la definición Entonces si un método es free Pues también es lo free es como la implicación de que si es starvation free Pues también es porque pues simplemente wiit free es la generalización no wif te dice que todo lo fre dice alguien algún hil alguna llamada método entonces pues realmente Este nosotros bueno Yo me imagino no como decimos Bueno pues lo que más nos gustaría es que todos acabe no que chafa un protocolo que pues que
(09:22) existan H los que no acaben no pero bueno este sí son más atractivos los métodos we free no O sea como Pues sí que todos acaben Pero la realidad es que a veces para permitir que todos acaben como que ocupas pues más este pues ocupa diseñarlos de esa forma No y regularmente suelen ser más ineficientes O sea como que entre más le pidas un algoritmo más ineficiente va a ser vale o sea más más se va a tardar entonces a veces por eso la gente prefiere que sea lo free no O que igual la entre starvation free deadlock free a
(10:02) veces se prefiere que simplemente no haya un deadlock pero de ahí que todos acaben Pues no sé no este entonces bueno otro ejemplo de Otra condición de Progreso no bloqueante es obstruction free esta digamos que es otra Como ot pero casi no Bueno vamos a ver en el capítulo 4 una implementación sig en el siguiente este conru free Entonces esta esta propiedad lo que simplemente nos dice es que garantiza que cuando un proceso va solo pues termina su ejecución en un número finito de pasos eh A qué se refiere con que va
(10:45) solo simplemente que es que este por ejemplo tienes alilo a b c no Entonces por aquí aquí están ejecutando métodos no se entrelazan Este es un relajo pero cuando a finalmente va solo acá este en este punto a va solo no este entonces termina no algo así O sea pero mientras aquí pues como que se tardan más no supongamos así entonces lo que nos dice obstruction free es que si el hilo va solo o sea si no se entrelaza con alguien más termina es lo que nos dice esta propiedad qué nos decía lock freel lock fre nos dice que alguien termina en
(11:44) un número finito de pasos infinitamente seguido No eso nos dice lf este no es que por ejemplo así infinitamente seguido alguno llamado un método acabará en un número finito de pasos vale o sea que alguien acaba es lo que nos dice y Qué tan seguido pues infinitamente seguido siempre siempre alguien acá es lo que nos dice vale eh okay Está no sé por qué les puse esta aquí pero bueno es un ejemplo de una cola pero este yo nada más lo puse como ejemplo Pero bueno ahorita vemos ejempl esto okay Entonces esto se ve así no
(12:33) lock free todos acaban y nadie nadie bloquea nadie todos acaban y puede ser que alguien bloquee el retraso de alguien lock free este alguien acaba y nadie bloquea el retraso de alguien Y deadlock free alguien acaba y este y pues si alguien se detiene todos valimos no oa igual este El Progreso no de este lado pues El Progreso en la detención de alguien detiene el progreso de todos y aquí si alguien se detiene no nos Afecta no como que es así el resumen no de las de Progreso ahora las de corrección vamos ahora sí no a esta otra partecita
(13:14) las de corrección a ver este vamos a ver estas tres que son laliz habilidad consistencia secuencial y consistencia en la quietud son tres condiciones de corrección la laliz habilidad es así la estrelar no nuestra estrella Esa es la que vamos a haer nosotros por qué porque simplemente porque estamos en alto nivel vale o sea estamos Este programando en alto nivel estamos viéndolo todo así a nivel de estructuras de datos si nosotros nos bajáramos a a caché no O Pues sí a caché memoria a a Baja memoria pues probablemente
(13:56) anduvieramos acá no O de hecho ya ni siquiera se considera a veces esta se considera todavía cosas más más este más ligeras Pero bueno Entonces nosotros vamos a andar acá pero vemos estas para para ver las diferencias entonces eh estas las implementaciones de concurrentes de objetos tienen pues ya vimos no de condiciones de Progreso y de corrección estas de corrección tienen que ver con propiedades de seguridad es decir nos dicen no que algo malo nunca va a pasar entonces eh la idea de estas tres propiedades va
(14:36) a ser esta palabra tan importante que va a ser transformar Qué vamos a hacer transformar la historia concurrente a una secuencial y simplemente vamos a analizar si esta historia secuencial es correcta la diferencia entre estas tres nada más es que tienen distintas reglas para transformar Pero la idea es esa Vale entonces Bueno vamos a ver yita voy a hacer como este bueno es que la definición así como ni siquiera está tan formal el libro pero este como que hay mucho concepto ahorita entonces espero como que mantenerlos no que no se
(15:18) me aburran pero ahí vamos no eh voy a irles preguntando van a ver un squiz ahorita entonces vayan poniendo atención entonces un objeto como tal pues ya vimos no que provee un conjunto de métodos y es la única forma en la que nosotros podemos este modificar a este objeto entonces e y pues estos métodos definen el comportamiento del objeto un ejemplo de ello pues es no sé esta una cola una cola nos dicen que es fifo en q consiste en insertar un elemento de que consiste en regresar el primer elemento insertado o se eso es una una descripción de un
(16:00) objeto Vale entonces los objetos además tienen estados bien definidos y a qué se refiere esto eh Por ejemplo este el estado de una cola en este caso sería una sería la secuencia de ítems que están en esa cola entonces una cola por ejemplo aquí no la cola tendría Como así x este así e Pues no sé el elemento c el un el dos no Entonces primero está x después está y no sé no entonces sabemos que si se aplica un enq no sé de Z pues entonces el estado de la cola cambia así no sea est es el estado de del objeto y así o sea es como pues lo Cómo se
(17:03) refleja la cola después de haber ejecutado pues sus métodos No simplemente es eso entonces e hay hay precondiciones en el mundo secuencial por eso por eso se llama así esta esta diapositiva en el mundo secuencial pues como nada más hay un hilo que está ejecutando cosas Pues digamos que el estado de esta cola va a ser uno antes no de ejecutar por ejemplo un enq enq no en cola x va a ser un estado y después de que hagas ese en qx pues esperas que el X esté en la cola no entonces podemos escribir un objeto en el mundo secuencial Pues en
(17:47) precondiciones y en postcondiciones simplemente las precondiciones describen el estado del objeto antes de invocar el método y las postcondiciones escriben el estado del objeto después y además te dicen si se regresa algo no entonces eh Como les había comentado no O sea pues tenemos la cola este Tenemos aquí la cola no Y si se por ejemplo esta sería está muy grande sería estáa la postc no este es el método y este Perdón la precondición sería esta y luego ahora sí no la po condición simplemente sería pues ahora
(18:46) ya cambió el estado de la cola y ahora Z no y se regresa Pues nada no como un verdadero como se pudo se regresa true voy a ponerlo así se regresa true y ya está entonces sería la postcondiciones a este estilo como de documentar las cosas se le va a conocer como especificación secuencial Entonces digamos que la especificación secuencial simplemente también lo podríamos ver como como el conjunto de historias válidas para una un objeto vale en este caso pues es una cola un objeto Pues en este caso es una cola no Entonces por ejemplo el que
(19:48) tengamos nuestra cola así y luego hagamos un nqz y después se ve así pues es correcto no entonces la especificación secuencial es lo que nos va a ir diciendo si nosotros hac Esto entonces debemos tener esto y si hacemos este conjunto no s de 10 llamadas pues la cola se debe ver de esta forma Esa es la especificación secuencial vale es muy importante en en el mundo concurrente o sea regularmente van a escuchar No este sequencial specification así así le llaman Vale entonces bueno ahora sí como viendolo aplicado
(20:26) no este digamos que esta esta descripción esta descripción esa es una descripción no letras descripción de una cola no una descripción de una cola entonces la especificación secuencial es el conjunto de historias que parten de esta descripción O sea que son válidas digamos no para esta descripción así le podemos decir entonces por ejemplo eh yo les había comentado que estas estas eh condiciones de corrección que vamos a ver simplemente lo que hacen es transformar ejecuciones concurrentes en
(21:30) secuenciales Entonces por ejemplo tomando la ejecución que nosotros vimos la ejecución concurrente no ejecución concurrente cuando la analizamos Pues en realidad parece una ejecución secuencial Por qué Porque pues se forman no O sea primero se ejecuta este y luego este y luego este Entonces si nosotros analizamos esta ejecución secuencial ustedes o sea es la pregunta no esta ejecución sería correcta con respecto a una a la descripción de una cola es decir con respecto a la especificación secuencial de una cola
(22:14) Esa es la pregunta por ejemplo si consideramos que la col inicialmente está vacía es correcto decir que sucede esto en ese orden dice que cre dice no entiendo Dónde está la especificación secuencial aj es que Haz de cuenta bueno que por ejemplo si escribimos todas digamos que esta es la descripción de la cola no entonces la especificación secuencial es el conjunto historias que se pueden hacer a partir de esta descripción pero imagínate que ese Ese Conjunto pues es enorme no imagínate si las escribimos no O sea como eh si
(23:12) suponemos no que se llama s no el conjunto Entonces sería como Eh Pues no sé enq a no y que se regrese TR es correcto Ese es una historia no otra historia sería que se regrese en q a y luego se haga de q de a es correcto entonces imagínense todas las combinaciones de historias que podemos crear no partir de de Pues en realidad de esta definición No si si nos vamos a lenguajes Pues en realidad esto es un lenguaje no una cola es un lenguaje es Es que esta especificación secuencial se refiere a esto no O sea digamos que
(23:59) Esta es la descripción del lenguaje Y entonces la especificación secuencial es el conjunto de cadenas que podemos hacer a partir de ese lenguaje vale Y entonces Eduardo dice faltan las precondiciones Ajá pues justamente las precondiciones y las postcondiciones viven en Este lenguaje no O sea eh el estado de la colol es uno y si se ejecuta en qa Pues yo hago un de qa hago un deq me debe devolver a no O sea pues está vacía debe suceder esto O sea digamos que aquí se ve una postcon no y una este Perdón una precondición y
(24:39) una postcondiciones Pues es que obtengo a vale o sea es el resultado y así O sea digamos que las postcondiciones y las precondiciones viven en la especificación secuencial y la especificación secuencial simplemente es todas las cadenas que podemos hacer a partir de este el lenguaje no que aquí lo vemos más bonito no no me estoy metiendo ahí como definamos la el lenguaje Y entonces las permutaciones o no estamos como tan abajo no pero es para que lo vean de esa forma y así es como definen la analizaba y todas estas
(25:14) Vale entonces las dos que están ahí son solo po condiciones no que solo Ah bueno pero sí ya ya cachaste verdad Ajá entonces este por ejemplo dice dice Camilo dice asael que que sí no Y sí La respuesta es Sí sí es correcta con respecto a la especificación secuencial de una cola no eso sería como y vamos a vamos a empezar a escuchar esto mucho es correcto con respecto a no es lo que se espera de una Cola Está bien no cumplimos con esto vale Okay entonces eh est eso está o sea como que esta ejecución está fácil porque en realidad
(26:15) esta ejecución concurrente parece que se ejecuta de forma secuencial porque ocupamos candados vale Ah dice zuriel podemos ver por qué Ajá porque sí es correcta sí te refieres a eso verdad bueno es correcta porque si la cola o sea consideramos que la cola primero está vacía No cola vacilla Enton si primero se hace un deq y se obtiene estado de la cola en este punto este pues nada más está así no vacía luego el estado de la cola ká sería que tiene B no hace un enq de B luego acá el estado de la cola sería B a no y el estado de la cola aquí si
(27:17) tiene sentido que lo que se desen Cole el lo que obtiene sea B no entonces el estado de la cola en este punto Pues sería a Y entonces la condición no lo que regresa pues es B Entonces es correcto no con respecto a la definición de una cola que es está de acá enus Este inserta el elemento este Okay entonces esta ejecución está como facilita no porque pues se forman sucede una operación después de otra por qué Porque usamos candados no O sea se forman pero como que aquí La pregunta sería Okay pero si la ejecución es
(28:19) concurrente o sea realmente concurrente como algo así no O sea aquí Cómo cómo armamos nuestra historia secuencial no o sea quién decimos que pasa primero O sea por ejemplo decimos que esta pasa primero y esta después y esta después no O sea cómo cómo armamos nuestra historia que realmente sea secuencial no que vaya una después de otra porque pues esto es meramente o sea puro concurrente no entonces esa es la como lo que vamos a ver ahorita no eh las reglas para transformar cualquier historia concurrente como esta en una secuencial
(28:59) Vale entonces eh este primero vamos Bueno les voy a definir aquí varias cosas en sí los métodos las llamadas a métodos creo que ya las había definido Pero bueno lo vuelvo a poner acá una llamada a un método pues es un intervalo vale que Inicia con un método de invocación y termina con un evento de con un método de respuesta no evento de respuesta Bueno en realidad aquí me equivoqué es evento si porque un método pues es el intervalo pero el evento pues es un punto vale una disculpa entonces empieza con un evento de invocación y
(29:41) termina con un evento de respuesta Así va entonces en el mundo secuencial las llamadas a un método Pues sí son secuenciales no O sea como estas precondiciones y postcondiciones que vimos no este pues ejecutas el Lio de a luego el de b y así no pero en el mundo concurrente pues existen interacciones o sea se traslapan entonces hay que analizar estas interacciones no Qué pasa si estas se Ejecutan al mismo tiempo no ahí son se traslapan y esta se traslapa también entonces cómo analizamos eso Ah entonces bueno en este es la anotación
(30:18) que se usa en el libro en la mayoría bueno Y la que yo suelo usar también pero van a encontrar como también varias formas luego no sé este escriben luego los métodos bien extraños no como W este escriben que según se escribe uno así no en vez de poner el el parámetro de entrada Aquí Pero bueno o sea como consideren Esto vale ya si no les este me preguntan y les digo cómo cómo nombran a sus métodos Porque si varía de libro a libro pero bueno entonces este sería el parámetro bueno s parámetro de entrada de entrada Esta es la
(31:05) llamada al método Este es el objeto porque ahorita hemos hecho todo en un mismo objeto por eso no lo hemos puesto y este es el hilito y acá también el hilo el objeto y aquí ya no ponen como el este En el libro no ponen la el método o sea como la respuesta ponen nada más este ajá si la llamada porque pues no sé si se ejecuta este en que no la respuesta es como de Pues sí lo logré no Y regresas vacío y ya está es como eh se refiere a Esto vale evento de invocación sería este de aquí y evento de respuesta sería como pues al final no
(31:59) lo que regresas pues pues simplemente regresa un vacío Vale entonces eh Cómo se diría lo que devuelve Bueno sí lo que devuelve gu respuesta no Entonces por ejemplo eh otro otro sería como de el hilo p hace a hace un dq no y qué devuelve el dq Pues sería este del hilo a Pues no sé un valor x no Y así también se vería como inicia aquí y termina acá vale es como la anotación para referirnos a estos eventos Entonces este ya les hablé ahorita de historias no pero bueno les he dicho bien Qué es pues una historia simplemente eh Es una forma
(32:51) de hablar de una ejecución en realidad una historia y una ejecución ambas son una secuencia finita de eventos ambas son eso vale o sea por ejemplo esto de aquí pues sería una historia Entonces cómo sería esta historia pues por ejemplo primero tenemos un evento evento de invocación no y luego en la historia en el tiempo por ejemplo lo siguiente sería esta tenemos un evento de invocación otra vez luego lo siguiente en la historia sería por ejemplo eemplo este que es el evento de respuesta Así ya vieron entonces una historia es un una
(33:35) secuencia finita de eventos de invocación y de respuesta no precisamente seguidos no puede ser que haya dos de invocación o tres o un buen y luego uno de respuesta o varios de respuesta Así entonces Esta es una historia la diferencia simplemente entre ejecuciones e historias porque a veces van a escuchar van a leerlo en el libro este o lo escuchan de mí es que simplemente la historia se refiere más como a como el modelo matemático vale Cuál es la definición entre un evento de invocación y un evento Cuál es la definición de un evento de invocación
(34:12) porque pensé que el enq era diferente a un deq Ajá sí sí sí este digamos que el evento de invocación simplemente es el inicio de una llamada un método okay O sea por ejemplo e método un método un método es enq No ese es un ejemplo de un método pero también otro método Pues es de q no es es otro método simplemente entonces con su descripción y todo no imagínense que acá tenemos la descripción descripción de ambos métodos no O sea si no sé en Java tenemos Ah okay Entonces no importa si en q deq ambos invocan a un método Ajá sí digamos que pues el
(35:11) método es así pues la descripción no y luego la llamada a un método pues ahora sí es invocarla en el tiempo no o sea es La invocación en el tiempo Esa es la llamada un método Pero además esta llamada un método tiene un un inicio y un final el inicio es el evento de invocación Y si el final es el evento de respuesta Okay entonces dice orel Ah okay Entonces no importa si es enq deq ambos invocan a un método Ajá sí o sea los los los hilos van a a van a invocarlos Exacto Okay entonces este Ajá sí Entonces estamos en las historias yo les
(35:56) había comentado no que tanto una ejecución como una historia son simplemente secuencias finitas de eventos como este Esta es una historia no vista como bonito no vista de forma gráfica pero pues la podemos escribir Ay la podemos escribir así no Así tal cual entonces eh la diferencia entre estas dos Es que la historia pues es el modelado como más matemático Vale y la ejecución es tal cual así como la vemos o sea pero a veces las Us de forma indistinta vale Si no es muy formal el como que lo que leemos entonces sea si consideramos no
(36:36) que sea heo una historia entonces una subh hisoria de H pues simplemente será una subsecuencia de eventos no por ejemplo estos tres serían una subh hisoria no si la cortamos aquí sería una subh hisoria de la historia grande Vale entonces así primero historia secuencia eh de eventos en entonces una llamada a un método en una historia pues simplemente como ya vimos no tiene un evento de invocación y de respuesta entonces simplemente este y aquí la diferencia bueno mucho texto Pero bueno la diferencia simplemente Es que este
(37:13) hacen match Okay por ejemplo este es el evento de invocación no hago yo un deq invocación y el evento de respuesta es que obtengo Uno Vale es como este invoco de que y y La respuesta es uno y hace match Por qué Porque comparten vamos a ver si lo escribimos así comparten el mismo objeto y el mismo hilo Vale entonces por ejemplo supongamos que esta implementación de aquí pues se hace todo sobre el objeto q no de cola Entonces si quisiéramos escribir esto así con la anotación pues simplemente sería q no punto de q bueno
(38:02) Esto lo hace el hilo p y la respuesta sería p sobre q y el resultado es un entonces este es el evento de invocación y este es el de respuesta entonces hacen mat por qué Porque ambas son hechos por el mismo hilo y están aplicados al mismo este objeto entonces una invocación endiente simplemente es una es una invocación que no tiene respuesta con match no por ejemplo esta de aquí Esta es una invocación una invocación pendiente simplemente pues este el el hilo q hace hacia el objeto q mayúscula el hace un enq de dos y pues ya no no
(38:58) tiene ahí como una respuesta se queda ahí pues pendiente No qué esperaríamos una conch Pues sería como que regrese este q y que diga pues vacío no lo logré pero pues no digamos que no tiene no no tiene esta Ah en la nota tendría que decir entonces si no tiene una respuesta no Ajá sí sí también no Ajá Es que aquí como que bueno es como el formalismo como que dicen este bueno siento que lo hacen así porque por ejemplo tienes una un evento de invocación y un evento de respuesta y esperas que sean sobre el mismo no pero
(39:46) por ejemplo puede ser que existan en esta historia Pues también existen respuestas de kuno Pero tiene que hacer match porque tiene que ser del mismo proceso no y hacia el mismo objeto puede ser que tengamos de distintas no entonces dices Bueno mira aquí hace match Sí pero o sea bueno Esta es una Este es un evento de respuesta Sí pero no hace match porque no lo hizo el mismo proceso Vale entonces nada más como que una una notación como formal no O sea tiene que ser del mismo proceso y tiene que ser del mismo objeto y ya o sea solo
(40:18) a eso se refiere pero sí En realidad podrías decirlo es pendiente si no tiene respuesta y ya entonces este vamos a ver no una extensión H prima de una historia H simplemente se construye a partir de Añadir algunas respuestas a operaciones pendientes Entonces por ejemplo en esta historia tendríamos si de una vez escribo H sería este ah el hilo p hace un dq Ah bueno todo es al objeto q vale objeto entonces p hace este un dq y luego eso sucede No aquí luego por ejemplo se hace unq q hace un hace q punto en q de 1 no
(41:32) luego por fin se obtiene la respuesta de p p q punto eh se regresa un y luego la respuesta acá sería este p p este se regresa vamos a pensar Ah no es q q Ah bueno aquí por ejemplo regresa verdadero y luego ahora sí vamos acá no p hace q de q luego Q en q de dos me cabe un poquito más error luego p este la respuesta de p simplemente aquí es dos no y ya Ya acaba Esa es la
(42:39) historia Vale entonces la extensión H sería simplemente Añadir cero o más respuestas cero porque puede ser que no añadas nada vale pero por ejemplo una extensión de esta historia podría ser eh simplemente pues la historia completita no puede ser esta No simplemente así porque añade cero respuestas dice pero Ah sí se me faltó verdad tienes razón Sur bueno es que aquí la había dejado pendiente pero le escribí no hay que pensar que no regresa si es que no la había cerrado vale como que quería Mostrar el ejemplo cuando quedaba
(43:28) pendiente por eso no la cerré pero sí la escribí Bueno hay que considerarlo así vale Pero gracias Sí sí sí sí sí sí así luego los hago bas pero entonces Este es un ejemplo de una extensión otro ejemplo otra extensión Pues sería Ahora sí realmente completarla no q y ahora sí poner no el true completarla no decir Ah pues que regresa pues hay que regrese true el truque ya estaba Entonces esta sería como Bueno supongamos est es un un una una extensión no cuando no agregué o sea agregué cero respuestas o esta otra
(44:09) cuando agregué una respuesta a una invocación pendiente ese sería un extensión Vale entonces una historia completa eh tengo la mismita Ah mira aquí sí la puse bien Ajá sí O sea como no le puse Aquí ya viste entonces Entonces vamos a copiarla que no escriba otra vez todo entonces por ejemplo Esta es una historia una historia completa simplemente denota la historia obtenida a partir de quitar las invocaciones pendientes Vale entonces por ejemplo aquí una digamos que la extensión pues es completar No si si quedó ahí
(44:49) este si está se haya una invocación pendiente la extensión te dice Ah bueno Pues busca si la puedes le puedes puedes poner una respuesta no O sea digamos que aquí ya vieron me creé yo la respuesta y la puse como yo quise no y acá también la complete lo que nos dice pues es como de pues no la completes simplemente bórrala no entonces complete th dh sería simplemente Cuál es la invocación que está pendiente en este caso miren en este caso se regresa mt no No dos sí empty y este a es lo único que cambiar esta entonces simplemente sería
(45:38) esta es la pendiente que es esta de aquí entonces simplemente la borramos no y así decimos est sería complete no complete que nos regresa eh siempre nos Bueno siempre construye historias completas completas es decir sin invocaciones pendientes V la diferencia entre extension y complete Vale entonces Ah bueno también existen proyecciones de un hilo y de un objeto no por ejemplo También acá No si tenemos esta historia la proyección de un hilo este sería así se escribe de esta forma por ejemplo lo que lo que solo hace el
(46:45) hilo p No pues lo que solo hace el hilo p Pues sería esto esto esto y esto no Entonces es así oa como que digamos que es la historia de lo que solo hace Lilo y también podemos Construir la historia de solo lo que se hace sobre un solo objeto en este caso pues sería la misma Porque todo lo hacemos sobre un mismo objeto Pero puede ser que exista un entrelazado de dos de una ejecución en donde tengamos dos objetos pero por ejemplo aquí Pues en este caso todo hace el mismito hdq no es como nada más como selecciona lo
(47:39) que lo que estás Este hecho no para un objeto o para un proceso y la historia secuencial va a ser el conjunto de eventos de invocación con su evento de respuesta que hace match enseguida por ejemplo eh esta historia de aquí la que llevamos No pues esta no sería una historia secuencial Por qué Porque eh dice dice aquí no que hacen match enseguida o sea quiere decir que que esta por ejemplo haría match con esta no entonces tendrían que ir enseguida esta hace match con esta y tendrían que ir enseguida Por qué hace match porque
(48:15) compartimos proceso y objeto Vale entonces estás en match estás en match no este y y no sé esta haría mach entonces est sería Esto sí sería una historia secuencial no A diferencia de lo que teníamos Entonces por ejemplo esta también sería una historia secuencial por qué porque tenemos el evento de invocación y el de respuesta que hace match enseguida invocación y respuesta que hace match no Entonces este pues sí esta sería una historia Vamos a ponerle secuencia un ejemplo no también como esto entonces este una historia vamos a decir
(49:01) que es legal o que es válida si para cada objeto o sea su proyección está de acuerdo a la especificación secuencial del objeto x Entonces por ejemplo No ya construyéndolo así dejen s lo voy a construir esta historia Pues sería así Simplemente no todo está sobre el mismo objeto Ah miren aquí lo Lama q entonces pero q chiquita Entonces sería como q el objeto Bueno lo hace el hilo este c al objeto q hace dq no y enseguida obtiene empt luego el objeto B hace q puntoq b y aquí tiene eh [Música] Pues sí vamos a pensar que regresa que
(50:00) lo logró true luego aq de a luego c punto de q b y regresas no este bueno ponerlo así entonces esta sería la historia secuencial no Entonces vamos a decir que una historia Es legal con respecto no a un a un objeto o en este caso a una cola si está en la especificación secuencial de en este caso la cola entonces Eh entonces la pregunta del Quiz simplemente es si esta ejecución esta que ya les escribí aquí que es una historia secuencial Por qué Porque pues tiene su invocación y su respuesta Que hace match no su invocación y respuesta
(51:03) que hace match si esta historia secuencial Es legal con respecto a una cola Entonces ustedes Cómo la ven ya la habíamos revisado se acuerdan de Cómo la ven ustedes s dice s exacto no si es si es correcta No a qu se refiere hx a la proyección de la historia H sobre el objeto x escribo proyección de la historia H sobre el objeto x a eso se refiere Entonces esta historia como está toda hecha sobre el mismo objeto en este caso que es q no Entonces por ejemplo H sobre
(52:09) q sería igual a h o sea es la mismita Vale entonces es correcta Sí con respecto porque q es una cola que tiene este de q y enq no O sea que tiene estos dos métodos Entonces es correcta vale en Entonces este ya empiezan los Quiz no esta historia la ven secuencial o es secuencial si nosotros hacemos así como ya este me vieron no haciendo escribiéndolo No la v secuencial no Ajá exacto no no no es Ajá Por qué Porque a cada invocación no le sigue enseguida su respuesta Que hace mach Ajá vale vale Sí Exacto Este Entonces como por
(53:16) qué porque pues primero sucede una invocación no y luego que sucede otra invocación y pues ahí ya no está la respuesta que hace vale q2 deq s no no precisamente este es es porque justo Esto vale porque tenemos por ejemplo primero el proceso p este hace un dq Y luego el proceso q hace un enq supongamos que al mismo objeto q Vale entonces hace un enq de uno no Y así va la historia porque eso pasa primerito no es lo primero que pasa en el tiempo Y eso es lo segundo que pasa en el tiempo Entonces esto ya no hace match no tendría que seguir enseguida
(54:09) pues la respuesta de p que pues es uno no pero entre entre mi invocación y mi respuesta ya tengo La invocación de alguien más pues ya no hace March Ajá sí Exacto Eduardo toda historia puede transformarse a una historia secuencial y ahora vamos a ver eh Pero bueno igual no me da tiempo ahorita este 4 minutos aj Bueno vamos a transformarlo ya con las reglas de la analab Vale y estas reglas simplemente de la analab nos van a decir que este ver lo tengo hasta acá miren lo que nos dice la laliz habilidad No simplemente es
(55:03) este sigue estas dos reglas no son estas dos reglas regla uno si una llamado método precede a otra no le hagan caso ahorita al orden parcial ahorita la clase del viernes lo vemos simplemente consideren Esto vale si una llamada precede a otra Entonces la llamada que sucede antes pues deben mantenerse en el orden antes simplemente es lo que nos dice y dos si dos llamadas se traslapan ordénalas de la forma que más convenga Esas son las reglas que nos da esta condición de corrección que es la an elizabad para transformar
(55:44) cualquier ejecución secuencial a una concurrente Perdón cualquier al revés cualquier ejecución concurrente o sea una historia concurrente a una secuencial vale sí es lo único son las únicas dos reglas entonces estas dos reglas este en este caso por ejemplo nos dirían estas dos dos llamadas a métodos se traslapan entonces ordénalas de la forma que más convenga cómo nos conviene más pues nos conviene que primero suceda en q1 que primero se encule uno y después se desenele no cómo va a ser que se desenca que no que no sea encolado
(56:30) entonces que no podemos Modificar el orden de las que sí realmente se preceden Cuál es el orden de esta esta el orden de esta esta el orden de esta esta y el de esta esta no entonces estas dos también la podemos ordenar de la forma como queramos pero este orden entre estas y estas se deben mantener Entonces el otro orden sería que es suceda primero pues me gusta más no que suceda en q2 Y ahorita la siguiente clase vamos a ver cómo pues la hacemos con estas operaciones pendientes No pero lo que nos convendría es que primero
(57:09) sucediera sucediera en q2 y luego sucediera de q2 Vale entonces es es este lo que nos dice eh las reglas de la analizaba aj s dice Dice Eduardo si de q1 y en q1 no se trasladaran eso podría seguir haciendo No no se podría no si si suponemos que el de q1 No termina ahí sino termina acá por ejemplo y entonces no se traslapan no Entonces se tiene que respetar el orden y entonces tendríamos una ejecución que no sería pues Correcta Por qué Porque primero se desenca un evento que no está no que se encerró después cómo va a ser no Entonces si
(58:04) sucede ya no se podría Ajá entonces lo que nos dice la angeliz habilidad pero este miren aquí tenemos este el orden parcial no el orden total Eh y además este ya viendo así la definición que está en el libro para que la entendiéramos también la extensión y lo complete las usamos para estas ejecuciones pendientes o sea como que hacemos no las completamos las extendemos y además este hablamos de orden parcial y de orden total y bueno ya también sabemos que es una historia legal o sea les digo como que son muchas
(58:49) definiciones no Pero bueno ya tienen la idea no de de cómo Pues en realidad son dos reglitas así que se leen fácil no pero pues la definición Sí está como pesada y la la clase del viernes Terminamos ya de verl todo esto del orden total el orden parcial los puntos linealización y este ya pues hacemos los Quiz vale para ver si si cacharon bien que es una extensión y que es una historia completa vale Ah Bueno nos vemos Nosotros mañana en laboratorio a las 2 en la mañana le subo su práctica Vale entonces nos vemos Bye Nos vemos
(59:40) mañana by buen
