2024 09 23 10 03 51 - YouTube
https://www.youtube.com/watch?v=sGphff-csC0

Transcript:
(00:08) Okay a ver nos habíamos quedado en e nos habíamos quedado en el Snapchat atómico la implementación que es weight free Y así vamos a comentar En qué consiste esta implementación Pues que como queremos que el update también sea wiit free este es decir que todo y lo que quiera cabe o sea tenga éxito no te acabe de ejecutar este scan en un número finito de pasos Pues los updates van a ayudar a los scans como pues van a ejecutar también un scan cada upate también va a ejecutar un scan y va a guardar ese scan digamos
(00:52) que el resultado la vista lo va a guardar en su en su arreglo no Además del valor así que este consistía En que si si un hilo está haciendo scan el hilo a y un hilo B este actualiza su valor dos veces Entonces el scan de de a le roba la vista al update Vale entonces en eso consiste el código có se ve habíamos visto visto que eh tenemos pues nuestra tabla de registros que esta sí es compartida es nuestra tabla atable no y en cada atable tenemos eh el valor como encapsulado el timestamp el value y el Snap no O sea si alguien ya hizo update
(01:56) pues va a tener estas estas tres este estos tres valores entonces de forma local cada hilo tiene un arreglo de buanos m entonces cada vez que un hilo quiera hacer un scan pues va a crear esta este arreglo de de buanos Y entonces inicialmente todos van a estar en falso y si un hilo se mueve la primera vez lo marcamos en verdadero para que así si se vuelve a mover No pues en la lía 19 preguntamos si ya se había movido una vez pues entonces Agárrate la copia de este de ese Agárrate la copia de ese hilo no O sea ya la vista que ya
(02:46) hizo Pero bueno también puede ser que el el scan vaya solo y simplemente pues la copia este vieja es igual a la nueva no entonces sales de aquí sales del y simplemente regresas lo que viste no o sea puede ser que regreses una vista tuya o sea propia no o puede ser que regreses una vista pues robada o sea bueno no prestada no este te robas este te llevas la vista del hilo que se movió dos veces puede ser entonces este Ah bueno y como les comentaba no O sea tenemos los tres valores en el update el stamp el value y
(03:29) el Snap pues es la copia de de los n valores de a Table entonces así funcionaban estas dos nos habíamos quedado en que Bueno o sea hay que hay que analizar este algoritmo la primero es pues que yo les comenté no es weight free este Ay no no empecé a grabar prog Okay entonces lo primero que les comenté de este algoritmo es que es weit free es que es linealiza y es que es este y y bueno también tiene esta Curiosidad no que se roba la vista de un hilo que se mueve dos veces y no una vez no y no tres entonces ahí tenemos tres
(04:15) preguntas que hay que responder entonces e yo les había comentado que eh Por qué Por qué este en resumen porque Bueno no sé si quedó claro pero voy otra vez este Por qué nos robamos la vista Por qué por qué no nos robamos la vista de un hilo de un hilo que se mueve solo una vez vale Entonces tenemos A B y C Entonces yo les había comentado que no nos podemos robar la vista de un hilo que se mueve solo una vez porque el
(05:19) update el el método update hace Bueno aquí voy a poner vale el método update o se general qué es lo que hace pues primero hace un scan no y luego ahora sí pues hace un este Table y bajo bueno vo ponerlo a Table mi valor nuevo no es lo que hace el update pues primero realmente hace el scan y luego por fin actualiza porque que el resultado es scan el Snap no lo mete en el nuevo valor en en la en la en la reglo de a Table entonces quiere decir que por ejemplo si yo tengo aquí un hilo no que está haciendo este Bueno creo que dejen pongo
(06:21) distinto Okay tenemos un Nilo aquí que está haciendo un escan no escan Entonces tenemos acá Este unilo que está haciendo un update y este y tenemos este otro acá por ejemplo que hizo aquí un update Entonces estos updates tienen un scan aquí sucede un scan aquí antes de que finalmente se actualice entonces Déjenme escribo aquí update de a y update de B entonces eh Por ejemplo si el scan se acuerdan no lo primero que hace pues es una old copy luego hace una New copy Entonces si si por ejemplo Por fin se actualiza no este
(07:21) aquí en a Table en esta en este punto entonces este supongamos que pues nos robamos la vista de un hilo que se mueve solo una vez o sea con una vez nos baste Entonces digamos que eh en este punto eh a no está en Old no pero a sí está en ol y b está en ol y b Ay perdón en discp y B está en en New no O sea B pues está en los dos B ya se hizo acá o sea B Se actualizó desde acá Vale entonces qué qué qué puede pasar Bueno si nos robamos la vista de un hilo que se movió Solamente una vez pues no sabemos si esa vista está actualizada
(08:22) Vale entonces si nos robamos este por ejemplo este no dice róbate la vista roba la pista de B no del hilo B entonces en el hilo B por ejemplo Qué sucede Pues bueno el scan que se hace aquí no que es es esta el escan de aquí no tiene la actualización de B no entonces y así no concretando esto si se roba la vista de B entonces eh el scan de a no verá la última actualización de C Que es precedente no O sea debería
(09:28) estar es muy importante es precedente como es precedente pasa antes en el tiempo Pues debería estar entonces si te la robas nada más y se mueven una vez Pues en realidad no sabes qué tan atrás se hizo Este scan vale o sea es como es por eso que no nos la robamos una vez ahora por qué Si nos la robamos Por qué funciona con que nos la robemos dos y no más no Por qué funciona con dos Eh bueno funciona si eh nos robamos la vista de alguien que se mueve dos veces Entonces supongamos no que tenemos aquí otra vez los hilitos A B y C Y
(10:30) tenemos otra vez Dj ver Ah los scan los puse en azul Entonces tenemos aquí el scan por ejemplo no tenemos aquí un update de B supongamos no que sucedió acá y luego este otro AC Y tenemos este de aquí vale entonces así así tenemos Este es un update de B este es update de c y este es un update de D Vale entonces cada update pues tiene su propio scan entonces supongamos que el scan de acá pues está bien viejo no sucedió hace un buen pero pues hasta acá se hizo la actualización imagínense es que son cosas que sí pasan en o sea porque los
(11:28) hilos no hacen las las operaciones justo después no sa no tenemos la certeza de que Elo es rápido No este entonces pues si pueden pasar estos como delays aquí y luego supongamos no que Este hizo aquí su scan y y actualizó aquí su valor y este pues lo actualizó antes Entonces digamos que sí o sí d debería estar en este scan o sea en la vista que devuelva Este scan Entonces por ejemplo no imagínense que aquí seale la All copy aquí sale la New un Entonces ve que se mueve y en el arreglo o sea bueno digamos que en las
(12:16) banderas pues diría B es igual a true no y después acá no sé supongamos que se tarda un poquito Y acá hace new2 Entonces este pues aquí revisaría no en el código diría Ah Mira pues ya se movió otra vez Entonces me robo de all copy pero en realidad all copy es esta o sea es New no porque lo que hace en esta línea es igualar Entonces te robas la de New este y e sí no es copy Entonces como old pues es igual a New 1 no Entonces te robas la actualización de Déjenme
(13:31) Sí sí Bueno entonces o es igual a New y este lo que haces Es que sabes que que hubo un update no entre que viste el último valor y entre que se escribió el siguiente que fue el que viste que se movió entonces quiere decir que si te robas el scan que hizo este digamos que esta te robas el scan que hizo el update dec te va a constar que este esto realmente sucedió entre digamos que es concurrente no O sea te vas a robar la vista de alguien que es concurrente a ti entonces e lo que vas a hacer es e Sí pues sí entonces Bueno en realidad
(14:33) all copy es igual a un pero lo que está escrito ya lo que está escrito es la última actualización vale es esta de aquí de o sea digamos que el Snap pues lo que ya está escrito es esto entonces lo que va a hacer el hilo es que se va a robar digamos que a se roba la vista de de b y qué vista la última vale la última La Última entonces quiere decir que es esta de aquí y este como e la primera vez que se movió sucedió mientras se ejecutaba el el escan de
(15:42) a y este y la segunda eh vez que es nu B sucede e mientras se ejecutaba el está no sea igual entonces sea la vista de Venus la primera la primera vez que se vió que se mueve B sucedió mientras ejecutaba ya el escand y la segunda vez que se mueve B sucede mientras ejecutaba el escand de a Entonces esto quiere decir entonces el
(16:51) scan del que me robo la vista Bueno del que Ah se roba la vista está es concurrente Vale entonces esa es la idea Por qué sí funciona por qué O sea por ejemplo acá pues si te robas si solo se mueve una vez te puede salir un esan Ajá Pues un scan que pues sucedió mucho antes y no sabes cuándo no en cambio Si te robas la vista de alguien que se mueve dos veces tienes la certeza de que este scan que te vas a robar sucede entre la primera que lo viste moverse o sea concurrente y la segunda vez que lo viste moverse es decir concurrente
(17:34) entonces sabes que el scan es concurrente a tu scan y no sucedió mucho antes no o sea porque aquí pues no tienes la certeza si te robas esto de acá pues no O sea imposible pero si te robas el scan que sucedió aquí pues sí O sea sabes que este scan debe contener todos los anteriores y por lo tanto si iba a tener a este por ejemplo no cosa que acá no pasaba O sea no tení est ación a pesar de que sucedía antes vale entonces es la idea de de que te robas la vista dos veces entonces de aquí Bueno un poquito de aquí sale que porque si es linealiza
(18:16) Vale entonces o sea porque es linealiza el scan Sí porque lo que devuelve un scan uno que no se traslada con nadie son los valores que ya exist tienen los registros no ciertamente O sea si un scan va solo a qué me refiero Pues si un scan va solo aquí no Y tienes aquí como Ay pues muchos updates no este y así Tienes muchos updates muchos updates Y entonces Aquí empieza un scan Pues sí ciertamente lo que nos dice el código es que el scan lo que hace Pues solamente es eh una un for no te hace un for leyendo todos los registros
(19:03) vuelve a hacer otro for leyendo todos los registros y como no va a haber nadie pues van a ser iguales y va a salir de este for Bueno más bien de este If no este va a salir hasta acá no ciertamente sí no sí es cierto la uno es cierto y la dos es que si un hilo a Observa que otro hilo B se mueve dos veces entonces B escribió en su registro Y tomó su una vista sin traslaparse con nadie no entre los d collex de a Entonces a qué se refiere esta esta de aquí nos dice no este sí si tenemos al hilo este a y al hilo B
(19:50) no Entonces dice que aquí que si un hilo a Observa que el hilo B se mueve dos veces a está aquí haciendo un escan no y Observa que B Se movió dos veces aquí y acá no entonces quiere decir que para que este scan haya visto que B Se movió dos veces quiere decir que pues este estos los minian no O sea pues estos scans que están aquí debieron acabar en y dice no en este Ajá sí o sea dice que entonces B pues pudo tomar la vista sin traslaparse con nadie no para poder terminar y y moverse para para a no O sea est estos
(20:38) dos estos dos este Bueno les dicen Double collect porque es este la unión de old más New copy sea así les dicen no los dos Double colle porque pues ha es como que es es la línea 14 y la 15 entonces dicen que que B tuvo que haber tomado esos Double colle No pues Sí este all má New no y old má New también aquí este sin traslaparse con nadie no Para qué pues para salir dos veces este en el escan O sea que en el escan de a eso es lo que tuvo que haber pasado en este punto dos y en el punto tres no finalmente Es que este es esta es así la
(21:22) que resume por qu eh porque esto de de de este de robarse la vista de alguien que se mueve dos veces vale nos dicen los valores de la vista que regrese un scan se encontraban en los registros en el intervalo entre su llamada este y Bueno o sea digamos que es entre su evento de invocación y su evento de respuesta o sea en su intervalo Por qué por uno y por dos no Entonces digamos que aquí este como les había comentado No si por sí funciona si se mueve dos veces porque quiere decir que eh Por ejemplo no si si pasa el el el punto uno pues sí
(22:15) claramente este todo esto ya se había sido escrito no entonces el scan realmente devuelve todo lo que pues está en el en el en a Table entre su intervalo de invocación y de respuesta ciertamente No pero si el esans se roba la vista de alguien entonces este también va a a este a regresar los valores que ya estaban escritos entre su invocación y su respuesta por qué Porque al robarnos este la vista de alguien que se mueve dos veces como les comenté no O sea tenemos la certeza de que aquí se robó no O sea aquí se movió eh
(22:56) movió primera no primera primera vez que se movió y acá es la segunda vez no entonces sabes que el scan que te estás robando es concurrente a ti entonces ciertamente se cumple esta este caso tres porque lo que tú devuelves sí sucede entre tu invocación y tu respuesta aunque no realmente tú lo tomaste te robaste la de alguien pero te consta que que el scan que te robaste es concurrente a tu escan y por eso es linealiza y este y Bueno o sea aquí ahorita vamos a lo a lo de por qu es Wi free Pero bueno o sea es que
(23:35) eventualmente alguien tiene un Double collect limpio no y y ahorita vamos a ello el Double collect que damos vale es all copy más New copy y limpio es que pues no se trasladó con nadie y pudo acabar entonces este Por qué es weight free vale Esa es la la pregunta e y Bueno aquí aquí se esce una precisión de hecho es bounded we free eh Porque no solamente decimos como es como dice Wi free no Wi free nos dice cada llamada debe terminar en un número finito de pasos acá Este nos dicen que es bounded porque cada llamada termina
(24:19) un número finito limitado Pues sí no limitado como free pero muy importante tiene pasos o sea hasta te voy a decir una Cota no una cota de Pues de complejidad entonces aquí está eleman no lo pasé español pero entonces nos dicen que de hecho esta Cota Cuál es pues es una complejidad cuadrática y Bueno aquí dice no cuadrática de lecturas y escrituras este entonces cada scan o cada update pues termina en un número eh cuadrático de lecturas y escrituras [Música] a ver entonces por qué Por qué acaba vale justo de para
(25:09) [Música] este Déjenme ver si está la esta Sí la voy a dibujar yo entonces por ejemplo Ah dejen escribo mejor más delgadito tenemos así varios hilos vale muchos muchos hilos porque pues esto es una implementación para para n no y así hay varios Vale entonces eh Tenemos aquí a los hilos a b c d y así ya está no sé Z no Entonces miren Bueno lo que nos dicen aquí así ya bien breve no es que nos dicen para un dado como solo hay otros n men Un hilos no supongamos que aquí pues este son n hilos entonces después de n más un hilos
(26:13) Perdón después de n más un dul collec algún scan debe estar limpio o algún collect se debía haber movido dos veces y entonces el escan las llamadas al escan son W free entonces Bueno vamos a decifrar esto con este ejemplo este tenemos n hilos Vale entonces qué nos dicen que tenemos un scan un escado vale que está Pues aquí corriendo no bueno no sabemos si acab ahorita les voy a vamos a debemos analizar no que realmente acaba ent este scan no pues va a sacar una vista ve Entonces por qué no podría terminar este scan así
(26:57) en un solo collect a ver este si me cachan verdad lo que son los collec porque estoy diciendo as ahorita qué tal que no me cach pero bueno sí O sea en un solo Double collect es decir en un solo digamos que en un solo for vale o sea esto es el Double collect dos veces collect copy más New copy o sea como que la idea es que si acabas en un quiere decir que pasaste este for sin problemas y terminaste acá vale o sea como que no no viste que nadie se movió es la idea de un Double collect limpio entonces este bueno por qué no podría acabar este
(27:43) en un Double collect Pues porque alguien se movió No si alguien se movió pues claramente no no acabó Entonces por ejemplo aquí pues es es una old y New no es es un Double collect pues no acabó porque resulta este por ejemplo no es que miren aquí se ve copy supongamos no más New copy entonces este Por qué no pudo haber acabado Pues porque aquí hubo un scan que s acabó no que se acabó o sea aquí se escribió y entonces no acabo este Okay pero por ejemplo este Eh entonces Bueno ese es un ejemplo no y y la otra es eh supongamos No que este
(28:47) scan así hacemos un zoom no supongamos que Este scan e Pues también se tardó un poquito pero bueno por qué pudo haber sido que se tardó un poco este scan pues porque hubo aquí un update no que se tardó Bueno un update aquí entonces se pudo haber tardado este scan porque hubo otro update no pero bueno después hizo un Double collect acá y salió limpio no Entonces supongamos que que este este hizo un Double collect no all copy New copy old new y luego otra vez hizo otra all copy New copy y esta Sí salió limpia no y por eso
(29:35) acabó Y entonces pudo molestar al scan de arriba no pero bueno supongamos que es otra vez se tardó Y entonces por qué porque hubo un scan que terminó hubo un scan de bd que no y y así O sea si se dan cuenta nos ponemos así a jugar a las muñecas rusas Ajá es una copiad era de scans no es que siempre hay que hacernos la pregunta si alguien si si alguien interrumpió mi scan es porque alguien pudo hacer un scan no Entonces qué es lo peor que nos puede pasar pues que yo soy el scan no O sea bueno aquí ya está haciendo el sc pues es un hilo
(30:25) entonces quiere decir que los n men un hilo o sea es es el peor escenario no los n men Un hilos se pusieron a hacer updates al mismo tiempo y bueno Y acá imagínense Noa Así sigue como esto de las muñecas rosas no O sea sigue acá y y y haces aquí un scan entonces imagínense No eso es lo peor que nos puede pasar que que yo estoy haciendo un scan y de repente todo el mundo haga un update pero este como todos los updates hacen scan quiere decir que eventualmente [Música] no para que el scan de a no termine en un solo Double
(31:21) collect no Entonces a entonces de debió haber al menos un scan con un Ay con un Double collect limpio O sea que acabó literal o sea tomó el copy New copy dijo son iguales y acabo entonces aquí pues este pues nos jodió no al de arriba este pues sí no pues ya y con esto hiciste que este de aquí no fuera un Double collect limpio entonces este cuánto se habrá tardado no suponiendo que que así esteé entonces este por ejemplo pues dio este dos doubles no dos Double collects ya la siguiente salió bien y este eh supongamos que entonces dio tres doble
(32:25) collec y este entonces Cuántos dio cuatro Google collex no y así entonces imagínense si tenemos n-1 hilos quiere decir que al menos uno o sea para que pues le alargar el escan al otro tuvo que haber terminado así en literal nada más haces este tomas un un al copy un New copy son iguales no entonces el siguiente va a ser Ah no Mira se movió Este pero la siguiente ya acabé y y así de arriba va a decir Ah este pero la siguiente ya acabé y así no entonces al final resulta que o se si hacemos así el análisis quiere decir que
(33:02) lo peor que le puede pasar a este scan no O sea si se mueven todos los demás haciendo update quiere decir que va a ser este eh n men Un no veces que eh dos n leídas no Por qué 2 N leídas es este el Double collect no O sea hacer el copy más el New copy el double double collect Este Entonces vas a ser n men Un veces leer dos veces no New entonces quiere decir que aquí está la Cota en cuadrática Vale entonces bueno Está interesante si más o menos como que vieron por s acaban si acaban los scans buen Está interesante no está muy bonito
(34:01) Ajá vale vale Y este Ah bueno si es que dej este porque luego ocupo Disculpe profesora Cuál era la diferencia entre obstruction free y weight free obstruction free Es que solo acaba si este un hilo va solo no y weit free es que e cada llamada termina en un número finito de pasos entonces bueno este así poniéndolo no [Música] obstruction free entre weight free por ejemplo no O sea lo que nos dice obstruction free es que pues aquí hay así un montón de updates no Y entonces el scan solo va a acabar cuando vaya solo no y pues en
(34:57) realidad esto le pasa igual a weight free no O sea pues también acaba pero este entonces eh aquí sería como eh un hilo solo termina en un número finito de pasos si va solo no solo si va solo y acá pues ya vieron No est acá pues no importa si si el hilo a no va solo no importa si todos a la vez hacen un update no este scan va a acabar Sí o sí en un número finito de pasos Vale entonces es la diferencia aquí pues este puede ser no que que hacemos aquí un update así u un montón de updates no Y esta fuerza se va a acabar
(35:59) este es la diferencia entonces un hilo siempre termina en un número finito de pasos no no solo cuando va solo la diferencia Pero además yo les comenté que de hecho este algoritmo es bounded bounded free y es es esto no Pero además es algo todavía más fuerte este como que el B todavía te voy a decir si acaba en un número finito de pasos pero te voy a decir exactamente a lo máximo o sea en una Cota De cuántos pasos máximos se van a echar no entonces este cada este método termina en o
(37:03) n cuadrada no es una Cota todavía cuadrática Entonces es así como vamos de este de menos fuerte a más fuerte No ya ver entonces es así este Y bueno ya vimos no porque la porque aquí la Cota es cuadrática porque sí entonces Bueno ya finalmente este está esta esta pregunta si podría pasar que un hilo nunca termine este suponiendo que que no se detiene no O sea e y y bueno no O sea este suponiendo que no se detiene O sea que pues el hilo sí quiere acabar no O sea el hilo le está echando ganas no se durmió o sea realmente el hilo quiere acabar pero
(37:56) pues puede ser o sea es la pregunta no ustedes creen que podría pasar que que un oo nunca termine No creo dice Camilo Ajá sí exacto no este Bueno o sea tan solo porque ya les dije que la Cota es cuadrática no o sea es es así la la seguridad pero bueno o sea más o menos como que bueno si se dan cuenta pues son las las tres no e que vimos este tenemos casos no caso uno Este un un scan no se traslapa no con nadie o si se traslapa con otro scan también no hay problema siempre acaban no este Entonces ese es el caso
(38:49) uno Este Ah bueno y aquí les pongo no no la respuesta entonces si tenemos por ejemplo un update que ese es el problema cuando se traslapan con pero si traslap con un hay problema siempre va a acabar este Por qué Porque por ejemplo estos dos scan qué van a hacer pues simplemente van a hacer este como no hay ningún update nadie que le esté moviendo que se haya movido pues simplemente vamos a acabar este for y vamos a llegar acá y acabamos no entonces este en este caso acabamos en máximo máximo este pues un no por 2n que es el Double
(39:54) collect no el 2n pues es el Double collect en el caso uno cuando va Solito o sea bueno cuando no se trasladan con otro up no en el caso dos este pues es este caso no que les planteé un scan se traslapa con n-1 update no Entonces es es este caso Bueno no sé si lo dibujo no solo solo lo comento Vale entonces se traslap con n-1 updates quiere decir que al menos un El scan Bueno El scan de un update terminó en e 2n no y más
(41:01) eh un esan termina en N - 1 * 2n No ese es el el otro caso y pues el otro caso también podría ser que o sea Bueno ese es un caso horrendo no se traslap con todos los los este con todos no por ejemplo y y bueno acá el caso tres no este y sí un scan se traslapa con n o más updates si se dan cuenta si se traslada con n má updates y uno es repetido quiere decir que este scan se va a dar
(42:08) cuenta que alguien ya se había movido no Entonces si son n o más quiere decir que este es el scan se roba la vista de alguien no porque son Porque alguien ya se movió dos veces entonces a fuerzas va a acabar por eso decimos no que acaba en un en una Cota cuadrática vale Bueno entonces este bueno platiqué con Isabel sobre cómo va y este bueno Estaba pensando en dejar la tarea al miércoles pero como de miércoles a miércoles pero como ahorita ya acabe les doy hasta el martes así si les alcanza para otra ayudantía en martes
(43:14) entonces Bueno aquí dice que se entrega el 30 pero sería el siguiente día vale no sería dees a lunes ser hoy a martes tien el es todavía final para hac ayudantía según yo no está tan complicada pero la verdad no sé como que a veces me pasa que no les cuesta trabajo los snapchats este Pero bueno pero es que sí son como curiosos no y Ah luego hay cada implementación de snapchats este Ajá sí la tarea será de snapchats Ajá sí pues de de lo que vimos ahorita del capítulo 4 que los los registros como Pues los vimos así muy muy
(43:59) ampliamente No pues no este no les voy a preguntar así tanto pero sí deberían lo que sí deberían saber no es este cómo se ve un registro seguro Cómo se ve un regular Y cómo un atómico o sea simplemente un atómico pues sabemos que es linealiza no un regular sabemos que que este que le que que puede tener lecturas no atómicas no O sea que puede leer que una lectura que sucedió antes que otra pue puede ser este más nueva que la siguiente no eso te permiten los regulares y lo seguro simplemente pues es que regresan cualquier cosa No si se
(44:39) traslapan y muy importante esto es solo si se traslapan con alguien no los O sea si un gr se traslapa con un re si sucede Esto entonces es cuando suceden cosas raras con los con los registros entonces este la primera pregunta es eh simplemente es que vean este videito eh es muy pequeño Y pues en realidad donde la parte no donde habla lor de los este de los registros Pues también es es breve vale e entonces bueno eh creo Son 5 minutos lo que dura el video entonces tienen que contestar en qué consiste la transformación de un registro seguro un
(45:22) regular no Y de forma muy breve por ejemplo en qué consiste Pues en poner un registro este otro registro no entonces guardas un valor viejo y un valor nuevo y Cuál es la diferencia entre un registro atómico y uno regular Pues que el regular tienes eh el el atómico la las tanto las escrituras como las lecturas son atómicas y en el regular sol solo las escrituras no y ya pues explicar qué es eso no que puede ser que que regreses un valor que que una lectura regrese un valor más viejo no que que el anterior y qué relación existe entre los
(46:03) registros atómicos y el algoritmo de Bakery para lampor no O sea como de forma histórica vale como ahí dice es que lampor dice que que este que pues sí O sea él dijo No pues es que mi algoritmo de Bakery ocupa registros atómicos y ya después de años Uy como de 20 años s muchísimo este se dio cuenta que no porque como que dejó el algoritmo de ahí no este se dedicó a hacer otras cosas entonces eh si contestar estas tres preguntas vale Ya vi que están bueno siento como sencillas Bueno espero y les digo el video de así como también situación
(46:44) histórica e Entonces ya el ejercicio dos consiste en analizar la siguiente ejecución que pues es una ejecución del snapshot weit free y este La idea es que yo aquí les pongo que la inicialización del snapshot inicialización del Snapchat es este así no puros como empis Entonces digamos que en realidad es como que a Table pues está inicializada así en en puros así vale entonces e lo que nos dicen es que Ah bueno tenemos cuatro hilitos que es el hilito a el hilito b c y d entonces y que les corresponde el registro al a corresponde
(47:39) el cer0 a b el 1 C el dos y d El tres no Entonces esta es la Esta es la ejecución Entonces miren vean aquí tenemos este updates no aquí hay un traslape de updates otro traslap de updates uno con scan y este otro scan que va solito Vale entonces aquí lo que les pregunto es si es posible que que dado los valores de estos no O sea este sería correcto para la implementación del snapshot weight free Entonces por ejemplo sería eh Por ejemplo veamos el primerito no tenemos que bd vea la a a b2 y a b4 no bd tiene a b2 y a b4 si es posible por ejemplo
(48:35) que solo tenga esos y así no entonces eh es la pregunta vale si es posible que tenga solo a2 y A4 entonces bueno así respuesta pues sabemos nosotros que si que que hay que hay que es este encontrar no los puntos entre entre la invento de invocación y de respuesta o sea digamos que en los intervalos rojos no Entonces si es posible como encontrar algo así no Entonces si se dan cuenta aquí no Sería posible Simplemente no Por qué Porque bueno Alguien lo ve por qué no Sería posible que solo tuviera b2 y b4 pero no tuviera B1
(49:27) por por qué Ajá dice Camilo porque el B3 terminantes que b4 Ajá sí sí no y bueno en es como que por ejemplo este o sea digo eh Ajá sí si no debería tener B3 No mira es que por qué no es porque b4 este acaba antes que B1 Entonces si el Snap si el scan vio a b4 pues tuvo que ver todo lo anterior a b4 o sea tuvo que ver a B1 vale a B3 Está bien que no lo tenga porque es como la actualización vale o sea digamos que es o b a b4 o b B3 porque es el mismo registro vale Camilo Este pero tuvo que ver a B1 o sea digamos que
(50:34) si si este b4 está en bd entonces B1 debería estar en bd no O sea este de acá cosa que no no debe no está no entonces eh si tienen si por ejemplo esta ya está contestada No si tiene estos valores pues no es posible que que sea una implementación del Snapchat que vimos o sea del we free que vimos vale no es posible porque el snapshot ciertamente Pues toma el Double collect no de todos los anteriores Y si se va a robar la vista de alguien por ejemplo Pues debería estar B1 o sea en este caso por ejemplo si se si vio que se movió
(51:17) dos veces este el hilo c pues se roba la vista de quién del update de este no entonces este scan debe tener a este O sea sí o sí no y no lo tiene Y ya entonces tienen que ver vale si si es correcto o sea por ejemplo y aquí les digo muestren una linealización no este ya me tienen que decir este no es correcto porque no es posible que B1 no no sé ya al siguiente me dicen esto es correcto y de hecho una linealización pues la podemos poner como que primero sucedió B1 luego sucedió b2 luego B3 luego b4 luego el scan y luego este otro
(51:57) no sé este algo así Vale entonces este Ese es el primer ejercicio bueno el segundo no el tercero es este ah miren Aquí les pongo no eh plantear una ejecución del snapshot weight free para nilos nada más en donde muestres un ejemplo de por qué esta implementación es bound Dead weight free o sea porque realmente acaba en un on cuadrada no cuadrática entonces pues ponen ustedes es una implementación o bueno la o la describen No tampoco hace falta este dibujarla si son buenos describiendo pues mejor no este bueno o
(52:37) está bien no como sea Ah sí para la inación es válido solo poner los tachas Sí está bien Camilo sí Y entonces acá pues ustedes escriben no es que por ejemplo si tenemos un scan que aquí se hace otro update otro update otro update no O sea la describen vale este y Y acá es escribir una ejecución del snapshot obstruction free en donde el método scan puede ser que nunca acabe no considera n igual a 3 hilos este entonces acá pues tenemos el hilo no sé A B y C y entonces este pues uno dice no pues aquí tenemos un scan que nunca va a acabar porque
(53:23) resulta que B y C siempre están haciendo updat no hacen aquí update update o sea describirla Vale y decir bueno Y esto pasa en el infinito No si se repite esto infinitas veces el scan no acaba eh Y ya entonces se apoyan igual del código no Y por qué no va a acabar Bueno pues porque en la línea este 25 se toma el el el collect y en la línea 27 el otro collect y entonces siempre son distintas y te la pasas dando vueltas en el bucle no este entonces así escribir eso y finalmente Esta es como que curiosita es si en la implementación del snapshot
(54:05) obstruction free modificamos el scan de esta forma Aquí les pongo no O sea digamos que no no haces un Double collect solamente haces un collect este solamente haces un collect entonces pues haces el collect te vale no las actualizaciones de los demás y acabas nada más devuelves la copia Vale entonces La idea es que que que ustedes analicen no A ver si no se hace un Double collect no O sea si no hay un una copy y una New copy este podría suceder la siguiente implementación no de la figura 5 o sea suponiendo igual que el arreglo está
(54:52) inicialmente todos así en inicializados no O sea no hay nada es eh Y también contestar si la implementación seguiría siendo linealiza no entonces así ver no O sea Sería posible que que teniendo el update no este update este otro y este otro este B solamente vea lo que hizo B sin lo que hizo c no a pesar de que sucedieron así en el tiempo o sea realmente que el update de B Pues sigue no O sea update c precede al update de B entonces este Bueno del valor c los valores c entonces tienen que ver o sea analizar no que
(55:37) realmente si no hacemos el Double collect Pues sí pasan cosas extrañas en el snapshot obstruction free vale o sea el primerito la primera implementación de snapchats que vimos Vale entonces esa es la tarea si se dan cuenta este el ejercicio 4 y el tres son como pues hay que nada más revisar no los códigos y ver que realmente se cumple lo que yo les comenté en clase o sea como que ustedes así sigan el código y el el uno pues es que revisen el video y el dos y el último el cinco Sí están como que como haí analizar un poquito no
(56:18) este Pero bueno o sea siento que está bien cómo lo ven entonces entregaría el siguiente o sea del de este martes a al siguiente así este tienen las ayudantías no vale Ahorita se la subo e entonces todo bien no hay dudas por el momento Ajá Cualquier cosa me preguntan vale Este Entonces hasta aquí le dejamos ya el miércoles empezamos con siguiente tema el tema 5 y les mando igual el miércoles Yo creo para que decidamos cuándo va a ha ser el examen no A ver qué día les queda mejor este va Vale entonces nos vemos Bonito
(57:16) inicio de semana Bye recording al ah
