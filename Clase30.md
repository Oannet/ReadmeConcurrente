2024 09 11 10 01 10 - YouTube
https://www.youtube.com/watch?v=FI0x0EAmMZk

Transcript:
(00:29) al al al Hola buenos días
(02:20) la clase anterior emp vios el campo volátil este Y por qué lo vimos Bueno pues porque en el modelo de memoria de Java tenemos eh Bueno es así pues más complejo no hay este o sea lo podremos revisar podría ser todo un curso del modelo de memoria de Java no pero nosotros nos quedamos con que eh Java reordena Eh puede reordenar líneas de código y este y ese es un problema no sobre todo en los algoritmos concurrentes en donde ocupamos a veces necesitamos que se ejecuten en ese orden no forzosamente Ese es el primer problema
(03:07) reordenamiento y el segundo es de visibilidad que como este cada hilo tiene su propio stack Ah bueno Sí cada tiene su propio stack no entonces de que para que llegue del stack a la Hip no y y de la Hip a la stack pues es tiempo Vale entonces volátil fuerza Bueno fuerza sí fuerza a que la actualización llegue inmediatamente haciendo con esta como haciendo flush así le dicen no O sea que llegue la actualización este inmediatamente y además este también que llegue de acá al que quiera leer de forma inmediata o sea
(03:56) ahora sí que paren todo y que no se haga nada hasta que no se act esa variable pero como ya vimos Bueno o sea como les había comentado este pues en realidad lo que está abajo de esto O sea del modelo de memoria abstracto pues son este pues un modelo de memoria más complejo no que pues es el de nuestra arquitectura de nuestra combo entonces pues aquí se ve no sea como que entre más lejos del Core de los registros de este del hilo propio pues más se va a tardar en llegar la información hasta por ejemplo la ram no hasta la hasta la
(04:35) Hip e Okay entonces es costoso pedir que las cosas se hagan de forma o sea utilizar campos volátiles es costoso pero bueno eh todo esto voy voy a acabar de explicarles ya lo de final no vien la tarea pero yo se los explico mañana porque tiene bueno siento que como que est parte tiene mucho que ver con la parte práctica H entonces en la en la clase de mañana repasamos volátil vemos los ejemplos e de forma así como más lenta no estos que les compartí al final de los códigos este los platicamos más más este espacio y y este terminamos de
(05:22) ver final y a qué se refiere un modelo de memoria fuerte o débil y este y pues ya o sea bueno en realidad es lo que nos falta No no es mucho de este tema pero digo que me parece mejor que entre mañana en la parte práctica porque pues tiene que ver o sea Bueno mañana temprano le subo su práctica y pues justo no se llama candados clásicos y el modelo de mell por qué porque simplemente es como de Pues cómo usamos volátil no Y también este pues contarles no porque no habíamos usado volátil hasta este momento no este en la
(05:58) práctica pero buenoa mañana hacemos como este nos dedicamos a ver volátil vale en la parte de práctica entonces Bueno ya de una vez Empiezo con este siguiente tema que se llama fundamentos de memoria compartida no que es Just como se llama el capítulo del libro el capítulo 4 creo entonces Bueno hasta Elo que hemos visto o sea e este este capítulo anterior nos dedicamos a ver objetos y por ejemplo un objeto Pues podría ser una cola no que cumple tiene su descripción no O sea que tiene sus métodos en deq y pues es fí Y
(06:47) tenemos implementaciones eh concurrentes de la cola una de ellas por ejemplo pues es la que ustedes hicieron para su práctica dos que pues la primera asinada de consistencia no O sea y y ahí se ve claramente no O sea qué es un algoritmo concurrente pues es el conjunto de de de algoritmos secuenciales o de programas secuenciales Por qué Porque una implementación secuencial de una cola pues Y como vieron no es la que les entregué pues nada más es un hilo ejecutando cosas o sea el hilo mail Okay entonces hacen q
(07:25) deq no y ya pero una cola concurrente simplemente es vamos a poner a varios hilos ejecutar el mismo el mismo programa o sea cada uno va a tener una copia de este programa y lo va a estar ejecutando y ahora sí no suceden cosas y justo el cómputo concurrente se refiere a analizar el entrelazado de programas secuenciales no entonces o se ahí tienen su primera implementación concurrente así en la práctica noer este de un objeto que en este caso pues es una una cola no entonces bueno Eh ya después para analizar estas implementaciones
(08:04) pues decimos no que es correcto si es linealiza a una cola no O sea la especificación secuencial o sea el conjunto de este ejecuciones válidas para esa Cola y este bueno Y eso implica no que existe una historia secuencial eh válida para una cola eso es lo que implica [Música] entonces bueno estos objetos claramente no Residen en la memoria compartida y los hilos pueden en la cola en nuestro caso pues estaban los hilos Head y Tail y además cada nodo eh el el next no del último nodo que se agregaba Pues también lo podíamos Ver
(08:55) todos y todos queríamos agregarnos después no entonces ahí estamos compartiendo no en este caso pues variables pero pues es el objeto e entonces eh Y aterrizando esto no las arquitecturas de Hardware e no suelen garantizar Line realizaba cierto software como la la la máquina virtual de Java no este y Bueno aquí me refiero o sea las arquitecturas de hardware no o cierto software Qué tienen en común ambos Pues que ambos tienen modelos de memoria Entonces cuando digo que no no suelen garantizar la alabil es que estos
(09:46) modelos de memoria por sí solos no la garantizan no O sea como permiten que se reenen las cosas por ejemplo con con en Java no O sea que se reorden que no pues la desabilidad no se garantiza hay que Us ar otros mecanismos como volátil no como la paquetería atomic este pereno bueno eso vamos a ver ahorita entonces quiere decir que estas estos modelos de memoria sobre sobre estos sobre este hardware no este software no proveen memoria de lectura escritura linealiza no Entonces por ejemplo si en Java no utilizamos volátil
(10:24) los hilos en ciertos Campos no pueden ver este bu los hilos no podrán ver no las modificaciones de ciertas variables compartidas entonces Ah bueno este es el ejemplo no recordando aquí en peterson pues si cambias esto no si no no vemos que unilo actualizó la bandera Pues aquí van a pasar cosas pues no malas no O sea pu no se va a cumplir exclusión mutua Entonces nosotros ya tenemos ahora sí que nuestro bonche no nuestra lista de cosas de de herramientas para entrarnos al mundo concurrente nosotros ya sabemos que existen candados no es llámese
(11:05) filter o peterson no que son candados eh Pues con relevancia más bien teórica más que pues se usen en la práctica Pero bueno o sea son sabemos cómo se hacen no sabemos cómo se puede hacer un candado muy simple para dos ilos o Cómo podemos construir a partir de este candado una generalización para nilos ya sabemos pero bueno se sabemos que en Java pues existe toda la libr ía de los logs los ls reentrantes los semáforos este así sabemos que hay muchas cosas para sincronizar de tipo candado y no se diga sincronize No este lo ponemos al método
(11:42) y ya con eso se convierte en un candado gigante todo y además ya tenemos ahora este esta otra herramienta que es bueno tienes problemas para que bueno para con que una ilidad no o o el ordenamiento Pues ponle volátil no entonces ya tenemos ahí dos herramientas candados y este campus volátil entonces pues está bien No hasta ahorita estamos bien ya con esto decimos que sabemos concurrente y o sea bueno si les dicen a ustedes no pues este ha una implementación no de una una cola una pila concurrente y ustedes van a decir
(12:26) Ay si no hay problema agarro la secuencial le pongo un candado y ahora sí no ya con eso ya ya funciona así pero bueno Siempre vamos a crear implementaciones bloqueantes no O sea si alguien se queda dormido con el cado pues este ya nos atrasó a todos no y pues no sé qué tal que no siempre ocupamos no no siempre queremos tener implementaciones bloqueantes y bueno la otra es si no queremos O sea no no usamos candados no este por ejemplo en peterson no que queríamos hacer un candado ni modo que haos un para hacer
(13:00) un candado no O sea entonces en peterson pues usamos volátil eh Y pues sí nos ayuda no e pero pues es una forma de sincronización débil Por qué Porque solo son registros eh que te permiten leer y o escribir no e de forma linealiza pero no hay más O sea y ahorita vamos a ver este qué tipos de registros hay entonces bueno eh la siguiente herramienta que vamos a ver además de candados y volátil es Esta es pues toda la paquetería atómica Eh bueno seo empezar vale porque en realidad es el siguiente tema donde ya vemos el la
(13:39) jerarquía de todas estas Este primitivas eh pero este vamos a ver en este en este tema eh los registros atómicos Vale y ya de ahí después van a vamos a ver este en atomicidad tenemos eh en este capítulo registros atómicos Ah bueno aquí lo ten escrito y pero también hay otros no también existen las primitivas atómicas que pues ahora sí que son todas las que engloban este ya la paquetería atómica atomic reference atomic mar reference este en la práctica TR vamos a ver un ejemplo vale Ya en la 4 horas Sí vamos así a meternos de lleno a ver
(14:32) porque vamos a ver este candados pues que sí realmente tienen un desempeño en la práctica y que se usan en la práctica este entonces ocupan esta esta paquetería de atomica pero bueno entonces ese es el objetivo de de este de este capítulo introducirnos a los a los este registros Entonces vamos a ver tipos de registros el registro atómico el regular y el seguro eh que son tipos y vamos a ver construcciones O sea qué tanto se puede hacer con solo registros y Bueno de hecho como que bueno siento que lo que lo más poderoso
(15:12) o sea lo más interesante que se puede hacer con solo registros son los snapshots atómicos Vale entonces vamos a ver dos implementaciones una que tiene esta condición de Progreso que ya la habamos visto pero bueno vamos a a ver un ejemplo por fin no y este weight free también otra otra implementación wif entonces este bueno como computos no computas pues siempre nos preguntamos eh qué S se puede resolver Qué es más poderoso que no sé o sea Qué máquina es más poderosa no eh Y también la pregunta no Ah s la pregunta base no de la
(15:54) computación podemos resolver un problema a con una máquina m o sea sipre la pregunta no entonces bueno esta este Quiz que les puse Aquí este pues dice Cuál es la máquina más poderosa no eh Y me refiero a si nos si pensamos en términos de computabilidad o sea cuál es la máquina más poderosa la que si no se puede resolver un problema con esa eh Pues decimos que no tiene solución No o sea se acuerdan de sus clases de complejidad este Cuál cuál consideran ustedes que es la máquina más poderosa Bueno también les ayuda sieron ya
(16:30) autómatas Ajá sí Exacto s Camilo la máquina de touring no es la más poderosa hay problemas que pueden ser resueltos con autómatas finitos otros este que no con autómatas finitos pero s con autómatas este de pila no y hay otras que no pueden ser resueltos con ninguno de estos dos pero sí con máquinas de turing y decimos no que si algo no puede ser resuelto con una máquina de turing Entonces es indecidible no O sea no tiene solución este bueno no puede ser resuelto la máquina no va a parar o algo así entonces en el mundo
(17:10) secuencial sí Víctor en el mundo secuencial decimos que la máquina más poderosa es la máquina de touring no y y así no se es tal cual no si el problema no puede ser resuelto con una máquina de touring Entonces no tiene solución y la más débil es el mata finito Pues bueno les Les comento esto porque en el mundo concurrente y y este haciendo un un este una precisión no en el mundo concurrente Ándale s la máquina de touring no determinista Ajá sí sí porque incluso Hay cosas no que como los problemas estos de los números primos hay problemas no
(17:55) que que solamente tienen solución con no deterministas muy interesante Pero bueno este entonces bueno Les comento esto no de complejidad del mundo secuencial porque en el mundo concurrente y específicamente de memoria compartida Y por qué Porque en el mundo concurrente También tenemos el mundo concurrente de paso de mensajes vale o sea hay otros y est est es un montón No que se toma en distribuido en en cómputo distribuido o se es como distinta es distinto el análisis Aunque en realidad se ha estudiado que son
(18:36) equivalentes Pero bueno ahorita estamos en este mundo vale de memoria compartida todo el curso Entonces en este mundo concurrente decimos que si algo no puede ser resuelto con con un objeto con un número de consenso infinito Entonces no se puede resolver eh Y o sea ya vieron que es análogo no O sea Tenemos uno objeto en en este mundo del mundo secuencial tenemos máquinas no y en el mundo concurrente tenemos objetos y hay objetos más débiles y más poderosos los más débiles este son los que tienen un número de consenso uno los registros
(19:17) atómicos y no se diga los registros seguros y los regulares que pues también sí tienen número de consenso uno pero bueno son más este son más débiles todavía y de ahí va aumentando y la jerarquía se construye de acuerdo al número de consenso HM Qué es el número de consenso pues miren este nada más Les comento ahorita porque la vamos a ver el siguiente no pero este el siguiente tema vamos a ver ya Cómo tal el número de consenso pero este ahorita lo les les este comento esto porque pues vamos a ver así a los menos
(19:53) poderosos no a los a los registros atómicos Pero bueno este número de consenso lo único que no nos dice Es que para Cuántos hilos se puede resolver el problema del consenso y el consenso está tal cual así no sé unas elecciones no este tienes a los candidatos Y entonces este La pregunta es cuántos siglos se pueden poner de acuerdo para elegir a un candidato vale o sea es es como el problema del consenso tal cual Entonces por ejemplo los registros atómicos solo pueden poner de acuerdo a uno a una persona no a un hilo
(20:30) esta segunda la segunda línea no estas las kwi las sts y estas otras estos otros objetos pueden poner de acuerdo a dos a dos hilos este y este a un número infinito de hilos puede hacer unas selecciones no para para cualquier número deos entonces bueno los más chafitas que pueden resolver menos cosas son los registros atómicos máquina de turing no este bueno la jerarquía de las máquinas no o sea los autómatas pues resuelven cosas pero poquitas no muchas no no les pidas tanto yasí los registros También acá Este Entonces Bueno si a los más
(21:13) poderosos Los vemos a ver ya en el siguiente capítulo vale Pero bueno mientras vamos a ver a los menos a los registros y también coinciden con que son los más simples Por qué do si una cola y una pila pueden ser compartidos entre varios hilos Ajá sí eso es lo que vamos a resolver el siguiente Pero sí muy buena pregunta Eduard sí O sea no no este o sea sí O sea me falta para llegar a eso para explicarles eso pero bueno o sea nada más como como nota no e y bueno Java tiene implementados aquí el comper set el getan set también está ahí en Java la
(21:51) paquetería y así vale Pero bueno ya después Sí porque si no no está O sea no está tan directo Eh entonces Bueno e los veremos primero porque pues sí son los más simples y porque como que nos ayudan a entender un poco este concepto de atomicidad si se acuerdan la laliz habilidad es una propiedad Bueno creo sí les había comentado pero este no no tal cual Pero bueno la analizaba es una propiedad atómica y por qu si se acuerdan vimos que tenía puntos ización los puntos en donde decíamos que aquí sucede a eso se refiere la atomicidad
(22:34) Pero bueno aquí ya la vamos a ver como que siento que con más más más ejemplificada pero bueno entonces primero no Qué permite hacer un un registro así como vimos de las colas de los contadores no O sea un registro Pues solamente escribe valores no O sea guarda valores y lee valores dos cosas no se entonces la interfaz de un registro Pues se vería así no este Pues lee algún tipo o sea devuelve algún tipo y escribe algún tipo no entonces bueno esos registros se dividen Según uno los valores que almacenan dos los números de Hilos de
(23:18) lectura y escritura que permiten y tres el grado de consistencia que proven entonces por ejemplo analizando esta este puede haber por ejemplo No buanos puede haber aquí enteros puede haber este multivaluados no no sé como Pues no sé que sea un String no que tenga varios valores pero otro tipo también o sea puede ser de cualquier registro este este es el valores no valores que almacena luego el número de Hilos de lectura y escritura que permite sería este yos de lectura escritura tenemos al multier multier no este la M es de multi vale
(24:20) multi Entonces tenemos varios lectores varios escritores no en esta otra tenemos varios lectores un solo escritor y en esta tenemos un solo escritor un solo lector o sea lo que permite no este por ejemplo se acuerdan no que tenemos a a por ejemplo a a esto no ejemplo ejemplo tenemos a a peterson por ejemplo no y peterson teníamos eh la variable de las banderas que era este un arreglo de dos entradas no Entonces en realidad cada hilo eh cada hilo no a o b eh es solo en su
(25:23) registro y le ambos Entonces por ejemplo la bandera flag de peterson sería una bandera de de dos registros un flag es son dos registros el single grer multi reader no puede ser leído por varios pero solo escrito por el hilo al que le corresponde y además como la bandera Pues solo es este pues ahora es true false no Además es boleana no dos registros e single writer multier boleana eh Y así no entonces Bueno lo siguiente es eh voy a escribirlo es la consistencia la consistencia de un registro puede ser segura Regular o
(26:21) atómica esta esta clasificación está hecho es así también tiene una relevancia teórica mu muy bonita y a lamport otra vez lamport este fue el primero que se le ocurrió esto de los registros atómicos Pero bueno coincide con que cuando nosotros usamos el campo volátil convertimos al registro en un registro atómico Vale entonces por ejemplo en peterson de hecho tenemos la banda además tenemos que es volátil no si se acuerdan o sea sin volátil no funciona peterson entonces además no esta esta flag pues son dos registros este de un solo escritor
(27:05) varios lectores boano y además atómicos Vale entonces así O sea tenemos este análisis entonces Bueno aquí también hay un análisis de de que hay un registro que es el más débil no y un un registro que es el más poderoso entonces eh Por ejemplo según la gráfica según esta gráfica eh Cuál consideran que es el registro más débil y cuál es el más poderoso vale por ejemplo podríamos tener una combinación no de un registro seguro juliano y que sea este single reader single writer No ese cuál sería cuál considerar no tenemos
(27:53) otro que que puede ser no sé atómico multivaluado y multier multiwriter no tenemos así entonces o sea por ejemplo a ustedes Cuáles les parecería no que es el débil el más débil cuál sería por ejemplo este bueno el más débil en este caso sería el el el rosita no Ah sí sí Exacto sí oa el safe el seguro jano eh single reader single writer no como que no te da muchas garantías o sea es así la consistencia más chafa porque bueno por qué O sea me tienen que creer no porque va va de aquí va de lo más este la menos a la más vale entonces la más chfa pues
(28:51) seguro es buano Pues sí O sea buano pues nada más es y este y solamente puede ser escrita y leída por un por un este solo hilo no Y tenemos el el morado no el morado a de ser el más poderoso es el más poderoso este son registros que son atómicos que son multivaluados y que son leídos por varios escritos por varios Vale entonces un registro secuencial pues simplemente se vería así no O sea eh Pues escribes no O sea lo que lees pues lo regresas y lo que escribes este lo escribes no en tu en tu variable en tu atributo como
(29:42) objeto entonces Bueno necesitamos definir Qué pasa para para permitir la concurrencia eh Y así no como nosotros vimos en la cola o sea tenemos nuestra cola secuencial pero bueno Qué pasa cuando cuando permites que se ejecuten varios programas a la vez no Entonces esto esto de qué pasa se refiere en realidad pues al grado de consistencia no en nuestra cola cuando permití que todo se ejecutara así pues el grado de consistencia era bajo no era nulo pues no tenía sucedían cosas muy extrañas pero le poníamos un un cado y pues ya
(30:22) tenemos una cola con consistencia linealiza entonces aquí en los registros tenemos una clasificación que son esto de seguro este seguro regular y atómico entonces e requeriremos que las implementaciones o sea todas las que hagamos ahorita pues sean weit free eh Y bueno Qué es weit free se acuerdan es que garantizamos no que cada llamada termina su ejecución en un número finito de pasos y muy importante cada no O sea todos todos terminan Vale entonces bueno no puede ser que sean bloque antes las este los esas implementaciones de
(31:12) registros Por qué Porque como les había comentado no O sea en realidad utilizamos registros volátil para construir candados no O sea para lograr exclusión mutua eh Por ejemplo peterson no Entonces cómo va a ser que utilicemos candados en los registros okay O sea como que cómo vamos a utilizar cados para implementar registros y usamos registros para implementar candados Vale entonces por eso como que este si no tiene sentido tiene que ser este no bloqueantes forzosamente vale Y este o sea no usar candados y además ser we
(31:50) free O sea que todos terminen en un número finito de paso de pasos e entonces la consistencia en los registros se va a definir en función de Cómo se relacionan estas llamadas de lectura y de escritura entonces e por ejemplo Cómo se relacionan las llamadas las las llamadas que son sucesivas como esta o también Cómo se relacionan las que se traslapan como esta que se traslap con esta y esta con esta no entonces Por ejemplo si sucede algo así pues que tendría que regresar la lectura ese va a ser como bueno así se define la
(32:39) consistencia entonces bueno el primer registro que vamos a ver los registros atómicos eh un registro atómico simplemente es una implementación linealiza de un registro Okay entonces por ejemplo no nosotros ya vimos que es la laliz habilidad entonces para que esta ejecución de aquí sea una implementación iniz Qué debe devolver este esta lectura no Entonces por ejemplo qué nos dice laiz habilidad aquí pues todos terminan O sea no hay no hay este implementaciones pendientes no aj dice Camilo 1 dos Exacto sí no este uno o dos no Por qué
(33:26) Porque podemos decir no que Este sucede le pongo en color que este sucede aquí y este sucede justo acá no podría ser y está acá podría ser no O podría ser que este no sucede que este sucede acá y este su si podría devolver uno o dos por qué Porque el método debe devolver siempre lo último escrito no dejenme desconecto de acá s en una implementación analizable de un registro pues intuitivamente tenemos estas dos reglas Simplemente si tenemos que una lectura se traslapa con una escritura pues puede regresar el valor escrito por el último
(34:32) anterior no a x o por o sea por el que se trasl entonces justamente no O sea por ejemplo aquí pues este pues podría regresar no el traslapa con este doces puede regresar lo último escrito O sea pues en realidad lo que tenía el registro inicialmente o regresa pues la operación con la que se traslap es la primera regla y la segunda es que si un no se traslapa con un no y este su vez lo antecede o sea el gr sucede antes no sea pensando que que tenemos por ejemplo acá no tenemos acá un re y y realmente no este sucede después que
(35:20) el gr no el gr lo antecede Entonces se debe regresar pues lo último escrito vale como que tenemos así dos reglas No si hay traslape de un read con un gr Y si no hay traslape de un read con un es lo que nos dice Entonces ya en el libro nos dicen no O sea tenemos estas reglas y todavía más este o estas dos reglas que les comenté de forma intuitiva están así escritas y lo vamos a ver así este porque se definen También en estos términos los registros regulares y los seguros que vamos a ver ahorita entonces bueno formalmente
(35:59) decimos que Eh bueno vamos a denotar a ri no como este la llamada que regresa el valor V no y que es el único valor escrito por una escritura doi Vale entonces Eh bueno puede ser no que que una historia contenga solamente una llamada de gr pero este aquí dej la Aquí sí O sea bueno creo que se refiere a que no lo había leído este bueno no la leí recientemente e entonces bueno a lo que se refiere es que vamos a a
(37:04) denotarlo ri este denota la llamada que regresa vi no entonces vi va a ser el valor escrito por alguna llamada gr no O sea como pues gr escribió el valor vibi entonces lo que nos dicen es que sí puede ser que una historia eh Ah bueno vamos a vamos a suponer no que solamente eh [Música] e lo que nos dice esto es que supongamos que solo eh bueno que w y es único V es lo que nos dice en esta línea o sea que solamente puede haber una escritura que escriba el valor vi
(38:10) vale Ya si o sea puede haber otra escritura no sé que escriba vj no y otra escritura que escriba no sé vz pero solamente hay una vale es lo que nos dicen o sea como es una suposición simplemente este para para estas definiciones vale es como una suposición nada entonces lo que nos dice es que pues sí vamos a suponer que solamente existe como una escritura que va a escribir v1 V Perdón vi Pero bueno puede haber varias lecturas que lean lo mismo no e entonces bueno Eso se refiere por ejemplo no que tengamos una
(38:54) implementación este en donde tenemos por ejemplo no tenemos V I no y de ahí tenemos r i r no Esto sí es posible lo que no es posible o sea lo que se refiere a esta línea es no es posible que tengamos este W vi O sea sí esto Esto no puede ser vale o sea como que solamente hay una escritura que escribe vi pero sí puede haber varias lecturas que regresen V no porque pues en este caso todas leerían lo mismo Entonces esto se refiere nada más esta primera línea vale Ajá el superíndice vi se refiere a que regresa un valor vi nada más O sea
(39:41) como que es y es único ese valor O sea que no puede ser escrito o sea por eso si algo escribe uno y otra cosa también escribe uno no es lo mismo No Ajá sí O sea por ejemplo no si algo escribe uno no O sea por ejemplo este como que los superíndice representa el el nombre no del valor que escribió entonces gr escribe uno por ejemplo no y no puede ser que exista otro que vuelva a escribir uno solamente los valores son únicos vale o sea si alguien escribió uno ya no puede ser que se repita O sea no puede haber dos vale a eso se refiere entonces bueno
(40:21) siguiendo esta anotación nos dicen que nunca es el caso que que se lea no que se lea eh un valor vi no que no se ha escrito es es lo que nos dicen vale en este primer como regla Nunca es el caso que aquí se aquí se representa no O sea que que tengamos un r que le uno si inicialmente el registro no está en uno no se ha escrito ese valor no a eso se refiere o sea este este sería el r r i no y este el W I vale No puede ser que suceda esto y también otra regla no que nos dice los registros atómicos es que nunca puede ser no que por que para alguna J
(41:22) eh se lea se escriba I luego se escriba j y el registro termina leyendo un valor viejo Vale entonces bueno eso se traduce a que no puede ser que una lectura devuelva un valor viejo eh Y bueno Esto significa No que ya se actu actualizo Vale entonces por ejemplo aquí tenemos no sea tenemos que se escribe uno luego se escribe dos y luego se lee Uno Vale o sea esto no puede pasar entonces lo que nos dicen Ah bueno así lo así lo definen formalmente vale Bueno más o menos dice dice cuando se hace un ya se puede volver a escribir
(42:27) uno o nunca más se puede volver a escribir un Ajá considera que nunca más nunca más solo existe los valores son únicos ya se escribió pues ya no se vuelve a escribir sí puede volver a ser leído no si no se si no se ha haber escrito pero no puedes volver este volver a ser escrito vale Ah pues nada más en la definición Ajá sí o sea es como este una definición formal vale pues matemáticas no eh para que para hacernos más simple las definiciones vale la formalidad y ya sí entonces Ah bueno est es y la tercera no es que
(43:15) este la tercera regla es que si si se le Y no y después el J quiere decir que que este que y se escribió antes que J vale ya es la es la última Y esta es si se lee eh un I no y luego un J entonces y sucedió antes que J es lo que nos dicen los registros atómicos Eh entonces por ejemplo no si se escribió uno no y después escribió dos este Ay perdón se escribió uno y después escribió dos Entonces se tuvo que haber leído primero uno y luego dos vale pero no puede pasar que se escriba
(44:23) uno se escriba dos y que por ejemplo este registro lea eh dos no y este lea uno pues no no porque este Eh Pues porque en este caso uno sucedió antes que dos Entonces no puede pasar que esto vale Este no puede pasar pero si se dan cuenta o sea como que siendo que este caso se puede hacer la precisión Porque si se dan cuenta estas dos No pues se traslapan y estas dos se traslapan entonces que te dice la generalizabilidad ordénalas como quieras Ajá sí pero obtén en realidad o sea lo que te dice la elizabad es además que
(45:04) todo tiene que tener un sentido o sea esta est tiene que suceder antes no entonces no sé si dices que este sucede después Este Entonces este también tendría que suceder después no pero no puedes hacerlo al revés no O sea como que este lea dos o sea en qué momento no porque este sucede en un punto No si sucede si este le do es porque sucedió antes y entonces tendría que leer dos forzosamente entonces lo que nos dice como que eso sí una especificación como de lais habilidad vale Pero bueno este les introduzco los
(45:46) eso no era con secuencia Ah lo de ordenar Como quisiera Ajá sí no no Bueno lo que nos decía la inabilidades es reordenar las operaciones que se traslapen no este entonces Pero además no s miiz habilidad que encuentra el punto atómico en donde sucedieron no es lo que nos dice Eh entonces por ejemplo en este caso la inabilidades como quieras y estas como quieras no pero sí respeta el orden de estas dos porque pues se preceden en el tiempo y lo que te dice la consa secuencial te dice este solo respeta el orden de estas dos no O sea esta podrí
(46:39) suceder incluso antes que esta no lo que te dice la conscia secuencial pero la inabilidades dos pero aquí se hace todavía la precisión no Ajá sí pero recuerda que las lecturas deben respetar el orden en en el que las cosas fueron escritas no es lo que nos dice toda ya es una precisión más no eh Entonces no puede ser que esta lea dos y esta lea uno o sea cómo va a ser no si este leyo dos es porque esta operación tuvo efecto antes que que esta otra no Entonces esta fuerza tendría que leer dos Entonces es lo que por eso nos dicen
(47:17) no que no puede pasar esto Esto no vale entonces un registro regular ahí nos vamos a bajar la consistencia este eh es un registro en donde solo las escrituras son atómicas pero las lecturas no y y Aquí vamos a ver se acuerdan la primera regla que vimos ahorita con los atómicos fue que eh que nunca sucede que leemos que leemos un valor no escrito no o sea esto se cumple Esto bueno sea esto sí se cumple no nunca podría pasar esto nunca podría pasar que que leyéramos un valor no que pues no ha sido escrito no puede
(48:07) ser este es el el primero luego su primera regla no la segunda regla no puede ser otra vez no que leamos un valor viejo no que lea un valor viejo no Entonces no puede ser que le yo uno si ya se escribió dos okay Y además no este no se cumple vale que si este si Bueno pero es esta Va a ser la diferencia en los atómicos sí no teníamos que se cumplía esta y se cumpla esta otra lo que va a cambiar es esta tercera regla lo que sí va a pasar es que suceda Esto entonces Este sí puede pasar que Eh sí puede
(49:16) pasar que r regrese uno aunque se escribió uno a dos no Esto sí se va a permitir en los registros regulares entonces no sé si se dan cuenta qué es lo que sucede en Java cuando por ejemplo tenemos nuestro programita no el de El de que les presenté no el último el de la bandera que teníamos a un hilo a un hilo lector no que pues él simplemente decía estaba en un ciclo While no decía eh voy a ver si la bandera cambia no y en cuanto la bandera cambie pues yo voy a imprimir no imprime eh cambió no cambió a true era como lo
(50:10) que hacía el hilo elector y luego teníamos lo que hacía el hilo escritor no eh Y hilo escritor nos decía este me voy a dormir tantito no slep eh No sé 100 nanosegundos algo y luego lo que hacía el hilo este déjen lo pongo un poquito más para arriba en otro color no eh Okay entonces lo que hacía el hilo lector era que se durmiera tantito y luego hacía que la bandera fuera verdadera no y ya está pero si se dan cuenta eh el hilo lector H nunca como que o sea cuando no le poníamos volátil O sea sí la simbola o sea acá no la declaración Ajá
(51:04) sí dice Camilo Cómo pasaría esto eso pasa en la realidad no O sea cómo puede ser que un hilo lea un valor más actualizado y en la siguiente lectura sea una un valor este viejo no O sea cómo va a ser pero bueno si si se dan cuenta sí pasa les digo no O sea esta cuando no le ponemos volátil a flat que si puede pasar no que y bueno eso vamos a hacer los experimentos pero el el hilo lector Perdón escritor cambia la bandera true yilo lector pues no se entera no pero sorpresa puede ser queo lector o sea siga pensando que que FL tiene un valor
(51:44) viejo que es falso pero si luego volvemos a pasar a un hilo lector no y y este que vuelve a ejecutar reer te va a decir este verdadero no entonces como que ahí pueden pasar cosas extrañas con eso por qué porque las O sea si se dan cuenta esta situación podría pasar porque este la actualización de algo es visible hasta después no O porque el sistema ya te reordenó las dos líneas no podría pasar algo así O sea sí pasa es es lo feo no si no usamos volátil no tenemos registros atómicos no con registros atómicos nos asegur uran estas cosas o
(52:27) sea estas tres reglas pero con registros regulares cuando no usamos atomic y de hecho todavía están peor los seguros pero cuando no usamos atomic suceden cosas bien extrañas el programa te reordena las líneas o no es visible para los otros entonces pasa o sea que no se cumple esta tercera no O sea s s este se cumple esto no que pues siempre les valores que ya fueron escritos no cómo va a ser que lees algo que no ha sido escrito no pero bueno Esos son los seguros este o no lo siguiente Pues es que este si siempre Leo la siguiente
(53:02) escritura No eso Si pero las lecturas pueden leer cosas extrañas no O sea si se traslapa si este tiene un traslape puede leer el valor viejo o el nuevo ya vion es como que lo que hacen los regulares o sea lo que la consistencia que tienen y si no usamos volátil pues tenemos registros regulares vale es como la realidad no entonces un registro es seguro y es así lo peor No cuando un read no se traslapa con un Wi entonces regresa el valor más reciente escrito no cuando pues así no O sea por ejemplo eh En este si tuviéramos
(53:47) no en este caso eh un re aquí eh Bueno y re no Entonces tenemos un gr escribe uno y un re este pues tendría que leer uno porque no se traslapa con nadie vale o sea simplemente regresa el valor más reciente pero sorpresa No si un re se traslapa con un gr Esa es la como el peligro no puede regresar cualquier valor en el rango de valores eso es lo que te o sea los seguros son los peores no los que no tienen consistencia absoluta o sea pasan cosas muy extrañas entonces por ejemplo no en un reit si puede pasar que si estas dos se
(54:29) traslapan pues regresa el valor viejo no e incluso podría pasar que este Eso se refiere miren aquí tengamos así dos dos este hilitos no a y b Entonces no sé que a escriba e voy a poner la anotación vale del libro Entonces tenemos gr un no sé dos yy tres no entonces lo que te dic los registros seguros es que si tenemos una lectura que se traslapa con una escritura por ejemplo no este estas dos se traslapan Entonces esta escritura va a regresar cualquier valor en el rango de valores o sea en el rango de en este caso estamos
(55:20) en los enteros Vale entonces podré regresar un uno no entonces puede regresar o sea este seguro no cumple con nada no o sea puede con ninguna de las otras tres reglas regresa un valor viejo no que ya ya fue actualizado regresa y también puede regresar este pues no sé o no sé regresa a cinco no un valor que ni siquiera ha sido escrito por qué Porque está en el rango de valores no Y ya por eso regresa regresa lo que quiere No este entonces por eso les digo en Java si no usamos volátil tenemos registros regulares ya
(56:02) los seguros son más como para las arquitecturas abajo en caché vale a cómo Escoge cuál regresar pues por ejemplo este yo siento que eh Como que una Cómo se vería esto en la práctica es en estos algoritmos de caché en donde tenemos este por ejemplo no sea en los algoritmos de cach regularmente tenemos no s la el cach l1 no y queremos que llegue al cach L2 entonces para que llegue lo que se utiliza un montón son como buffers que los buffers Pues en realidad se pueden ver como colas Entonces por ejemplo lo que hacen las l1
(56:52) Es que aquí escriben por ejemplo tienen un buer de ura de gr de gr no y tienen otro buffer de lecturas Entonces digamos que este se quiere comunicar con L2 no y el L2 también tiene un buffer no de lo que le ent yo siento que cuando l1 no tiene nada que leer regresa como el valor un valor que tiene ahí viejo o sea por ejemplo no sé o sea el buffer un quiere leer algo no quiere leer no este algo de L2 no entonces pensemos que el paquetito no en el buffer de los gides pues no pues no no sale No este es el buer de los de losers de las
(57:57) entonces pensemos que el paquetito que está aquí quiere llegar al paquetito de lecturas no pero no llega no entonces simplemente lo que hace l1 es te dice Ay mira toma Aquí está mi valor inicial no por ejemplo e qu dice no quiere leer algo de le2 el paquete no llega no llega entonces devuelve el valor inicial no y yo sorpresas algo que ni siquiera ha sido escrito no O sea como él quería leer algo que que escribió L2 pero pues no no encuentra nada entonces simplemente Lee Pues un valor no O sea regresa un valor
(58:47) para no tirar error Por ejemplo no pero o sea los registros seguros viven un montón más bien en arquitecturas de memoria este Pero bueno espero como que más o menos este les haya quedado esta este capítulo siento que es muy teórico vale Pero bueno no sé cómo cómo lo ven este o sea pero más o menos sí les quedó como claro este las reglas no de un registro regular Vale entonces bueno la siguiente clase repetimos todo vale es un poco confuso muy teórico justo sí sí este Bueno voy a tratar de no meterme tantas a las demostraciones es que en
(59:30) realidad no se ocupa en la práctica No o sea en la práctica práctica pues nada más les ocupo decir como que miren hay registros atómicos y hay registros regulares no y ya pero como siento que está bueno verlo un poquito no como a qué se refiere no O sea por qué volátil regresa a cosas Ajá sí sí y bueno en el libro están las demostraciones están las construcciones no pero bueno voy a tratar de de no meterme tanto porque pues yo sé que a veces algunos no Bueno o sea la verdad luego los pierdo no aquí los pierdo Pero
(1:00:03) bueno tenemos todas estos este tipo de en el libro vienen implementados todos estos hilos este Perdón todos estos registros así que pues los interesantes los que son muy bonitos y de hecho este mi tema de doctorado pues usé los los Snapchat atómicos este tienen una aplicación bonita pero pero sí como general todo lo demás es muy teórico Vale entonces Pero bueno vamos poco a poco la siguiente clase repasamos este porque pues como comput tologos es importante no saber pero bueno entonces nos vemos el Ah nos vemos
(1:00:41) mañana en la clase este de práctica vale les dejo su tarea temprano su práctica temprano Nos vemos bye recording stoped al
(1:02:25) al al al an
