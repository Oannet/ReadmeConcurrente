2024 09 12 20 03 04 - YouTube
https://www.youtube.com/watch?v=5RTrndc5YXo

Transcript:
(00:29) al al al Hola
(01:49) hola se escucha bien verdad sí gracias es que estaba esperando que se conectaran más pero si no luego no bueno esta vez creo que no no tengo tanta teoría o sea bueno tantos códigos nada más son cuatro y en realidad dos ya se los había enseñado Bueno muy brevemente [Música] e dejen compar [Música] está es que andaba revisando de una vez
(02:55) algunas prácticas dejen pongo a grabar recording in progress este entonces bueno Isabel me comentó que ya la tarea dos no la han calificado verdad ya empezó con algunos Pero entonces me parece que no este la práctica do es así no solo le he calificado un equipo pero hoy califico a otros más si es que tenía cositas que hacer pero sí ya le empiezo a calificar la dos la práctica dos ya la tarea dos les digo que en realidad creo que lleva como la mitad pero sí este entonces así ya le grabar sí e de Cuántas tareas y cuántas prácticas
(04:01) eran les había comentado que este al inicio no que eran más de seis puse Pero bueno por ejemplo el semestre anterior justo fueron seis tareas y siete prácticas este yo creo que van a ser mm es que depende cómo avancemos Pero bueno si al menos Son seis tareas estaba pensando en una más este en unas siete tareas y igual siete prácticas o seis pero sí O sea no pasa de eso no seis o siete Depende depende del tiempo porque Bueno luego se paro no este sí pero bueno o sea no có las ven no están tan complicadas no O sea o sea como que bueno si tienen las
(04:51) herramientas para resolverlas no porque bueno de momento no Sí o sea siento que son están basadas en la clase no O sea no es como que tengan que investigar muchísimo Ah sí Ah Qué materias llevan van en octavo cripto Ah cripto sí Qué ven este a D este todas esas rsa no rsa c clásicos [Música] Pues sí Bueno Ah Mira ya se metió alguien más pero bueno entonces hay que empezar este bueno como les había comentado sea este esta práctica se dan cuenta las prácticas trato de darlas ahí como un overview no O sea como un pequeño
(05:52) resumen de lo que va Entonces en realidad este resumen pues lo vimos No ya en la clase Pero bueno aquí siento que está como más eh digerible Leo no pero bueno entonces para qué es importante eh saber de los modelos de memoria pues miren cuando programamos de forma concurrente no es como o sea como ya vimos No no es una situación trivial o sea tenemos que considerar hay varias cosas entonces una de las cosas muy importantes es el modelo de memoria este O sea qué nos garantiza no e por ejemplo como esos programas que
(06:32) vamos a ver no cómo va a ser que yo estoy contando con que mi programa se lo diseñé con cierta corrección no O sea puse puse las instrucciones de esta forma para que se cumpla exclusión mutua no O puse o sea como este sí O sea como que para que de la teoría llegue a la práctica No o sea para eso nos sirve el modelo memoria para saber qué va a ser el modelo O sea qué va a ser eh Java no por ejemplo en este caso con nuestras escrituras con nuestras lecturas Entonces los modelos de memoria están presentes en todos lados o sea como les
(07:07) había comentado es es software sobre puede ser sobre Hardware este sobre Hardware o también puede ser sobre otro software sobre Hardware este pues ahí too un análisis no quien se dedica a fabricar este arquitecturas no este ciertas bueno ciertas máquinas este Pero bueno vienen en el libro vienen ahí mencionadas como algunas pero no vienen a detalle no es como de otro les digo como que podría ser toda una clase no modelo de memoria de no sé del arquitectura de Intel 9 no O sea bueno no sé pero bueno es es muy cosas muy
(07:50) especializadas o sea están sobre Hardware pero también están sobre software este Como por ejemplo esta Java o c más que hay un montón de artículos investigación sobre estos dos e entonces e informalmente no como les había comentado un modelo de memoria especifica cómo las acciones de memoria van a tomar lugar entonces por qué nos importa Porque es cómo se Ejecutan para nosotros como programadores entonces e en un programa cuando pues o sea de forma secuencial si ejecutamos Java nada más utilizando el hilo Main no O sea no
(08:30) ponemos a varios hilos a correr Pues sí O sea en realidad no nos importa mucho las lecturas y escrituras porque solamente es un solo hilo No de hecho incluso lo puede hacer en su propia en su propia stack no O sea no no hay como que tenga que preocuparse no por por interval por este porque se entrelacen con otras ejecuciones bueno Por qué por qué es trivial porque Bueno aquí dice no ya que siempre se lee lo último escrito Pues sí no pero cuando tenemos un programa multihilo el modelo de memoria ahora sí no se
(09:01) aplica es complejo porque una lectura de un hilo puede no ver puede ver o no escrituras de otros no es como que haía grandes rasgos eh qué es lo que hace un modelo de memoria no nos dice como las escrituras van a ver las lecturas y ya así como si les preguntan eh pueden así decirme simplemente e entonces em para un lenguaje no esta esta frase La saqué de de este artículo que es este digamos que es el artículo que motivó el modelo de memoria para Java 5 imagínense No qué importante entonces bueno para un lenguaje de programación
(09:42) como Java el modelo de memoria determina como les había comentado las transformaciones que el compilador puede aplicar no al producir el BC este las transformaciones que la máquina virtual va a aplicar sobre el código al producir el código nativo no y finalmente las optimizaciones que el Hardware puede realizar en el código nativo y ya pues Esta última es el Hardware de cada quien no O sea no sé pues el que tenga el Intel el que tenga amd el que tenga no eh entonces aquí se ve no el modelo de memoria de Java Pues
(10:16) en realidad engloba este para el bcode y para el código nativo pero pues ya en realidad las optimizaciones No que ya tu Hardware ag haga pues ya es de cada quien no O sea Es dependiendo tu computadora eh Sí por eso no todas a pesar de que todos tenemos Java pues no no en todas se ejecuta en el mismo tiempo no Entonces les puse esta esta en Safari miren este por ejemplo no doua es uno de los que escribió Ah no no Bueno pero también es muy importante Este es un investigador que que se dedica a los modelos de memoria
(11:00) y precisamente al modelo de memoria de Java no también tiene C también tiene para semas más pero por ejemplo aquí te explica no sea hasta como parece como documentación como escrita más bonita Entonces por ejemplo aquí dice no este eh Estas son las reglas no para las para para que se renen ciertas instrucciones y por ejemplo si utilizas eh volátil o monitores luego vamos a ver monitores vale Pero bueno si utilizas este volátil una escritura normal Este sí se puede reordenar con otra reescritura normal no eh Por ejemplo no
(11:43) si no usas volátil No pero si usas volátil una escritura volátil este por ejemplo no se puede reordenar con otra escritura volátil no O sea aquí te dicen no se reordene una escritura volátil no se puede reordenar Perdón una lectura no volátil no se puede ordenar con una escritura volátil no dice entonces aquí están las reglas no O sea si ponemos si no le ponemos volátil sí te permite que una lectura se reordene con otra lectura o que una escritura se reordene con otra o sea el compilador puede hacer lo que quiera no este como les digo en realidad
(12:16) H este no siempre eh es que el compilador a fuerzas vaya a modificar tus líneas no Pero puede por ejemplo en peterson Ah me llama LL la atención Este bueno ahorita lo vemos no pero lo implemente ahí el código que tenemos de libro lo implemente acá y si no usa si no se usa volátil No pasa nada o sea se sigue cumpliendo exclusión mutua pues quiere decir que el compilador no no vio como bien modificar no las líneas este o sea bueno no me cambió no flag antes que victim porque si sí pues entonces no se cumpliría O sea no es como algo
(12:56) así que podamos nosotros estar seguros no sea para estar seguros de que el compilador lo va a ordenar pues ahora sí que nos Tendremos que dedicar a ver compiladores no pero este Pero puede pasar no Entonces en realidad no estás volátil también para asegurarte Noa no sabes si el compilador considere bien cambiar tus líneas no justo las que te preocupan Pero puede ser o sea este entonces como que por eso como ver ejemplos de volátil también es como hacerle ahí este hacerle un sum al compilador no entonces eh bueno y aquí te explica los campos
(13:33) finales Pero bueno es es así cosas que pues sient no que no como les digo sea no nos importan ahorita este nosotros nos vamos a quedar con que este nos vamos a quedar con que o sea si eso es todo lo que sucede con el compilador yaa los volátiles los barriers que también vamos a verlos Un poquito más adelante nosotros nos vamos a quedar con dos cosas no O sea qué nos hace el modelo de memoria nos provoca un problema de reordenamiento y un problema de visibilidad vale simplemente o sea como les digo no en realidad hay en este aquí
(14:13) tenemos como un un este un breve no e como resumen de lo que puede hacer el modelo de memoria por ejemplo Aquí también no O sea te cuenta como Cómo se pueden reordenar las cosas cuando tenemos dependencia de datos que puede pasar Eh las interacciones con las instrucciones atómicas también eh Pero bueno se les digo no es mucho rollo pero nosotros no no no vamos a ver eso pero bueno sea para comentarles no que en realidad el modelo de memoria pues está totalmente especificado así entonces Eh Pues solo nos afectan dos problemas no como
(14:51) programadores de Java O sea no como creadores de compiladores o así Eso es otra cosa entonces Bueno lo que hace el compilador pues es optimizar no O sea el ordenamiento surge porque el compilador optimiza entonces en peterson no O sea por ejemplo podría cambiar el orden de estas dos podría o podría ser que no no pero si no nos queremos arriesgar y a fuerzas nuestro programa se tien que ejecutar de esta forma pues le ponemos volátil y este y con la visibilidad pues simplemente es porque tenemos esta noción de objetos compartidos entonces
(15:29) como estos viven en la Hip no y en realidad los hilos realizan sus cosas en su propia memoria local Entonces en realidad tarda no en reflejarse una escritura eh Para que otros la puedan leer no en la Hip por ejemplo entonces para mitigar este tipo de problemas estos dos no ordenamiento y visibilidad pues usamos los campos volátil y final eh Bueno me parece que hay más Pero bueno vamos a quedarnos con volatil y final este ah y también eh objetos atómicos ahorita el último programa El de Bakery que les tengo utiliza ya atómicas
(16:11) am entonces bueno estos dos nos van a garantizar que una variable se actualice y se refleja enseguida Y que además se respete el orden de las instrucciones en sus programas Esas son las dos cosas no eh Entonces los ejemplos a ver los ejemplos este ah les había comentado de este no [Música] tenemos hao más grande entonces e Ah mir como les había comentado tenemos la bandera que es compartida Eh entonces qué podría pasar no bueno saben que también me di cuenta que cuando no no hacemos que que G se duerma no como que no pasa nada no pero
(17:15) buen por ejemplo cuando utilizamos volátil este Bueno déjen a poner aquí reer no para que se vea mejor Y esto es el hilo okay Entonces cuando utilizamos volátil el hilo writer cambia la bandera a true no O se está primero está en false la cambia true Y pues lo comunica no se lo imprime Y luego el hilo re se va a quedar atorado aquí en este While no O sea digamos que aquí adentro no de los corchetes mientras sea falso y hasta hasta que vea que que está en verdadero pues sale del Wild no Entonces ahora sí puede decir que la bandera está en
(18:11) este que la bandera está en verdadero pero por ejemplo en este caso nunca pasa ya vien o sea como que en realidad nuestro programa No termina quiere decir que el hilo rit sigue dando vueltas ahí no y y que entonces este problema es de visibilidad vale Por qué Porque este digamos que lo que pasa aquí es que mandamos a dormir al hilo no los 100 nanosegundos aquí en la línea 23 Entonces el H re quiere decir que él empezó desde antes a estar leyendo la bandera este todo el tiempo no en falso en falso en falso Entonces no se si o
(18:54) sea sigue leyendo la bandera en falso y este Y probablemente no la está leyendo de forma local porque pues o sea obviamente para los hosan Java no lo que te conviene pues es leer leer de forma local no lo que pasa aquí es que este la la actualización a true se refleja en la Hip No si está en la Hip pero como el hilo re sigue haciendo O sea desde un inicio estuvo leyendo no esta variable nunca le va a llegar el valor actualizado porque él está de forma local o sea está ocupado no no está esperando que le manden la nueva
(19:34) actualización pero cuando hacemos volátil forzamos a que la escritura en la Hip de r le llegue de forma enseguida a los a los que están leyendo no o sea los hos que están leyendo justo esa variable entonces forzamos a que r le llegue e entonces no sé si forzamos a que llegue Ahí está no pero por ejemplo es distinto si no utilizamos esta Este sí voy a ponerlo si no utilizamos est y miren aún así nuestra variable este está en la variable ya no es volátil no en
(20:38) este caso no es volátil pero si se dan cuenta el hilo reader sí revisa que se cambia el writer a true no Y esto esto este por ejemplo puede ser porque el Lilo Rider Eh bueno Y aquí este y por ejemplo no siendo que pasa esto O sea que realmente el reader o sea mandamos la primero no el read Y luego el Wi y aún así siempre lo ve no siempre siempre Y esto por qué es porque el reader digamos que el el hilo lector no está ocupado cuando la bandera de gght se cambia enseguida no o sea porque lo que hace G es cambiarla enseguida a este
(21:23) a true o sea bueno Más o menos ven no O sea digamos que aquí Pues estaba ocupado y llevaba un tiempo ocupado no cuánto pues 100 nanosegundos en lo que el right la cambió pero cuando no no ponemos esto como que se duerma el hilo ruida enseguida o sea quiere decir como que no está ocupado Entonces la actualización Pues sí la ve Pero si ya estaba haciendo algo y alguien le cambia no la va a ver o sea bueno como que aquí siento que se ve como muy curioso no esto de de utilizar volátil o no este Bueno entonces más o menos como
(21:58) que ven este problema de visibilidad como por qué lo hace seguido Cómo por Cómo que seguir Ah sí porque jala Ajá es que Bueno yo lo que veo es que el este digamos que si el writer no se duerme Bueno voy a ponerlo así mejor si bueno no se duerme los 1000 menos segundos Entonces el hilo
(23:09) reader está disponible para de forma local vale pero sí si el writer se duerme el L reader está 1000 nanosegundos leyendo eh su propia variable no O sea su variable de forma vale o sea como que eso es lo que pasa Este Entonces si el hilo gritter no se duerme en O sea si el hilo gritter Ah no se duerme los 100 segundos Entonces el hilo ruer quiere decir que pues está disponible no para leerlo de forma o sea como que la actualización le llega más
(24:13) fácil de forma local pero si dejas que el liter está dando vueltas y nanosegundos no no no se va a poner a a actualizar su valor de la Hip al al al forma local dice ah pero después de esos 100 segundos ya lo mostraría no estuviera en un for todo el programa Cómo que si subieran for Ah o sea por ejemplo no que que este de for de c a 100 por ejemplo aj se si como le dices al reader detente no ahí buenoa yo deía más que o sea dice que no lo lee durante nanosegundos No pero si todo el programa durara por ejemplo con un Ford que lo pusiéramos
(25:03) que dure unos no sé e más de 1000 nanosegundos ahí ya Llegaría un punto en el que en el programa Sí sí lo mostraría No aún con el hilo dormido A sí sí sí sí porque haces como que el hilo reer se detenga No sí pero en este caso digamos que como tienes al hilo reer ocupado no no tiene O sea pues sí no se da el tiempo de actualizar de la Hip a de de forma local o sea como que ese es el problema de o sea como que donde sucede este problema de visibilidad pero sí como dices suriel s Sí verdad s Ajá entonces Bueno aquí se ve no el
(25:46) problema de visibilidad Pero bueno Si usas los si se duerme no y está el rido ocupado pues no lo va a ver no entonces o sea aquí s es un problemita y este otro eh lo puse por un por el problema de reordenamiento Pero bueno es como lo que quería vernos es que les digo que como que no sabes bien qué es lo que te va a reordenar o no tu compilador no entonces estuve ahí jugando a ver en qué momento este y por ejemplo no O sea si si no le ponemos volátil estos dos hilos el hilo re hace pues ha no que a igual a 0 luego le suma
(26:30) uno a b luego hace que B sea igual a 0 porque lo hace igual a a y luego le suma un a a no Entonces digamos que aquí el resultado sería cer0 y este a le suma un no y el aquí el hilo right lo que hace es que te Iguala no a con b b con a o sea los pone igualitos los dos y luego lo aumenta uno a cada uno no Entonces si no le ponemos el volátil quiere decir que este Ajá quiere decir que que la bandera no eh que se cambia a a a verdadero o sea porque inicialmente está en falso no gr lo cambia a verdadero en la línea 30
(27:15) entonces quiere decir que este mientras re va a estar haciendo todo esto no todo el tiempo va a estar haciendo que pues este cero sumándole a B1 no dejándole B = a y luego a + 1 Entonces es lo que va a estar haciendo Entonces por ejemplo en este caso sin volátil quiere decir que todo el tiempo se está haciendo lo que está aquí no o sea porque todo el tiempo es falso quiere decir que todo el tiempo está no iterando de la línea 16 a la 19 y este y lo que hace gr nada más es eh este Ah bueno y lo que Se imprime al
(27:57) final el Main es lo imprimí después de 15 nanosegundos no para ver o sea En qué en qué está el valor no de que está modificando todo el tiempo el re porque el gr pues solo lo hace una vez el gr igual a a con b b con a y simplemente a los dos le suma uno no así que también digamos que al final esto quedaría en uno no O sea el valor si a y b son inicial cero queda a y p igual a [Música] un o sea entonces este si o sea como que solo se hace lo de o sea lo de gr y aquí este a todo el tiempo se está reseteando no acer B a 1
(28:54) este luego B aer no O sea está aquí b y a son cero es con volátil Ajá o sea este caso es sin volátil no y este Ah bueno Y este caso es interesante eh A este caso es inv volátil digamos que lo que sucede no es que al final de Great pues deberían quedar los dos igual a un no a ig a un y en este caso debería quedar B igual Bueno voy a escribir igual a cer y a igual a n o sea todo el tiempo se está reseteando a y b y siempre Al final de este pues deberían quedar en cer a uno no hasta que después de 100 de 1000 nanosegundos se hace que sean los dos
(29:55) igual a un no pero bueno o sea como imprimo este en después de 1500 Debería ser que este los dos quedan en uno no porque eso es lo que se hace después entonces en este caso si no ponemos en volátil solo se escribe lo de gr no eh o sea como que queda esto pero por ejemplo si le ponemos volátil solamente a a la bandera no por ejemplo Qué es qué es lo que pasa no eh la la Bandera ahora o sea ahora sí no quiere decir que ahora sí termina de ejecutar de la línea 15 a la 19 porque qui decir que ahora sí este se tragó
(31:11) Ah sí se tragó Ya apagué mi cámara me escuchan mejor Bueno ya se escucha hola hola sí sí sí tenía conexión inestable Ajá por ejemplo aquí No este lo que sucede es que ya por fin red termina de ejecutar la bandera no y este o sea bueno termina de ejecutar este ciclo porque por fin cuando le ponemos este a la bandera este volatil quiere decir que r ya puede salir del ciclo y va a poder imprimir no este deen le pongo aquí no este es el reader el gritter y pues aquí está el lome Ah para que lo veamos mejor Okay entonces quiere decir que
(32:16) este e miren que que B estaba en un un y a estaba en uno Ajá sí sí sí no en este caso b b b y a es en la línea 33 ambos terminan estando en un no Entonces cuando el este la bandera no deja de ser este eh falso no digamos que en este punto e sí las es eh verdadero Bueno voy a ponerle true entonces termina de ejecutar el ciclo y del writer no teníamos que a ig a 1 y b = 1 No ya vieron entonces
(33:27) este consideremos no que todavía hizo todavía un ciclo más no O sea entró todavía en verdadero y ya no vuelve a entrar no Entonces qué es lo que hace al terminar aquí quiere decir que que este que B es igual a a no O sea que bueno Déjenme lo pongo este aquí Vale entonces si FL es true entonces termina ejecutar el ciclo del grit y y termina con a = 1 y b = 1 vale o sea termina digamos que ejecutar la línea 34 entonces entra aquí y este Ay no y supongamos no que que lo termina más o menos eh parejo no Entonces qué es
(34:17) lo que hace a pues simplemente termina de bueno digamos que la línea 19 este ve ya en este caso no después del writer son este a igual a p = 1 no porque hacemos que B sea igual a a y pues ambos son igual a 1 y aquí otra vez no después del gr entonces a es igual a 2 y b es igual a 2 no Ah perdón a un no porque solo se aumentó solo se aumentó a Ajá Entonces qué quiere decir que ni siquiera o sea cuando no usamos volátil ni siquiera se cuenta el orden de a y de B No pero lo está haciendo raro no O bueno
(35:21) es que o sea por lo que entiendo primero hace lo del y termina en a y b con uno no pero entonces después sería lo de lo del re Pero entonces a a lo vuelve cer0 entonces llevamos a0 B 1 a b le un a 1 entonces va a0 b2 luego hace B = a que entonces era ahí es cero ah no sí ya ya ya ya es que me confundí yo perdón sí sí sí no es que está bien confuso no pero es que bueno eh o sea bueno sea sí entiendo no que dices no pues es que si hace a = a 0 no pero recordemos que el read y el r en realidad se están ejecutando de forma
(36:04) concurrente no Y si el hilo re eh o sea digamos que la última vez que entró al ciclo en realidad quiere decir que ya ya ya tenía tiempo no O sea no este Ajá sí ya tenía tiempo como ejecutando no O sea probablemente no estaba en la línea 17 sino no sé en la 19 en la 18 no por ejemplo entonces por eso es que cambia Ajá pero es que entonces en qué momento se hace a = a 2 porque como o sea hace a = 0 Ajá luego al final hace a + 1 o sea nada más le suma uno pero por qué termina en dos es que es ahí donde no no entiendo
(36:41) Ah okay okay O sea bueno es porque en la línea 34 o sea por ejemplo esto lo que sabemos es que eh en la línea 32 no hace flag igual a true entonces quiere decir que la línea se Pues si el ruid estaba todavía dando vueltas no este quiere decir que pues es la última vez que va a entrar no entonces eh Como que la línea 33 y la 34 se hacen un poco como concurrentes con la 17 a la 20 no O sea como que este flag marca el último este ciclo de del rit no entonces quiere decir que o sea bueno por ahí paso por ahí paso o algo no O sea lo que
(37:29) nos está arrojando aquí es que se aumentó o sea lo que sabemos no es que a y b van a terminar siempre en más un no del right y quiere decir que si pasó Ah que si pasó que flag igual a true no quiere decir que estaba ya por la línea 17 18 no o sea esto se hizo más o menos al tiempo no entonces por eso lo que sucede aquí es que a y b ya son igual a uno y que la línea 17 Pues en realidad sucedió antes no o sea porque esta es la última vez que entran al ciclo Sí o sea bueno Más o menos como que o sea como que se están haciendo a
(38:14) la par no porque a la par ajá ajá s O sea no es como que que primero O sea por lo que yo lo entiendo primero está haciendo como que el a igual a cer y Por ende B termina como que o sea se se queda en uno pero luego le suma uno a b quedaría dos pero luego como que hace el B = a Entonces se regresa a uno no a cero no más bien porque ya después hace a = + 1 Ahí va el + un pero luego como que toma el + un de la línea 34 y por eso como que queda en dos y b queda en en uno no O sea algo así medio extraño No sí como
(38:55) que al final Como que por ejemplo no O sea al final tenemos el reseteo de a0 Entonces al final lo que se hace pues es que tenemos en la línea 34 y en la 20 tenemos a + 1 no O sea a va a quedar en dos y ya de ahí dependiendo lo que suceda antes no eh Porque B tiene también se suma dos veces a uno pero quiere decir que B Se Iguala a a cuando es cer0 no O sea como que aquí sucede concurrente o sea sucede antes la línea 17 no y y b quiere decir que se igual a cer y ya después se le agrega uno no O sea lo que suceda primero no O sea la
(39:32) línea 33 p = 1 pero pues se resetea a a y a ya valía uno no porque esto O sea est tenemos esta relación de que sucede primero la 33 y luego la 34 Entonces al final por eso queda esto no porque se hacen al mismo tiempo pero bueno o sea lo que fuerza flag es que se respet también el orden O sea que que el orden de la línea 33 y 34 nunca super no a a la bandera en en true Ajá pero bueno o sea por ejemplo no poniéndole volátil a a flag No pero si le ponemos solo volátil a estatic Ah Ajá perdón a si le ponemos solo
(40:19) volátil no a a y a b este eh qué Qué sucede no sucede lo mismo o sea quiere decir que poniéndole volátil tanto a flag o poniéndole volátil a a y a b recordemos que lo que hace volátil Es que hace que se respete el orden de las instrucciones pero que además todo lo que ya se hizo antes o sea para el hilo writer por ejemplo H writer dice eh Sí o sea a tiene volátil y b también no est dos variables la línea 33 34 no tienen volátil entonces lo que dice eh volátiles sí esto sucede Pero además Haz que lo que está antes tenga efecto Ya
(41:04) para los demás hilos Entonces se dan cuenta no importa si le ponemos volátil solamente a flag O si le ponemos volátil solamente a aave de cualquier forma este o sea forzamos a que true sea visible para el rit perdón a que la a que la bandera flag no en true sea visible para r ya ya vieron o sea est como este o sea fuerza o sea volátil fuerza que sí que a y b tengan efecto pero que tengan efecto en este orden y que todo lo que sucedió antes tenga efecto también para los demás y en la anterior no no si también sí la la anterior también si le
(41:48) ponemos solo volátil a a esta también Se imprime el Main Sí sí Ajá sí sí sí sí O sea ya vieron es lo mismito no este entonces e Bueno aquí como apunte no este en este caso como las variables bueno la actualización no actualización en el Wi de las variables a b y está bueno relacionado entonces ponerle
(42:52) volátil solo a solo [Música] a y fuerza Bueno fuerza fuerza a que FL sea visible para el no noer volátil a ambos No pasa nada o sea se cumplo nada más debería No sí O sea no es lo que sucede siempre y siempre va a suceder lo mismo quiere decir que las O sea que hasta las actualizaciones suceden siempre igual o sea la la Cómo se entrelazan estas dos siempre se mantienen
(43:57) pero por ejemplo si le pusiéramos volátil según yo se cumple igual si solo tiene volátil una sola [Música] este Ajá sí por qué porque todas están relacionadas o sea el orden de ejecución de todas está relacionado Entonces si se actualiza a se debe actualizar antes la flag and true Sí o sea como es totalmente relacionado fuerza que la la Bandera siempre se vea Vale entonces como en la tarea por ejemplo tenemos este [Música] eh [Música] está Ajá en la tarea tres tenemos HM esta no
(45:03) visibility dónde es Entonces tenemos esta no entonces aquí Qué pasa No yo les pregunto si si si divide entre cero alguna vez eh Y bueno qué es lo que hace el H writer es que el primero cambia x a un y luego pone la bandera en true y este no va a hacer nada O sea no va a quedarse como en la línea 11 hasta que se cambie la bandera verdadero y entonces va a ser esto no entonces La pregunta es si divide entre cero Entonces ya vimos que volátil o sea ponerle volátil a una variable que está relacionada con otra Eh entonces en este caso se dan cuenta
(45:54) si solo le ponemos volátil a true este Perdón volátil esta bandera flat quiere decir que se va a cambiar a true Eh sí solo Sí o sea se va a ver si ya se reflejó el X igual a 1 para todos los demás hilos Vale entonces como ya vimos en este ejemplo las variables que están relacionadas en orden o sea en instrucciones este se va o sea se va a mantener no Entonces si le ponemos solamente volátil a la flag no quiere decir que el H reader siempre que lea que o sea que salga de este bucle no O sea que le true quiere decir que el uno
(46:38) ya se escribió no O sea que el X = a 1 ya se escribió siempre siempre o sea se debe mantener el orden de las variables o sea de las instrucciones Vale entonces ahí pues ya como que está la respuesta no O sea por qué Por qué es posible o sea Sería posible que divida entre cero no si tenemos el volátil en la bandera falso pues ya se Bueno creo que ya les comenté no O sea si más o menos lo ven no O sea solo va a poner la variable en true si x1 se refleja para todos los demás hilos Vale entonces este o sea en este ejemplo
(47:17) No aquí se ve como no importa que le ponga volátil como todas se relacionan el código va a forzar a que las actualizaciones de las otras refleje no antes de que se refleja que le pusiste volátil no tanto si es de o la bandera vale t más o menos o nada más los dias Sí cómo cómo cómo lo ven Okay Bueno pues ya les dejo de tarea que se pongan a jugar aquí en estos programitas vale Este sí pero sí Bueno pues aquí se los dejo pero Eh Pues bueno les digo como en realidad O sea a veces no no controlamos O sea no sabemos el compilador en realidad qué
(48:19) vaya a hacer no entonces hay que estar como viendo e pero bueno dice cam creo que sí Entonces lo de arriba de la variable volátil Siempre será a los demás Cuando se actualice la variable Exacto Sí si le ponemos a FL volátil quiere decir que todo lo que está antes se va a reflejar y todo lo que está después va a pasar en ese orden Entonces si le ponemos también a b todo lo que está antes se va a reflejar entonces por eso es que poniéndole volátil a cualquiera de las tres variables hace que el hilo reader termine no o sea dice Ah mira Sí ya ya
(48:57) este la bandera está en verdadero salgo de este bucle y ahora sí imprimo no sí sí sí Entonces ya con eso para la tarea Bueno al menos no lo lo ven y también para sus futuros códigos m Pues la verdad a mí me gusta me gusta en flag me gusta en flag porque como que es la variable determinante no O sea tu programa no acaba si el hilo re no lo ve no Ajá dice Camilo tiene algo de malo ponerle volátil a todos pues nada más en rendimiento no en rendimiento tu programa Va a ser poquito más lento pero este pues bueno ahorita como que no
(49:50) tenemos tantos problemas en eso no O sea no les estoy pidiendo ahí que eficiencia no pero Pues sí nada más es Eh Pues sí para no hacer el programa más lento de lo que podría serc ya no con volátil pero sí no sea pues podrían ponerle a todo ya pero bueno sea hay que tener cuidado también hay cosas que no ocupas a veces volátil no en este caso Sí porque pues si no r nunca acaba no per hay otros en los que no se ocupa o sea bueno no pasa nada no O sea si no le pones volátil el programa sigue cumpliendo no sé con exclusión mutua y
(50:26) sigue terminando no en este caso no termina entonces aquí sí se ocupa okay Bueno vamos ya ahora sí a este les estaba calificando unos su práctica Okay dice suriel hay que volver a ver este por qué a ver bueno es Porque cuando terminan los los o sea digamos que lo que lo que está sucediendo este a ver Déjenme ver sí eh puedo abrir una una hojita esperen un tantito voy a abrir una hoja
(51:32) para escribirlo no para que má clar esto este a ver Okay entonces Déjenme pego aquí el código vuelvo a tomar mejor
(52:58) [Música] m kapt Aquí está Okay entonces bueno tenemos Este programa no Y entonces quiere decir que Cuando tenemos volátil en algunas de las dos lo que hacemos Es este por ejemplo
(54:05) no está ejecutando el hilo read y el hilo gr no entonces el hilo r empieza aquí y está todo el tiempo en este ciclo no dando vueltas entonces Eh Pues él está leyendo que la bandera Vamos a ponerle no aquí es el hilo reader y el hilo writer entonces todo el tiempo está dando vueltas aquí no Mientras que está haciendo pues hace a = 0 no y luego dice B = a b + 1 luego dice B + 0 Eh bueno B = a no O sea B = 0 y luego dice a más este Bueno a termina en un no y b termina en cer0 o sea como que lo que está sucediendo todo el tiempo aquí es
(54:52) esto no Y esto se repite repite este hasta los 100000 nanosegundos no que gr pues ya está ejecutando aquí pero mientras estaba dormido no supongamos que aquí Ya por fin despierta no Y él dice a = b b = a no O sea que lo deja igual no este ah no sí aquí qu haría sería a ig a b cero no y b = a a a cer no O sea digamos que aquí lo resetea y luego dice ahora sí flag igual a true no pero mientras quiere decir que el H reader pues ía dando vueltas no as repitiendo y repitiendo reseteando a a = 0 y luego B = 0 y a = 1 no entonces
(55:49) quiere decir que en este punto no sé puso la bandera en true H y acá quiere decir que lo que sucedió es que e pues entró al ciclo no y supongamos que este entró al ciclo no y no sé aquí sucedió el último ciclo vale Pero quiere decir que entró al ciclo cuando FL era igual a true no O sea quiere decir que esto Ay escrit quiere decir que flag igual a true se hizo ahora sí que entre que entró al último ciclo no O sea justo aquí entre que entró al último ciclo Y entonces la primera instrucción que se hizo aquí fue a igual a cer no pero qué
(56:53) pasó después sucedió de + 1 y a + 1 no O sea aquí lo que hace es B + 1 y a + 1 y mientras el r el Lilo reer lo que hizo fue este B + 1 B + 1 y ya más un bueno P B = 1 y así no est es lo que hizo Ah bueno lo hizo al revés b y Lu a entonces lo que hizo aquí este y mientras es de forma concurrente se hizo También acá no este un B + 1 y acá se hizo un ba no supongamos que
(58:01) entonces sucedió acá B O sea que quiere decir que B antes estaba en dos no B + 1 = 2 pero lo igualó a entonces quiere decir que se convirtió en un y después Ahora sí sucedió a = a 1 no este bueno a+ 1 Ajá sí sí entonces finalmente a lo que hace es que vale dos no porque ya estaba en uno o sea de este no Entonces al final quiere decir que tenemos se suma a + 1 y a + 1 no entonces queden dos y b Lo que sucede es que Pues est digamos que sucedió antes no O sea como que analizando las las Ay no veo el chat en el chat Ah sí Sí vale entonces
(59:02) analizando aquí quiere decir que estas operaciones todas estas sucedieron más o menos de forma concurrente no Entonces si analizamos tenemos dos as + un no tenemos un B = B + 1 pero a la vez tenemos un B = a a no O sea que quiere decir que B por o sea sucede antes no Entonces se Iguala a uno a pesar de que era dos se Iguala a un ya Ya acaba entonces que es lo último que ha Elo reader no y ya de ahí reer pues quiere decir que es el último ciclo no en cuanto flag se hace y sale y ya finalmente quedan dos y uno pero si no
(59:38) lo ponemos quiere decir que el ciclo Ajá se queda dando vueltas todo el tiempo porque o sea digamos que si no usamos volátil sin volátil quiere decir que este todo el tiempo se está ejecutando este ciclo no y nunca acaba entonces a pesar de que aquí se actualizó aquí seguimos dando vueltas no este entonces queda siempre como este a = 1 B = 0 no es lo que debería quedar sin volátil entonces a ver de compartir y ahora sí pantalla Entonces ahora sí no este sin volatil sin nada nada no se todo así e ajá No Ah bueno en este caso igual a
(1:00:42) uno y uno no a ver este otro Ah sí uno uno y uno ah es curioso no este ah lo que es sucede es Sí pues se se cambia esto quiere decir que writer nunca se entera que la bandera está en cero y miren aquí es todavía más curioso no a es igual a 0 no B es igual a má más igual a 1 no este entonces aquí B vale 1 luego B vale 0 aquí a y b son 0 y luego B = 0 a = a 1 y aquí de hecho lo que tenemos es un problema de reordenamiento no ya vieron es el problema del ordenamiento Por qué sucede chat Aquí está el chat Ajá sí O sea ya vieron en realidad
(1:01:40) si O sea qué debería vamos obtener aquí siguiendo Pues el orden de las instrucciones qui si este Lilo Main se duerme 15 nanos o se duerme más que el gr no quiere decir que el gr hace que B sea ig 1 a ig un pero el rit el Lilo reer nunca se entera no nunca se entera que que que la bandera cambió o sea por eso ya vieron aquí Se imprime y solo imprime writer y Main pero reader Nunca termina o sea reader sigue dando vueltas ahí no y lo seguirá creo o sea por eso aquí dice que le ponga stop no porque en realidad sigue dando vueltas pero bueno
(1:02:17) entonces este eh Qué quiere decir que lo que tendríamos que tener al final sería que a = 0 perdón a ig 1 en la línea 24 ya a = 1 y B = 0 no Por qué Porque a es igual a 0 luego B = 1 luego B = 0 porque se Iguala a a y a queda en un No pero en realidad lo que tenemos es un y un quiere decir que el programa Además nos ordena como quiere no O sea nos ordena nos ordena nos dice qué ha de hacer el programa yo creo que saben qué ha hacer pone la la igualdad no sube cambia de orden la línea 22 con la 23 y ya con eso nos queda un un no
(1:03:02) entonces el programa Todavía este como no hay volátil pues yo creo que el compilador Consideró que es más fácil hacer primero las igualdades y ya luego sumar no que sumar es en realidad O sea no es nada más este no es una sola instrucción son dos instrucciones en una no sumar Entonces el compilador considera no ordenar nuestra eso tiene que ver con que es más igual a uno es azúcar sintáctica es azúcar sintáctica Ajá sí O sea así como que se se suma no Sí o sea se suma no se Iguala sino que se suma no lo que lleva se le suma
(1:03:44) Ajá sí Entonces el o sea aquí no solo por eso no el no solamente tenemos un problema de visibilidad que que r Nunca termina sino tenemos un problema de este reordenamiento no O sea nos hace lo que quiere eh nos ordena no O sea como dice no pues Miren el compilador dice Ah B ig 0 pues cámbiala acá no para que sea este s no la cambia acá Arribita de hecho si la cambiamos arriba no debería no pasar nada debería dar lo mismo A ver así no miren aquí que Qué hace B = a a Ajá qu sucede aquí [Música]
(1:04:58) Bueno voy a dejarlo como estaba por qué Por la a Bueno vamos a dejarlo así pero este Bueno si este ya para la tarea Simplemente no ponerle vol volátil a una hace que eh todas las instrucciones que están sucesivas a ella tengan efecto para todos vale Y además nos evita como estas cosas no de reordenamiento cosas que no deberían pasar porque aquí claramente deberíamos obtener 0 y un no en a1 b0 y obtenemos un un no O sea quiere decir que el programa nos reordenó las dos líneas nos reordenó Ajá nos reordenó alguna alguna línea aquí no
(1:05:52) Cuál es bien pues no sé no O sea por qué Porque no no sabemos O sea no sabemos bien qu hizo el compilador abajo pero de que pasan cosas extrañas sin volátil las pasan suceden Vale entonces Esas son estas dos y Déjenme de una vez ya vamos a peterson este Bueno uno de ustedes que cambió el get ID pero bueno si quieren cámbienla vamos a ver dónde está ahora sí no eh A ver tenemos el algoritmo peterson solo funciona para dos hilos No pues sí ya lo vimos dice por eso quedó Por eso como lo entiendo sin volátil el no se
(1:06:51) entera del cambio por eso sigue en el Wi Pero al final se queda con las asignaciones finales de right No por eso queda uno y uno eh Ah tienes razón soriel tienes razón Sí o sea quiere decir que ni siquiera este es visible los cambios que hace el reader no Ajá tienes razón Sí sí sí sí qu buena explicación sí Entonces cuando pero por ejemplo si modificamos B = a ahí qué pasa no O sea sí O sea en realidad Por ejemplo si queda un un no O sea Al final este tenemos la línea 37 y 38 no supongamos que eso queda y que el hilo Main pues es
(1:07:51) soleno como que no no fue visible no sup entonces las modificaciones aquí en adentro de no de la línea 21 a la 24 tampoco deberían ser este importantes no en ese caso no crees Porque por ejemplo mover acá a ver en este caso si no le importa no si haces Antes el uno Ah bueno Sí pues aquí no hay problema no en realidad da igual es lo mismo pero o qué pasa si de inicio Flash en la asignación Ah o sea esta la ponemos antes ahí sí cambi
(1:08:56) más bien no no de cambiar Como así un uno ah arriba este Ah o sea como para ver qué sucede no sí suponiendo no que enseguida esto Bueno eso sí Sería distinto porque quiere decir que nunca va entrar al ciclo no entonces solo se va a hacer lo del hil Bright no si o sea nunca entraría a este ciclo en realidad rit no modificaría absolutamente nada y solamente sería lo que modifica [Música] el Per por ejemplo Aquí hacemos no sé la asignación antes suendo dos y
(1:10:03) dos Ah tienes razón s tienes razón Ah bueno Por ejemplo si no verdad aquí lo que pasa es que ha se que un no pero aquí a igual a c porque al final lo resetea resetea a y b es ig a O sea que a ig cero no Bueno este ya yo creo que Ajá si es que sin volátil pasan cosas feas feas es mágico Ajá o sea Pero bueno con volátil ya no pasan estas cosas eh tampoco crean que es es como lo que estamos viendo en de los registros regulares no pasan cosas bien raras o se supone que sigue un orden pero no no porque si B es igual a
(1:11:11) a y este es igual a 3 Ahora sí quiere decir que nos reordena las líneas clamente no O sea bueno lo que lo que nos reordena aquí es no porque reit no puede llegar a ser tres porque se supone que lo que nos hace re es que resetea b ig a a no pero bueno sí O sea sí Camilo es mágico pero sin volátil vale o sea si usamos volátil si usamos atomic ya no pasan estas cosas vale o sea tampoco se crean como que todo es así horrendo no pero sí O sea si como que representa clamente no este de las sumas o sea e como las cosas extrañas que pueden
(1:12:01) pasar no Pero bueno o sea como les digo O sea no no sé yo a fondo qué pasa no O sea no porque pues no no hice yo el compilador no O sea no sé bien quién qué va Qué se va a reordenar antes no justo que o si no es que nos va a reordenar algo pero bueno entonces este vamos ya con esto e Entonces el algoritmo de peterson si no solo funciona para dos hilos pero su objetivo de ustedes es que funcione para cuatro Entonces qué Vamos a hacer van ustedes a a realizar una implementación Vale ahora sí que como la que vieron en la tarea dos o sea literal
(1:12:47) tómenlo como seudocódigo Vale entonces lo simplemente lo que van a hacer es que pues van a probar no que su ad funciona para cuatro hilos utilizando un executor service y le ponen así para 400 tareas Vale y Pero bueno sea no no es mucho No nada más tienen que crear la tarea que aumente de uno un objeto contador y este y y pues ya lo ponen a correr vale con su nuevo candadito entonces eh De alguna forma no Y esta forma pues va a ser con futures obtengan el número de veces que los cielos aumentan el contador entonces pues si son 400 tareas no O sea
(1:13:29) como que un candado justo Pues yo creo que las dividiría no 100 100 100 este más o menos no sea sí hay los medio lentos pero más o menos Debería ser así como algo este que cada quien haga a proox un cuarto no de tareas y Bueno o sea en realidad ustedes ya analizaron en su tarea que en realidad esta implementación no cumple con justicia no claramente eh Por qué Porque al cambiar no de un hilo a otro te pueden adelantar como que pues sí O sea algún hilo puede pues no ser este muy rápido no Entonces te pueden te pueden
(1:14:04) adelantar al cambiar de de un este de tomar un lock a tomar el otro Vale entonces este Simplemente yo aquí Ya les hice el peterson o sea bueno lo program no sea les digo que si quieren ustedes cambien el ID pero es realmente lo mismo este ah dice victim en tres porque pues solo somos dos hilos Vale y como puse el módulo dos Pues nadie va a ser inicialmente tres entonces este Es igualito casi no que que en el libro alguien va a ser el el ID y alguien es el j y este sí Pues sí tal cual y bueno entonces la bandera
(1:14:50) este la inicializan primero en verdadero luego hacen victim igual a y y se quedan esperando si son la víctima y el otro Quiere pasar no eso es lo que hace peterson y ya el momento de dejar el candado pues simplemente dices este falso no y este importante no ambas variables son volátiles vale para que no sucedan cosas extrañas e y porque aquí si nos importa o sea nos importa mucho si eh nos reordenan estas dos líneas o si el Lilo se queda o sea está esperando No leer la variable victim que no sea él o está esperando
(1:15:34) que el otro la ponga en falso No ya cuando deje el candado Entonces es importante que tengamos volátil aquí eh entonces este así funciona peterson y ya nada más acá pues lo que hice fue ponerlo a a correr no seces la tarea este a la tarea pones un este el el candado no que en este caso es peterson pu esta implementación este y tiene ambos métodos lock y unlock entonces simplemente lo tomas y lo dejas vale Este candadito ya le puse Aquí el el counter Y entonces este en este caso pues nada más no una executor service
(1:16:16) Pues de dos hilos no pero la idea es que ustedes la hagan para cuatro y que aquí en vez de pasarle 1000 no O sea le pasen aquí este 400 tareas y y este y lo pongan a correr no Entonces al final la idea es que veamos no sea si Cómo se ve la justicia o sea teóricamente sabemos que que no se cumple no O sea la justicia no este no es justo este candado no O sea si hacemos la implementación para cuatro hilos no será justo Entonces cómo va a ser su candadito nada más así similar a esto sea consideren un montón este seudocódigo no el Double
(1:17:00) peterson ent algo así O sea tienes el candado entonces creas así varios peterson tres De hecho no para hacer cuatro y y a cada uno se con módulo pues haces que solamente porque si se dan cuenta Bueno no sé cómo son en sus compus No pero en la mía Pues empieza creo como en 20 21 22 los ids no ent por eso le pongo módulo para que justo solo tenga uno el ID de uno el ID de dos Vale entonces este y ya también para dejarlo o sea nada más es acomodar el candado peterson o sea que ya está aquí o sea lo toman así no como una instancia y y crean su
(1:17:41) nuevo candado Double peterson vale esa Esa es la primera parte o sea no sé cómo la ven siento que está como sencilla no este o Cómo la ven ustedes si más o menos cachan como cómo hacerlo para cuatro hilos Sí vale Bueno ya si no me preguntan no y este Ah bueno la otra parte de la tarea de perdón de la práctica es que más o menos el próximo jueves sale en la sesión de dos ahí de hecho o sea así lo pienso no que quien entre a la clase de hoy Pues en realidad ya sabe que hay que hacer No y en la sesión siguiente tienen 2 horas
(1:18:31) para hacerl o a mí me parece perfecto 2 horas está perfecta no y ya está para reportar Bueno no sé según yo pero o es la idea que que este pues que no sea tanto como trabajo no pero pues sí como que no tiene caso siento que yo de tanta clase si es la parte práctica no bueno no sé yo digo entonces así este yo les digo qué hacer y a la siguiente clase la hacen y y me van preguntando no si es que hay dudas pero bueno entonces ya luego tienen que hacer en el ejercicio dos van a implementar Bakery pero es la que vier vimos en
(1:19:05) teoría y lo consideran O sea no no hagan una generalización vale solamente es para cuatro hilos Así que los arreglos flag y lavel pues los construyen simplemente de tamaño cuatro no y este y bueno ven si es necesario ponerle volátil a estos vale o sea como que Pero bueno o sea obviamente me imagino No pues para no no no preocuparnos pues le ponemos No pero bueno o sea consideren no este si sí realmente los necesita o no entonces eh con ayuda igual o sea es lo mismito de la para que para Double peterson no igual con un executor service ejecuta
(1:19:43) cuatro tareas no Perdón 400 para cuatro hilos y este y pues de alguna forma no O sea casi pues reutilizan ese mismo código que hicieron para acá no los futures y todo para ver cuánto hizo cada uno no y y además este decir No si esta implementación consideran que cumple con justicia que si la hacen o sea les queda como muy de acuerdo con con el con el este el el código teórico no O sea el que está en el libro o el que vimos en clase este Pues debería cumplir con justicia no O sea debería y hay que ver si realmente se ve o sea se diferencian
(1:20:20) en algo estas e entonces bueno eso es lo que tienen que hacer no es como el trabajo de programación Eh y además yo les compartí el programa de bakri este pero no no es este vale o sea el el que está en el dos es tienen que basarse en el que vimos en teoría pero yo les compartí otro que que es este sí es una generalización o sea para n n hilos vale Eh entonces y Bueno aquí se los presento Pero bueno de una vez les digo no lo que tienen que hacer es revisar Para qué sirve este campo el atomic reference revisar Para qué sirve comper set y get
(1:21:07) vale o sea como que ustedes investiguen ya eso lo vamos a ver el siguiente la siguiente práctica y también en teoría pero se me gustaría como que despés tomaran la iniciativa no y revisar qué son estos métodos ocupa Bueno después deben escribir a lo más seis líneas o sea tampoco se lo que no no me digan como Ay est variable Este no sé se aumentó en uno y luego en dos no tan preciso pero sí como que me digan en general Cómo es que funciona no luego tienen que ver que si Bueno ahorita les enseño Quién es next no si
(1:21:45) la variable next no es de este atomic reference pues seguiría funcionando y y revisar si mantiene la lógica de la impl de de la pregunta dos o sea la que ustedes van a hacer este de lo que se vio en la clase de teoría vale Entonces miren Cuál es el código es este de aquí miren en realidad o sea lo implement de esta forma este tenemos en realidad es una cola vale una cola tenemos el nodo también el nodo interesante tenemos el nodo y Y esto es lo que cambia bueno tenemos la bandera este una bandera vale en cada nodo que va a ser de tipo
(1:22:34) volátil Por qué Porque si me importa no que se refleje el cambio se Sí o sí ocupo que sea volátil luego tenemos en la línea si el campo next que va a apuntar a otro nudo apunta a otro nodo Este pero muy interesante es una referencia atómica vale una referencia atómica de tipo nodo luego se va a guardar el el Pues un ítem que va a ser así entero y lo que se hace para inicializar el nodo pues es simplemente poner la bandera este en algún valor no este ponerle el ítem y se inicializa el campo next a a nul no O sea una referencia O sea
(1:23:30) inicialmente no pues el el nodo no apunta a nadie no Simplemente es a nul entonces eh luego qué hace acá Este Bakery no lo que hace es que tenemos el los nodos no Head y Tail Y estos dos nodos el primero va a ser igual a cero y el siguiente va a ser igual a un número grande no O sea le puse ahí 100000 eh Pero bueno o sea yo creo que eso ya sería como para generalizar lo bien poner ahí un Max integer y un mini integer no de Java pero bueno entonces inicialmente este las banderas de ambos están en falso y este y esta línea nada más la puse para
(1:24:16) que eh este bueno bueno concentr centrémonos en esto primero vale en este qué es lo que nos dice nos dice que el apuntador de get le haga yo un comper set y un comper set nos va a decir nos dice si si está apuntando a nul entonces cámbialo a Tail vale es lo que nos dice aquí el compan ve como que es un es le hace honor a su nombre no compara Y si está bien apunta no O sea bueno hace el cambio Entonces nos dice nos dice en este en el apuntador de Head si el apuntador de G está apuntando a nul entonces cámbialo a Tail Y por qué lo
(1:25:15) puse en el W porque hagan de cuenta que lo que regresa Conan set es un valor buano entonces si realmente pudo hacer este cambio te va a decir true vale pero si no lo pudo hacer te va a decir false Entonces digamos que eh apuntará Eh bueno si si logra hacer el cambio de nul a Tail regresa eh y termin no pero si no lo logra regresa este false y lo vuelve a intentar V por eso se pone en ese en ese Okay entonces este Qué sucede acá el el este campo de lock vale
(1:26:25) Cuál es la lógica de este de este Bakery pues se acuerdan no que Bakery este pues es como irse a formar a la fila de la San Pablo no de la farmacia tomas una tomas un número no y este y no sé pues tienes el número 38 no Entonces estás esperando a que te toque Entonces no se están en el número 35 y tú sabes que no s en tres personas vas a pasar Pues digamos que la lógica aquí es es que tenemos una cola Entonces como la cola es fifo pues el que vaya primero va a pasar primero no y el que se forme al último en la cola pues va a pasar al
(1:27:04) final no entonces eh quiere representar Esa esa idea no como de tomar un número y formarte a esperar no y En qué orden vas a pasar Pues en el orden que llegaste entonces la idea del campo del método lock no la idea es que el siguiente que añada su nodo eh pasará una vez e sea c turno no una vez que sea c turno lo pongo acá para que se vea mejor entonces esa es la idea de del nodo perdón del del campo lock Bueno del método lo Disculpen entonces La idea es no entonces el método lock de qué consiste Pues que que un hilo quiere
(1:28:07) poner su su nodo no entonces este qué le va a pasar al método el nuevo nodo eh este entonces eh mientras no me haya no me no me haya añadido pues va a ser falso o sea para eso es no esta variable cambia si ya me añadí a la est true bueno est true si si mi nodo ya está en mi vale Y este y este simplemente es para guardar el anterior vale noo que guarda al anterior Entonces qué hace aquí en la línea 22 este pues voy a estar voy a estar
(1:29:11) intentando Ay voy a estar intentando añadirme vale Y hasta que lo logre si no no salgo entonces qué va a pasar miren voy a voy a tomar la referencia a la que apunta Bueno aquí más bien checo No si si Tail no apunta a nadie pues quiere decir que la cola está vacía no O sea si la cola está vacía pues no apunta a nadie y entonces simplemente lo que hago es que este trato de añadirme en el siguiente del get Y si logré añadirme en el siguiente O sea la misma la misma este lógica no del comper Z si G apunta al anterior perdón a
(1:30:04) Tail entonces que apunte a mi nudo Esa es la lógica no de esta línea lo voy a poner aquí para que se vea entonces este finalmente no lo que hace es si si sí realmente este me pude Añadir y recordemos no lo mismo Solo regresa verdadero si se pudo hacer ese cambio Entonces si sí realmente me añadí entonces Este voy a hacer que te apunte al nuevo nudo no eh este entonces eh lo mismo No acá va a hac no [Música] e bueno cambia apunta next deta ain no y estaba inicialmente n entonces Simplemente ya lo que haces es este Ah
(1:31:07) bueno Last es igual a Y entonces para qué guardo este Last pues Miren la lógica de esto es que nosotros los hilos se van a formar en la cola vale con esto O sea digamos que en cuanto llegues a esta línea eh el nodo ya está en la cola vale o sea aquí en este punto ya está en la cola pero en este otro qué va a pasar pues miren voy a estar dando vueltas leyendo el el anterior no Last eh flag Este mientras sea true Por qué Porque eh Cuando quiera dejar el candado lo único que voy a hacer es poner mi mi nodo en falso vale Entonces digamos que
(1:32:07) inicialmente [Música] [Música] Ah Aquí está aquí está Entonces miren aquí está la creación del nodo aquí la línea 13 Vale entonces inicialmente este el nodo está en true vale sea la bandera del nudo Y eso qué implica que este si la bandera está en true y estoy formado bueno y implica que quiero pasar no a la sección
(1:33:14) crítica ya vieron entonces lo que va a pasar es que los nodos se van a formar no Entonces sí ya estás en la fila pero aún no estás en la sección crítica Cuándo es que vas a poder pasar sección crítica cuando el nodo de adelante no Ponga su bandera en falso mientras la bandera de adelante del nudo de adelante estén en verdadero quiere decir que uno o ya está Cómo van implica que quiero pasar la sección crítica Sí sí me escuchan es que me dice conexión inestable bueno se cortó Ah vale vale Pero bueno ya me escuchan
(1:34:14) verdad Ah vale gracias sí Okay entonces este Eh bueno esto en este primero no de aquí acá es si la cola está vacía pero si no está vacía No pues hago que veo Quién es quién es el anterior no este bueno Quién es el último o sea el que apunta Tail o sea con obtengo obtengo al que apunta te y ya no eso es lo que hago ahí luego acá Este hago que el el último no al que apunta este que en vez de que apunte a nul apunte a mí y si lo logré entonces hago que que Tail este eh apunte de del que está bueno antes estaba apuntando a Last Pues ahora que apunte a
(1:35:14) este nuevo nodo no que soy yo entonces Bueno les digo no hasta aquí pues ya estamos ahí formados en la fila y Mientras todos tenemos nuestra bandera en verdadero Entonces por esto que Hey Tail tien su bandera en falso ya vieron o sea digamos que pues eh el primero que se agregue no va a revisar que la bandera del anterior por ejemplo en este caso del primerito pues va va a ver la bandera de he va a decir Ah mira su bandera es falso Entonces yo salgo del ciclo no Y entonces termino de ejecutar el lo y puedo tomar no la sección
(1:35:51) crítica pero si y el de adelante tiene su bandera en true quiere decir que está formado esperando no O está en la sección crítica Pero bueno mientras este Mientras esté su bandera del anterior la bandera del nodo anterior está en true Entonces espero no Y entonces lo que hace el es decir el método lock está lo que hace es cambia laera a falso y entonces dejas pasar al siguiente en la cola ya vieron se como que te formas ahí en la fila les digo de la San Pablo í en la filita y ya entonces lo que haces te
(1:36:54) formas y te pones a esperar Bueno Este es el código vale o sea de aquí a acá pues es este el método lock el pesado no el método unlock este y este nada más es para imprimir vale Para que veamos cómo está el Cómo o sea cómo se ordenaron los hilitos Vale entonces ya para para ejecutarse pues Bueno lo que sucede no es que le paso Pues un candado no berer y le paso el el contador Vale entonces un ejecutor service de cinco hilos en este caso por ejemplo este Ejecutan 400 tareas y qué es lo que va a hacer cada tarea
(1:37:42) eh este toma no el candado lock y Toma este el contador entonces lo que hacen Es que en la línea 13 creas al nodo Y entonces sí en la línea 15 eh tomas no haces lock luego este Bueno yo lo puse así como que te duermes tantito no para que no suceda o sea para ver no que se tardan un poquito este haces el counter increment el contador pueses así un contador así sencillito y este y bueno Esta es de Catch no porque te duermes o es para para la la excepción no que pueda aventar el slip y finalmente dejas el candado no con el
(1:38:29) mismo nodo Para no perder la referencia o sea por eso lo puse así este entonces Ah va así Bueno aquí n má lo puse así Ah pero miren por ejemplo en 5000 no acabo contar este Ah bueno entonces por ejemplo qué tenemos primero si se acuerdan en en la cola tenemos primero al este no que vale cer y ya pues en la cola le dije que terminara de contar hasta que bueno Hasta que te encuentres a Ah bueno no en general no hasta que curren
(1:39:32) sea igual a nul y mientras imprimo todos los pred Pero bueno Ah bueno los predecesores Perita les exp Entonces el primerito Ajá s Es que creo que no leí tanto tiempo para que terminara de contar Pero bueno Entonces miren por ejemplo el ID este del hilo lo que imprimen son los ids Vale entonces el ID del hilo 20 es que en mi compo van del hilo 20 al 24 Entonces tenemos primero el hilo 20 no luego el 21 el 22 el 23 el 24 y otra vez el 20 el 21 el 22 el 23 el 24 no O sea casi que se forma No esto que Se imprime son los ems que son los ID vale de los
(1:40:19) hilos entonces casi se forman no y van aumentando el contador y al final le dije que me imprimiera pero a mí me parece que no le tanto para que se [Música] durmiera blog print déjen aquí pongo Ah Ya sé es que podría imprimirlo así no mejor se lo de
(1:41:33) y no sé a ver 500 si los dejo dormidos cinco sí debería acabar no no no se puede Ah s mir todavía le falta No Bueno vamos a dormirlo ganito más muchos [Música] segunditos Ahí está no Okay entonces bueno como veren es un poco lento no este pero sí termina de contar justo las 400 tareas que esa es la idea no Empezamos el contador en cero entonces este aquí se ve o sea digamos que lo que
(1:42:37) Se imprime no todo esto todos estos números son los este y siempre sucede no 20 21 2 24 20 21 2 así siempre sucede así no este es muy curioso se forman justo los hilos no de en orden de creación Entonces es este lo que sucede aquí es que se imprimo los ems y en los ems yo lo que hago es que guardo el el este el ID Vale entonces tengo ID desde 20 a 24 para cinco hilos entonces pues se ordenan justo en ese no en ese orden justo van pasando los va formando así de forma muy justa no eh entonces bueno regresemos a las preguntas vale qu qué
(1:43:26) es lo que este acá Este yo les digo no revisen elery porque ya está hecho no O sea este otro no ustedes van a hacer la clase teórica pero les digo que esto es una generalización no debería funcionar para entonces este deben revisar Para qué sirve el campo atomic reference entonces bueno ven ven ahí en Java no ven la documentación o sea Simplemente no lo buscan y ven para qué sirv Qué hacen los métodos comper set que ahorita ya les comenté no pu Bueno espero que más o menos lo hayan visto Aunque es nuevo pero get aquí pues lo que hace es que
(1:44:09) obtiene tal cual la referencia por ejemplo curr no O sea revisa la referencia de de PR y el comparet lo que hace pues es que trata de modificar no eh este el valor esperado por el valor nuevo y si lo logra pues te regresa un true y si no lo logra te regresa un false no pero bueno es muy curioso que eso se hace de forma atómica es decir que esas instrucciones no O sea por ejemplo pues una lectura y una escritura son operaciones que claramente sabemos que es solo solo una no O sea pues leer solamente es r no O sea y se hace en un
(1:44:49) punto No o sea solamente se lee solamente se escribe pero para para por ejemplo hacer esta operación de comper set Pues en realidad si se dan cuenta es como revisa o sea lee el valor si el valor es lo que se espera Entonces cámbialo ya o sea Ahí van como otras dos dos instrucciones más no Y además si lo logras regresa verdadero y ahí va otra instrucción Pero qué es lo que nos hace est estos métodos hacen que estas cuatro instrucciones se hagan en una sola Por qué porque estas iciones ya las trae están Viven en el Hardware o sea
(1:45:27) viven en su procesador Intel en su procesador md en su procesador Apple viven ahí entonces este nos permiten hacer estas cuatro instrucciones de un jalón o sea como en un solo paso vale Bueno entonces este bueno van a describir cómo funciona no O sea más o menos es lo que les comenté O sea la idea pues la idea pues es no de que te formas en una cola y y este en esta cola pues esperas no que que el anterior termine de o sea o haya pasado la sección crítica no O por fin llegue que ponga su su bandera en falso y entonces tú pasas no pero bueno quiere
(1:46:11) decir que tú solamente revisas al del anterior no no revisas a todos es como más eficiente en ese aspecto no solo revisas Al que está antes de ti Eh entonces bueno en la en la C tienen que ver no si next no es atomic reference o sea next este no está la línea s No si next no atomic reference es posible o sea sigue funcionando esto y Bueno aquí pues ya tienen la experiencia o sea en su cola concurrente sin candados pues sucedían cosas extrañas o sea ponían cosas este Bueno un hilo trataba de añadirse un enq y pues no lo lograba no o hacas
(1:46:52) un deq y regresabas doble o o sea de cosas feas no Entonces esta es la pregunta pues les digo no ya tienen a ustedes la experiencia de que pues saben que que no no no funcionaría este entonces eh a fuerzas tenemos que ocupar atómicas por qué porque pues estamos haciendo un candado no O sea no podemos hacer un candado para hacer otro candado imagínense no O sea este o sea por ejemplo en peterson Double peterson Pues sí no pero pues ni modo que usemos este no sé un candado reentrante no O synchronized porque pues esos son
(1:47:29) candados estamos haciendo un candado no de cero desde cero entonces pues sí O sea por eso no no podemos ponerle simplemente a la cola sincronize tenemos que utilizar estas operaciones este pues más poderosas vale Y se acuerdan no en la clase teórica vimos eh que ya las operaciones menos poderosas que son los registros Pero bueno estas otras son más poderosas nos permiten hacer este tipo de cosas Eh entonces ya la siguiente pregunta es pues ver no O sea ustedes consideran si mantiene la lógica o sea realmente se
(1:48:05) puede decir que es un backery no O sea nada más que implementado pues ya este como de forma más eficiente no O sea como revisar eso este Tienen que contestar vale si si realmente ustedes consideran que mantiene esta lógica de formarse y pasar Eh y bueno tanto si sí o si no si contestan eso no si sí o si no pues decir por qué Vale entonces Bueno cómo lo ven Esta es la práctica en realidad pues el tres es este que se pongan a a correrlo no que vean ahí cómo funciona hasta ustedes podrían quitarle el next y pues van a ver que no funciona
(1:48:41) no claramente O sea si no si no le ponen el atomic reference este jugar con el comper set con el get no eh Pero bueno esa en realidad ya está la que tienen que hacer Pues sí un poco de cero pues lados pero no me parece como como pues tan complicadísimo no O sea seguir justo la implementación de del arreglo de la bandera no de flag y de Label este Y entonces pones a los a todos los hilos a revisar no estar leyendo este Label o esta esta bandera este a ver si no hay alguien no si si ya si ya te toca entrar no a la sección
(1:49:20) crítica y en la un pues es este tomar instancias de peterson acomodarlas de forma que solo permitas que al final pase uno no eh teniendo cuatro hilos les digo no considerando un montón esta no el Double peterson y ay Bueno ya no ya no corrí el este lock Pero bueno o sea funciona igual no funciona bien pues sí justo cuenta las 400 siempre no este está Sí o sea quiere decir que funciona No sí funciona Vale entonces alguna duda Hasta ahorita los pudic códigos están en la presentación dos Ajá sí en la presentación dos y en el libro vale
(1:50:10) eh este pseudocódigo de Bakery no Ajá sí sí O sea solo ocupan el pseudocódigo de bery no el de peterson pues ya está hecho nada más tómenlo y y pues nada más les digo lo acomodan lo acomodan así no O sea a prox no O sea obviamente ya en la práctica como que cambian algunas cosas Vale entonces este el jueves siguiente Pues yo espero no se ponen igual y le dan una leída pero bueno como ustedes s entraron Pues no creo que que ocupen no rever esto pero este ya el jueves eh voy a estar así al pendiente No me conecto y
(1:50:59) y Bueno nos vemos el jueves para las vale vemos by for
