2024 09 13 10 02 36 - YouTube
https://www.youtube.com/watch?v=u2GnT6ULMgQ

Transcript:
(00:29) al al al Hola Hola Buenos días
(02:03) [Música] creen que estaba revisando su práctica dos justo ayer y hay un par de equipos bueno llevo cinco no tres muy bien y dos como que no tan bien nada bien pero creo que hubo un problema no bueno C saliste perfecto pero el equipo de de Kenia el equipo de Ay no me acuerdo de Alex de Cruz Cruz Bueno pero bueno ya luego me comunico con ellos no están ahorita verdad aj si es que este Bueno uno ni usó ecut Service no uso puls y alguien otro ni siquiera usó la cola o sea usaron una cola para hecha en Java pero pues ahí o
(03:08) sea este de hecho las implementaciones que están en Java las vamos a ver probablemente en la sec kwi pero pues sea ya entonces no sé pero bueno no sé cómo se les ocurrió Pero bueno este Sí yo creo que es la falta No porque si dice ahí que con Y utilizando la cola no secuencial pero pues voy a ver este bueno Espero que no haya más así porque si no pues sí sería un problema mío de redacción no pero voy a ver pero no todavía no está nadie del equipo verdad Bueno pero este también Uh bueno el error este de bueno eh que creen que que
(04:01) los futures este bueno la forma No en la que se guardan las operaciones en los futures es justo como suceden solamente es justo como se les dan a los hilos no pero no como suceden entonces hay quien confundió las inconsistencias Pero bueno eso es como nada más ahí o sea sí le salió pero este las inconsistencias no las registraron bien pero yo creo que vamos a usar otra vez executor service así como que para la práctica cuatro cuando veamos cómo se desempeñan los spinlock estos los Ah bueno Spin ya les dije no pero los bueno son candados más
(04:34) este más chidos no que se utilizan en la práctica Este Entonces yo creo que les voy a explicar así bien porque s quedó esa duda no de los de los futures de si es justo el orden que en el que se hacen las operaciones o no también les quería hacer otra pregunta antes de iniciar que si este alguno de ustedes va a la Facultad o sea por ejemplo o no no van ya o sea ustedes trabajan y nada más la toman esta en línea o así o si suelen ir 10 Sí vale vale bueno es que en tres semanas este en la en la este TR semanas Sí sí en TR semanas es
(05:29) la semana la tercer semana no de O sea no de esta la siguiente ahora sí que la siguiente el miércoles m probablemente no pueda darles la clase Porque este voy a ir a la a la Bueno al imate al instituto de matemáticas este mi asesor está dando ahí una charla bueno está dando una clase no Entonces me dijo que si podía dar una una clase A sus alumnos bueno sirve que yo practico para el congreso al que voy a ir así que igual y si alguien va no pero bueno yo les aviso con tiempo si alguien va para ver si pueden ir no este o sea no es
(06:15) obligatorio no pero para que pues no se pierda completamente la clase pues como que quien quiera ir pues que vaya No pero les aviso bien vale Qué día y a qué hora pero es como la hora de la clase o sea nada más como sería como en vez de tenerla en línea pues nada más sería la única ocasión no que si nos sea bueno vernos no en presencial Este pero no sea es como es sobre en mi artículo Vale entonces O sea sí es sobre de hecho es todo sobre concurrente eh Y un poco con distribuido pero este no es O sea no es como que venga en el examen no nada así
(06:56) o sea es algo extra Pero bueno les les les aviso con tiempo no si alguien va y le queda de paso Pues bueno este o quien quiera ir también no entonces bueno Esos son los anuncios hasta ahorita Vale entonces nos habíamos quedado en que habíamos visto registros seguros registros atómicos y regulares registros seguros atómicos irregulares y bueno estos los habíamos visto no en la la tablita de consistencia Eh entonces un registro lo podemos definir como Dependiendo el tipo de valor que soporta O sea que guarda Dependiendo el número de hilos o de
(07:51) Hilos de escritura o de lectura que tenga no que lo puedan leer o escribir y dependiendo la consistencia la consistencia podía ser segura Regular o atómica Entonces esta consistencia lo que nos dice es qué vas a hacer cuando exista concurrencia Entonces tal cual la consistencia la habíamos visto no eh vamos a ver cómo se relacionan las llamadas de escritura y lectura cuando son sucesivas no O cuando se traslapan entonces en general eh a ver si tengo una para escribir todo vo a tener que [Música] sacar Ah creo que H acá atrás
(08:47) tengo bueno saco [Música] una Entonces teníamos este registros bueno tenemos no la grafiques los grados de consistencia Y tenemos los registros los seguros los regulares y los atómicos no y ahora sí que van de de menos a más este consistencia en los tres en los tres no al recording in
(10:10) progress Hola Se me fue Se me fue el internet este ya todo bien gracias entonces tenemos de menos a más consistencia no los tres que compartían ambos en los tres no este no cosas anotar de estas tres en en las tres si este si un este Bueno si un si un precede a un re no entonces el re regresa lo último escrito en las tres no las tres en eso
(11:21) Es igualito si dos dos escritura dos este llamadas no una escritura y una de lectura y por ejemplo Esta es la el Wi no y este es el r Entonces si la escritura escribe uno el re debe leer uno no O sea siempre sucede así si no hay si no hay este precedencia bueno perdón si no hay este concurrencia no al contrario si si se precede O sea si hay una línea de aquí acá siempre se mantiene en las tres no lo que cambia eh No este se diferencia cuando e este y re se traslapan eso es lo que se diferencia entonces este en los registros seguros
(12:21) no no Bueno aquí tomando no en los registros seguros si se traslap entonces regresa cualquier valor en el rango de valores No eso regresa los registros seguros los regulares o sea contestando est el la dos eh regresa e un valor viejo o nuevo no O sea el valor con el que te trasladas o o sea el valor nuevo o un valor viejo no el que ya está escrito el último escrito es eso te dicen los regulares y el el atómico lo que nos dice es Si regresa un valor Bueno lo vuelvo a escribir regresa igual un valor nuevo o
(13:27) viejo Pero además más si una lectura regresó el valor más actual o sea el valor nuevo eh regresa el nuevo también no Esa es como la Esta es la este la condición Vale entonces eh Ya haciendo resumen no en las tres si hay precedencia respeta esa precedencia no pero si hay traslape entre gr y brits los seguros van a regresar cualquier valor en el rango de valores o sea son los peores no los regulares van a regresar sí lo copié quéda van a regresar un valor
(14:40) e yo creo como se copió bueno los regulares van a regresar si se traslapa el ril van a regresar un valor viejo o nuevo y de hecho no importa no puede ser que que en los regulares no podíamos tener cosas así como extrañas no O sea podía ser que que tienes este un gr eh un read no y aquí dos reads este por ejemplo gr de uno gr de dos y este puede ser que lea dos y este puede ser que lea uno no O sea quiere decir que este le un valor viejo este y este le un valor más nuevo o sea bueno en la escritura sucede no de esto
(15:25) de uno a dos pero las lecturas leen dos a uno entonces como que ahí está extraño no pero los regulares puede pasar eso y en los atómicos ahí Sí además si una lectura la lectura anterior o sea regresa un valor nuevo Pues yo también ocupo regresar el valor nuevo no O sea no puede pasar esto en los atómicos es la diferencia pero sí puedes regresar un valor nuevo o viejo no O sea como Pues con como la laliz habilidad te trasladas con alguien regresas el valor este anterior no o el por el que te tras la paz Este Entonces es la diferencia de estos
(16:04) tres vale Y entonces ya de ahí tenemos los seguros son los más este como bueno fáciles de decir no e simplemente pues regresa cualquier valor en el rango de valores pero los regulares nosotros habíamos visto estas tres reglas que también vimos para los atómicos no eran estas tres eh Y bueno esto ya Eh pues como que se les comenté ahorita no pero bueno la primer regla es justo no siempre tienes que leer un valor que ya está escrito no O sea no puede ser que leas un valor que pues no sea escrito luego este tienes que leer
(16:46) el valor más actualizado si es que no te trasladas con nadie eh Entonces no puedes leer el valor viejo tienes que leer el último en este caso y en los regulares Pues aquí no está el ejemplo no que si pasa que pues puedes leer un valor este viejo a pesar de que el anterior leyó un valor nuevo cosa que en los atómicos no las reglas que vimos Vale entonces o sea bueno se se puede ver como resumido así no a grandes rasgos en esta Eh bueno si en esta sí O sea si no se trasladan como ordenas si sí sigue estas reglas no para cada uno
(17:32) entonces nos quedamos aquí nosotros podemos implementar registros poderosos a partir de los más simples Y esto es la contribución Bueno sí contribución dejen escribo aquí contribución teórica vale es la contribución teórica y es inter an esto porque quiere decir que por ejemplo en Java no a partir de registros pues que no cumplan con consistencia no incluso registros seguros podemos construir registros atómicos es decir por eso es que existe volátil no O sea la contribución teórica Pues sí nos lleva a la práctica no O sea
(18:22) no no se acabe el mundo porque tengamos cosas bien horribles a nivel de caché sí podemos construir registros atómicos no eh Y bueno por ejemplo ya teóricamente no O se ya como está en Java pues no sabemos no pero este regularmente toman de la teoría o lo adaptan a la práctica basados en la teoría pero este por ejemplo en el libro nos platican las las este las transformaciones por ejemplo en libro te transforman un un registro seguro de solo escrit ura y solo de lectura o sea por uno solo a un registro seguro en el que varios tenemos varios
(19:06) lectores y un solo escritor este y luego bueno transformación no de del registro seguro de varios lectores un escritor a una consistencia Regular o sea como que no por ejemplo aquí transforman este la transación va en el en el número de lectores no y aquí la transformación es en la consistencia e y bueno entonces acá tenemos este Ah mira por ejemplo aquí transforman de boano a a a este multivaluado no es como que aquí la transformación la hacen en el tipo tipo de dato no aquí la transformación es este regular a
(20:07) atómico este y bueno interesante no es de varios lectores un solo escritor a a un single writer sle reader no O sea un solo si no tiene tipo Entonces es multivaluado así si no tiene tipo es multivaluado se acepta lo que sea sí pero como por ejemplo o sea como que te van van tomando no O sea en realidad es este implementación sobre implementación no esto ya este implementado se ve una locura no porque este considera este no y luego sobre este anterior construyes este y luego sobre este construyes este y ya este te permite construir el
(20:53) atómico pero es interesante no porque el multier single writer o sea un uno de varios lectores un solo escritor te permite construir un solo registro atómico que sea de solo lectura de uno o sea Bueno solo lo puede leer uno y solo lo puede escribir uno no este y y ya de ahí no transforman de atómico a a que varios lo lean no varios lectores y luego de varios lectores varios escritores atómico y ahora sí de bueno digamos que este es este de acá no y ya de estos se salen dos sale el de varios lectores varios escritores o sale
(21:37) el snapshot atómico que es el que vamos a ver este ahorita no Bueno yo creo que ya el miércoles pero este Pero bueno o sea es como que es la contribución teórica vale o sea como que si bueno haciendo el análisis no cosas que tenemos en Java para para jugar no nuestras herramientas en Java tenemos este candados no tenemos volátil Y tenemos la paquetería atomic que vimos ayer una implementación no de Bakery este que usa estas primitivas atómicas Entonces tenemos ahí nuestra nuestro Sí nuestra caja de herramientas
(22:18) no entonces eh Como que este capítulo se centra en decirte que si tenemos registros volátiles no es porque los podemos construir desde no tener nada de consistencia no O sea de la nada o sea de regresar lo que quieras cuando te traslapes hasta Eh pues registros atómicos no O se lo podemos construir no importa o sea es la razón por la que tenemos registros volátiles en Java no o sea es como que todo el bagaje teórico no de Por qué pues nada más le ponemos volátil y nos evitamos cosas extrañas no este porque pues sí vimos no en los
(22:57) programas de hecho pues ya ni siqu era como sabemos bien qué es lo que nos hizo el programa Cómo reordenó qué es lo que se puso a leer no este Entonces es como esta este capítulo es mucho no lo que hay abajo Lo que hay abajo en la teoría y este y bueno entonces sí o sea es este esta pregunta no podemos implementar cualquier objeto a partir de los registros más poderosos y también a partir de los registros más débiles o sea como no sé no podemos implementar desde aquí hasta acá pues no así directamente pero pues podemos
(23:33) construirlo no O sea vamos de aquí a acá y luego no sé de aquí acá y luego de aquí al atómico y del atómico pasamos al multier y por fin llegamos al snapshot no O sea sería mucha herencia sí horrible no Sí o sea todos todos se ocupan con todos pero les digo no O sea Está interesante en el libro están los códigos y y funciona no O sea ahora sí que este como que estos serían por ejemplo para llegar aquí no sería pasos para construir este un registro volátil no un registro volátil o de pasos no este o sea si no tienes nada eh
(24:27) si nada más tienes no esto Ah pues con esto te asegura que vas a construir un registro volátil No hasta ahí y ya este o sea como que para que lo hagas no Tú desde cero pero no lo vamos a hacer no Sí o sea o sea en la práctica si hacemos que hacemos este desde cero pues candados no O sea este la práctica dos pues nada más usamos sincron sea usamos herramientas que ya nos provea pero en la práctica TR nosotros los construimos los candados no O sea no no usamos ya los candados hechos construimos un candado por ejemplo el de peterson no
(25:05) para cuatro hilos construimos Bakery de forma pues si no medio chafan no pues este el que van a construir ustedes porque no es una generalización no para cuatro hilos y está este último cado que tampoco crean que me quedó muy increíble no pero el que les compartí el de ber que yo les compartí que es paraos este y bueno pero también se construyó desde cero no O sea no no ocupamos una herramienta de l Bueno volátil no pero este no ocupamos la el la herramienta de candado de LL este Pero bueno o sea no vamos a construir una un registro
(25:42) volátil eso ya como que es más abajo vale pero digamos que lo que lo desde cero no lo que construimos pues son candaditos por ejemplo construimos también una cola no una cola este pues ya con consistencia decente no con lados Este pero bueno entonces diga les digo como que esta es la idea o sea en este punto estamos no eh abajo de volátil entonces eh Y en el libro te platican no O sea está la implementación pero me doy cuenta que pues como no lo vamos a ocupar no no lo vamos a implementar Pues siento que no tiene
(26:21) casa que nos detengamos tanto a ver vale este o sea las transformaciones porque hecho aquí Saqué el libro en el [Música] capítulo cuatro está por acá Ah no es el de s este en cuatro Ah miren Aquí está por ejemplo aquí en el libro te platican no este las construcciones y están todas todas eh este por ejemplo no te van escribiendo Cómo serían o sea son pseudocódigos pero te platican eh cómo vamos a hacer la construcción de de boano de de booleano seguro multier single writer este a partir de un registro bolean no
(27:16) e y es así de ahí empiezas Luego haces un un registro buo una construcción que sea regular boleana de de multier single writer no a partir de un registro bule es como la van haciendo No o sea literal en este capítulo te van comentando Cómo se hacen las transformaciones hasta llegar a volátil no este y sí O sea por ejemplo en laa por ejemplo los atómicos se construyen y Y eso así toda es una locura no este Pero bueno ahorita les platico así a grandes rasgos para que Pues si lo quieren leer no les sea más fácil que
(28:01) hace cada cosa pero miren los atómicos usan una clase que se llama pues la como que el St no O sea como que como de etiquetas no es lo que usa la clase atomica pero pues bueno este la transformación de un registro seguro a un regular no Simplemente consiste en que en la implementación no en el pseudocódigo e pensamos no que Este es un registro seguro no y y solamente puede ser escrito y leído por alguien este y para transformarlo a un registro regular vamos a poner dos registros seguros safe y safe no entonces este y dos registros seguros
(29:01) ambos son single writer single reader entonces recordemos que los seguros lo que hacen es que eh Te regresan cualquier valor en el rango de valores si es que se traslapan con alguien entonces la idea de la implementación es que me pongo un poquito más abajo la idea de la implementación es que en un registro te va a funcionar para guardar digamos que la nueva eh o sea el nuevo valor y en el otro va a haber una copia vieja de este valor entonces La idea es que este si existe un traslape no de una escritura con una lectura por ejemplo no write con
(30:01) un read y por ejemplo pues Antes había un cero no entonces la All copy va a tener este cero y se va se actualiza después Este Entonces cuando el re se traslape con el Wi ya no es que va a tener O sea no es que pues no va a sa ver qué se está escribiendo no va va a poder regresar el valor anterior el valor viejo porque pues el registro regular va a ser dos seguros Vale entonces este seguro va a estar por ahí guardado no la copia vieja y no sé no entonces la copia nueva va a ser uno entonces el registro bueno el
(30:44) hilo que está haciendo el re el hilo a y el B el hilo que está haciendo el re que es el hilo B va este a tratar de leer el primero no y por ejemplo si este se está trasladando con el otro no por ejemplo Entonces si Ah no importa regreso la copia vieja que esa va a ser escrita después no O sea no importa regreso simplemente el valor viejo no entonces esa es la idea cómo separar no el el la escritura por como que el respaldo entonces la idea para para transformar simplemente de un registro seguro a un regular vale luego esta otra transformación es
(31:30) de un regular a un atómico Y esta es como la Tri O sea de seguro a regular es muy fácil nada más como Pon dos no Ten un respaldo y si se traslapen no importa el respaldo no y regresa a eso alguno de los dos no se va a traslapar no es es la idea este entonces regresa siempre el respaldo pero con los de regulares atómicos para este no O sea el regular Pues que te dice regresa el valor nuevo o el viejo en qué no me importa o sea si la lectura siguiente regresó un valor todavía viejo no Aunque yo regresé el nuevo no importa pero
(32:17) este si recordamos en los atómicos nos importa que las lecturas se hagan también de forma atómica es decir que no este que no no se regresen valores viejos no entonces recordando Bueno voy a volver a poner aquí no El ejemplo de qué es lo que no no se puede hacer este no si tenemos un gr c un gr 1 este si lee el uno este otro debe leer también el uno no entonces e no puede leer un valor más viejo que la lectura anterior entonces esa es la idea y basados en esta idea o sea digamos que en esto es lo que va a motivar la
(33:12) transformación entonces eh No sabemos que bueno vamos a abstraer vale o sea aquí pues tenemos el regular no que son dos seguros entonces Bueno vamos a pensar que ya o sea nos vamos a quedar con el regular vale pero Nosotros sabemos de nuestra mente que son dos seguros entonces así un regular simplemente es una cajita no Entonces para transformar al atómico lo que vamos a hacer simplemente es eh voy a tener un registro regular no y voy a tener otro entonces este otro lo que nos va a guardar es un time stamp vale Y entonces
(34:02) este digamos que yo voy a escribir no sé Bueno y este va a ser el el valor no este va a ser el registro del valor y ambos pensemos que son regulares no entonces eh digamos que por ejemplo si yo actualizo aquí un valor No sé no le pongo el valor actualizar pues entonces pongo el Time stamp no este eh No sé H por aquí tenemos no el Time St Entonces no sé va en cero no Entonces tú dices Ah yo lo puse cuando vi el este el Tim Stand en cero no y Y entonces cuando tengamos una situación otra vez no acá Entonces cuando tengamos otra vez
(35:00) una situación como esta de acá las escrituras tienen el cometido no de poner el timestamp Entonces por ejemplo si este escribe claramente va a tener un timestamp no s igual a y y este va a tener un timestamp igual a i + 1 entonces la lectura este cada vale Al momento de leer también va a regresar a un timestamp no y va este por ejemplo este va a decir No mira yo leí el Time y+ un y este va a decir Este voy a leer No si si lo que Leo o sea digamos que esta segunda va a decir si lo que leí sí voy a ponerlo as si el timestamp de lo
(36:01) que leímos como el no es mayor al timestamp de lo que este el otro Bueno no s No sé có bueno si el amp lo que le no es menor que lo que leyó alguien precedente a ver si el No aquí el este es lo que va a regresar vale de aquí va decir stamp de lo que leí es menor de lo que leyo alguien precedente al timestamp es este el otro registro regular que ponemos al lado del
(37:06) value vale eso es el Tim entonces cada vez que el cometido O sea que tienen todos los hilos los hilos writers van a escribir su valor y van a ver este el timestamp no este que tenía anteriormente este este registro y le van van a sumar uno no Y entonces por ejemplo pues este puso uno no luego y alguien llega dos y dice Ah mira el Time estaba en cero Pues yo le pongo uno y así vale entonces como el registro no esto se ve primero esto después esto después así No todos van aumentando Entonces el cometido o eso van a hac los writers van a revisar van
(37:50) a aumentarlo y los los readers los hilos que lean van a leerlo y además van a decir yo I un Y corresponde al timestamp I + 1 no Y entonces el siguiente cada lectura siempre va a revisar eh va a leer no va a leer el el registro y va a decir si el timestamp de lo que leí es menor de lo que leyó alguien precedente o sea y aquí la construcción va a quedar de tal forma que que las lecturas puedan leer también lo que leyeron las otras vale como que aquí Está pesado no sea Está pesado el asunto porque no solo te importa saber qué leyeron O sea en qué
(38:34) forma se hicieron los gdes también te importa saber en qué orden la lectura que te precedió leyó O sea qué valor leyo entonces aquí se hace una comparación No si el timestamp de lo que leí no en el gritter o sea de lo que leí de lo que estaba escrito es menor de lo que leyó alguien precedente No ahora sí que si si yo real o sea como que la pregunta es si yo leí un valor actualizado no este pues eso regreso pero si alguien leyó un valor más nuevo entonces voy a regresar lo que leyó ese alguien Esa es la aquí El dilema vale de las de lo que
(39:15) hacen las lecturas entonces este aquí no sería si el timestamp de lo que leí es menor de lo que leyó alguien precedente entonces eh regreso lo que leyeron no lo que yo leí Lo que alguien leyó porque sabemos que Ajá inmediata anterior porque comparar toda la lectura sería muy ineficiente sí Bueno aquí importante Eduardo que no nos estamos preocupando por eficiencia vale solo por construir un registro atómico entonces bueno esa es una pero la realidad es que tienes que leer todas las lecturas anteriores de todos los
(39:54) hilos Entonces en realidad esto se ve con [Música] como una así por ejemplo tenemos de cer a un no eh perdón de n un hilos entonces cada hilo tiene escrito su última lectura no por ejemplo el hilo cer este el último valor que leyó Pues fue el I + 1 no y el ese otro le yo el I má el I + 2 no Entonces tú al momento de leer o sea vas a decir yo regreso lo que leyó por ejemplo no tú estás leyendo el registro es es este par no Y tú estás viendo que es i+ 1 ejemplo este hit hil y pues aquí hay un valor así cualquiera Y este es el Entonces tú vas
(40:54) a revisar el registro pero también vas a revisar la relación de todas las lecturas de todos Entonces vas a finalmente regresar el el I por ejemplo vas a ver no si lo que está escrito es I + 1 pero este hilito no el hilo n - 1 le yo y + 2 entonces yo regreso y + 2 y regreso el valor que tiene asociado el hilito n má n -1 es lo que se hace vale es ineficiente es horrible no pero nos da la garantía de que podemos garantizar que todos los hilos se van a formar no O sea este que realmente vamos a poder ordenar las lecturas entonces esa es la idea de
(41:40) la transformación es ineficiente Sí este entonces o sea como que quise dar una idea no como que cuando me dicen Oy profesora Y si utilizo volátil no este en todo a todo le pongo volátil Pues sí O sea va a ser ineficiente o sea garan atomicidad o sea este que las lecturas se ordenen siempre no Que tu código nunca se reordene que todo sea visible garantizar eso es pesado es pesado O sea sí e bueno Pues habría que Vera Cómo están Bueno sí están los estudios no de cómo cuánto tiempo tardas en leer algo volátil a cuánto tiempo tardas tener
(42:22) algo que no que no es volátil no entonces Bueno ya sí O sea este el que nos importa ahorita Bueno ahorita de todas estas transformaciones Pues ahorita al comentarles esto simplemente como que damos por hecho no O sea les digo que no Quiero meterme haí tanto porque luego Met un montón y no no llegamos entonces necesitamos una estuctura con referencia a los hilos y registros que guarda el valor leído y el timestamp Exacto quiere decir que tanto los H los writers tienen que poner un timestamp pero también los H los
(43:01) readers tienen que poner un timestamp de Qué fue lo último que leyeron Y entonces cada vez que tú vas a leer algo Tienes que revisar lo que está escrito pero también lo que leyeron entonces comparar si vas a regresar lo último leído no O sea bueno si o sea si realmente lo último leído es el valor actualizado este si no es así pues ocupas regresar el valor actualizado leído por alguien más no Y entonces así te aseguras que nunca va a salir un valor más viejo que alguien que ya hizo su lectura y leyó un valor más nuevo
(43:38) no vale entonces sí sí muy bien muy bien Eduardo Vale entonces les digo no ahorita ya nos saltamos todos estos vimos todos estos más bien no nos vamos a saltar todos estos ya le encante la teoría y que quiera ver las demostraciones y las implementaciones Bueno este espero que les haya ayudado no esto que les comentó de cómo se hacen las transformaciones y de por qué Por ejemplo tenemos toda una clase de de Stand values No mira aquí están las estampas de tiempo o sea hacen toda una una clase eh En donde la idea es ir aumentando no
(44:22) miren por ejemplo hasta aquí comparan los timestamp yao este y ya esta clase la usan ya para hacer la construcción entonces utilizan registros de tipo St Val para decir cuál fue la última lectura y cuál es el último estampado no escrito en el gr y así entonces bueno es ahora sí que el cuento el cuento corto es esa transformación Eh entonces Ah bueno entonces bueno el artículo es este es es interesante esta historia a ver sí que de esa historia teoría bonitas hgan de cuenta que bueno Esto es lamport este de aquí es lamport ya creo que más o menos
(45:08) por ahí este sigue vivo en nuestra en nuestra época creo que más o menos ya se ve así no pero este Eh Pues en esa época no como en los 70s cuando él presentaba kery dice que su algoritmo necesita eh registros atómicos pero hagan de cuenta que en los 70s o sea ahora sí que hagamos cuentas no 70as quiere decir que no existía ni Java no O sea Java Java no existe y tampoco existen las multicores No ni ni las multicor o sea imagínense qué mente no para que se le ocurriera eso Entonces este él Afirma no que que ocupa registros atómicos para para que
(45:59) funcione correctamente y de hecho los menciona así porque él cree No Bueno aquí está creo que Ajá sí él cree que la implementación de estos era trivial no obviamente pues estos registros no estaban ni estudiados ni implementados no pero él dice yo ocupo un registro que me permita que las las escrituras sean atómicas pero también las lecturas no o sea esto que vimos al Al final este que que regrese yo un valor viejo nuevo pero que además si alguien le yó un valor más nuevo pues regresar él se valor No él dice esto y Define no los registros
(46:40) atómicos dice yo ocupo que mi programa cumpla con esto O sea ahora sí que andaba definiendo no los campos volátil pero pues o sea los 70s no teníamos ni llva ni multicor no entonces este y lo definió así O sea él dijo Yo quiero un registro así porque é pensaba que que la implementación era trivial o sea dijo pues qué qué puede ser no ya al momento de analizarlo y y es interesante este el el paper este de los registros que hizo salió bastante después me parece que en los 90 e y ya pues ahí se dio cuenta que las
(47:17) transformaciones no eran triviales no O sea que no era trivial pedir que fuera atómico y Bueno aquí les puse esta liga de Z así no está no está larga vale o sea son y creo que aquí les puse los segundos justo en donde habla de registros atómicos este por si la quieren ver o sea él hablando No de hecho te explica como de qu es un registro atómico creo que te explica también la transformación de regular atómico y este te cuenta no la la situación esta con backery entonces este bueno este concepto de atomicidad Entonces no
(48:00) como que es es pesado no nos dice que que que las operaciones suceden en un punto atómico pero cuando son o sea cuando queremos que todos vean lo mismo Está pesado no O sea ocupamos eh andar inspeccionando lo que todos leen no Casi casi que todos tienen que que pasar lista no O sea decir yo Leí lo último que leí fue esto no Y tú tienes que revisar así entonces ese concepto de atomicidad es pesado no Pero bueno usamos un registro Bueno aquí no usan un registro de single writer single readers para construir multi
(48:37) readers single writers no ay Bueno aquí lo puse al revés pero o sea este es de un solo lector un solo escritor y este de acá es de varios lectores no y un solo escritor entonces hacen esta transformación aquí no y nosotros vamos a ver esta de acá esta de aquí simplemente para hacer esta transformación simplemente lo que nos dicen es agrupa varios single writers single readers y permite que los lectores lean todo no pero solo escriban en su registro S como que esto como que bueno esta transformación para de aquí acá
(49:41) pues es así no O sea nada más Pon un arreglo no y todos son single writers single readers y este y entonces nada más permites que los gr que un hilo solo pueda escribir en su propio registro no O sea él escribe en el hilo I en el registro I este escribe en el registro perdón el registro uno no este en el registro y Y entonces los readers pueden leer todo no Y entonces este este conjunto no de registro single writer single reader nos dan un registro multier single writer no O sea como que de ahí así va no vamos creando entonces
(50:27) entonces bueno este Ese es el último no nos quedamos en tenemos a los multi reader single Entonces esto quiere decir que multier muchos lectores un solo escritor no solo un escritor Entonces ya los snapshots atómicos Okay no está bien Podemos leer múltiples registros no pero el snaps atómico surge Porque queremos leer registros así de forma atómica varios no múltiples registros de forma atómica Entonces qué hacer Bueno pues miren un objeto de Snapchat se construye construye una vista
(51:31) instantánea de un arreglo atómico de registros e entonces aquí Bueno espero que cosas que no conocemos no en est pu bueno claramente el Snapchat atómico no pero bueno En eso estamos la vista instantánea Qué es eso bueno simplemente es una copia de lo que está vale o sea nos vamos a quedar ahorita con eso Entonces construyo una copia ahora hgan de cuenta que es como si le tomara una foto a todo lo que está escrito en el arreglo atómico de registros este arreglo atómico son puros registros multi reader single writer en donde quiere decir que a cada
(52:26) hilo de un registro Entonces por ejemplo tenemos el hilo al hilo un hasta el hilo n no y aquí está el hilo I Entonces el hilo I le corresponde su registro I y el registro el hilo I lo que va a hacer es que él pues va a escribir en su solo registro Pero va a poder leer e todos no Para qué para construir esta vista instantánea y y o sea es como una foto no tomarle foto a todo lo que está escrito en todos los registros Pero además quieres que esto suceda como ya les comenté no sea queremos leer de forma atómica O sea que
(53:08) literal le tomes una foto clac no y salgan todos o sea como que sin moverse no entonces Bueno un Snapchat atómico va a constar de 2 Met 2 Met métodos principales va a tener este el método scan que va a ser este que nos va a construir la vista o sea se va va a ser un escáner no Y mientras el método update va va a escribir el valor V no en el registro de ese proceso Vale entonces bueno comoo se ve una interfaz de un Snapchat pues les digo no Simplemente tenemos dos métodos update y scan entonces scan pues valer no del tipo
(53:54) este pues que esté guardado en en los registros no y update pues simplemente va a este escribir el valor en tu propio registro entonces Este sí entonces bueno la propiedad clave de de de este objeto secuencial o sea analizándolo como objeto secuencial es que el método scan regresa una colección de valores Y esta es no O sea la vista pues es la colección de valores que representa el estado del sistema no vista o también podríamos decirle como la foto no este entonces cada scan corresponde a la última actualización o sea como similar
(54:45) no a los registros o sea qué regresa una lectura pues lo último escrito no Entonces qué regresa un scan pues lo último escrito pero en todos los registros No pues eso va a regresar el escan e Y entonces lo podemos ver así como que el scan va a regresar la última llamada update no O sea pues sí claramente no O sea el update son aquí los los gdes no este y muy interesante no que lo precede o que es concurrente por qué Porque estamos hablando de atomicidad o sea de laliz habilidad no Casi casi que son Bueno sí O sea este concepto de
(55:22) atomicidad y de laliz abilidad son equivalentes vale la diferencia es Es que la atomicidad estuvo definida para los registros inicialmente y la linealiza bilidad eh surge surge después a para generalizar para cualquier objeto pero eh la laliz abilidad USA o sea para definirse no sé si si hay una definición usa este concepto de atomicidad ahora sí que Qué fue primero pues la definición de los registros atómicos y luego salió el concepto de laliz abilidad Pero bueno o sea como que si me escuchan Así es porque en la teoría se o
(56:05) sea son son iguales no intercambiables pero bueno entonces nos ocupamos que el scan y el update se in realizables entre ellos no entonces ya analizando esto no de forma así este más estricta las vistas obtenidas por el escan no O sea el esan se hace lo realiza así algú hilito y te va a regresar una vista Vale entonces Esta es la vista Entonces esta vista [Música] este regresada por ejemplo por este método scan no supongamos que sucede así en el tiempo no Entonces por ejemplo no si tenemos aquí eh una una un intervalo No
(56:57) aquí está ejecutando el scan y luego tenemos este otro no scan Y regresamos la vista V prima vale eso es otra vista Entonces tenemos un update por aquí no este e no sé vamos a ponerle a no Entonces supongamos que este es el proceso uno y este es el proceso dos no entonces el update pues escribió aquí el proceso dos escribió ahí su update a Vale entonces la idea de estas Es que todas las vistas se van a relacionar puede ser que que esta vista sea un subconjunto de esta o al revés no pero siempre se van a relacionar Por qué
(57:49) Porque suceden de forma atómica Entonces por ejemplo si este esan se hizo después que este update entonces a debe estar en B No pero como es concurrente a este puede ser que a esté en v o puede ser que a no esté en v vale Y bueno ahí le dejamos pero este bueno igual se les olvida para el miércoles pero volvemos a repasar esto de los snapchats Okay entonces Que tengan un buen puente nos vemos el el miércoles nosotros Ah igual cualquier duda que tengan de su de su práctica o su tarea tambén tamb este me escriben
(58:31) no vale gracias Nos vemos a luego lendo puente sí
